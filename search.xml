<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 指针上</title>
      <link href="/2024/05/21/pointer1/"/>
      <url>/2024/05/21/pointer1/</url>
      
        <content type="html"><![CDATA[<p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🙋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 继续C++ Primer 第五版的学习</p><p>可以先看看这两篇 或许可以进一步加深一下对指针的理解</p><p><a href="https://blog.csdn.net/qq_53131867/article/details/134937138?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171630129616800211536873%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=171630129616800211536873&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-134937138-null-null.nonecase&amp;utm_term=%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4450">指针和数组</a></p><p><a href="https://blog.csdn.net/qq_53131867/article/details/134842073?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171630129616800211536873%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=171630129616800211536873&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-4-134842073-null-null.nonecase&amp;utm_term=%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4450">指针简介</a></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 上一次讲了 C++中的引用，总结一下指针和引用的主要区别。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>指针是一个变量，其存储的是另一个变量的地址。而引用是一个别名，它和被它引用的变量共享同一内存地址。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>指针可以被赋予空值（即<code>NULL</code>），而引用必须在定义时初始化，并且不能被赋予空值。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>对指针的操作不会影响其指向的变量，除非通过指针进行赋值或解引。而对引用的操作会影响其引用的变量。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>下面就开始指针的学习叭~</p><h2 id="指针">指针</h2><p>指针(pointer）是“指向（pointto)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。</p><p><strong>其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象</strong>。</p><p><strong>其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</strong></p><p>定义指针类型的方法将声明符写成*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号*:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip1, *ip2;<span class="comment">//ip1和ip2都是指向int型对象的指针</span></span><br><span class="line"><span class="type">double</span> dp,*dp2;<span class="comment">// dp2是指向double型对象的指针，dp是double型对象</span></span><br></pre></td></tr></tbody></table></figure><h3 id="获取对象的地址">获取对象的地址</h3><p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;):</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">//p存放变量ival的地址，或者说p是指向变量ival的指针</span></span><br></pre></td></tr></tbody></table></figure><p>第二条语句把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象。<strong>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</strong></p><p>一般而言，所有指针的类型都要和它所指向的对象严格匹配。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval;</span><br><span class="line"><span class="type">double</span> *pd = &amp;dval;<span class="comment">//正确:初始值是double型对象的地址</span></span><br><span class="line"><span class="type">double</span> *pd2 = pd; <span class="comment">//正确:初始值是指向 double对象的指针</span></span><br><span class="line"><span class="type">int</span> *pi = pd;</span><br><span class="line"><span class="comment">//错误:指针pi的类型和pd的类型不匹配</span></span><br><span class="line">pi = &amp;dval;</span><br><span class="line"><span class="comment">//错误:试图把double型对象的地址赋给int型指针</span></span><br></pre></td></tr></tbody></table></figure><p>因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。</p><h3 id="指针的值">指针的值</h3><p>指针的值（即地址）应属下列4种状态之一:</p><p>1．指向一个对象。</p><p>2．指向紧邻对象所占空间的下一个位置。</p><p>3．空指针，意味着指针没有指向任何对象。</p><p>4．无效指针，也就是上述情况之外的其他值。</p><p>试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。</p><p>尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。</p><h3 id="利用指针访问对象">利用指针访问对象</h3><p>如果指针指向了一个对象，则允许**使用解引用符（操作符*）来访问该对象:**</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p存放着变量ival的地址，或者说p是指向变量ival的指针*</span></span><br><span class="line">*<span class="built_in">cout</span>&lt;&lt;*p;<span class="comment">//由符号*得到指针p所指的对象，输出42</span></span><br></pre></td></tr></tbody></table></figure><p>对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//由符号*得到指针p所指的对象，即可经由p为变量ival赋值</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p;<span class="comment">//输出0</span></span><br></pre></td></tr></tbody></table></figure><p>如上述程序所示，为*p赋值实际上是为p所指的对象赋值。解引用操作仅适用于那些确实指向了某个对象的有效指针。</p><p><strong>关键概念:某些符号有多重含义</strong></p><p>像&amp;和*这样的符号,既能用作表达式里的运算符,也能作为声明的一部分出现,符号的上下文决定了符号的意义:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i= <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r =i;<span class="comment">//&amp;紧随类型名出现，因此走声明的一部分，r是一个引用</span></span><br><span class="line"><span class="type">int</span> *p;<span class="comment">//*紧随类型名出现，因此是声明的一部分,p是一个指针</span></span><br><span class="line">p = &amp;i;<span class="comment">//&amp;出现在表达式中，是一个取地址符</span></span><br><span class="line">*p= i;<span class="comment">//*出现在表达式中，是一个解引用符</span></span><br><span class="line"><span class="type">int</span> &amp;r2= *p;<span class="comment">//&amp;是声明的一部分，*是一个解引用符</span></span><br></pre></td></tr></tbody></table></figure><p>在声明语句中,&amp;和*用于组成复合类型;在表达式中,它们的角色又转变成运算符。在不同场景下出现的虽然是同一个符号,但是由于含义截然不同,所以我们完全可以把它当作不同的符号来看待。</p><h3 id="空指针">空指针</h3><p>空指针（nullpointer）不指向任何对象，在试图使用个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pl = nullptr;</span><br><span class="line"><span class="comment">//等价于int *pl = 0;</span></span><br><span class="line"><span class="type">int</span> *p2 =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//直接将p2初始化为字面常量0</span></span><br><span class="line"><span class="comment">//需要首先#include cstdlib</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//等价于int *p3 = 0;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>得到空指针最直接的办法就是<strong>用字面值nullptr来初始化指针</strong>，这也是CH+11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成(参见2.1.2节，第32页)任意其他的指针类型。另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。</p><p>过去的程序还会用到一个名为NULL 的预处理变量(preprocessorvariable）来给指针赋值,这个变量在头文件cstdlib中定义，它的值就是0。</p><p>2.6.3节（第68页）将稍微介绍一点关于预处理器的知识，现在只要知道预处理器是运行于编译过程之前的一段程序就可以了。预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须在前面加上std: :</p><p>当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用NUL初始化指针和用0初始化指针是一样的。在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。</p><p>把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> zero= <span class="number">0</span>;</span><br><span class="line">pi = zero;</span><br><span class="line"><span class="comment">//错误:不能把int 变量直接赋给指针</span></span><br></pre></td></tr></tbody></table></figure><p><strong>初始化指针</strong></p><p>使用未经初始化的指针是引发运行时错误的一大原因。和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃,而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。</p><p>在大多数编译器环境下,如果使用了未经初始化的指针,则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针,相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是,如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。</p><p>因此建议初始化所有的指针，并且在可能的情况下,尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处,就把它初始化为nullptr或者0,这样程序就能检测并知道它没有指向任何具体的对象了。</p><h3 id="赋值和指针">赋值和指针</h3><p>指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是<strong>引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。</strong></p><p>指针和它存放的地址之间就没有这种限制了。<strong>和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象:</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *pi = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//pi被初始化，但没有指向任何对象</span></span><br><span class="line"><span class="type">int</span> *pi2 = &amp;i;</span><br><span class="line"><span class="comment">//pi2被初始化，存有i的地址</span></span><br><span class="line"><span class="type">int</span> *pi3;</span><br><span class="line"><span class="comment">//如果pi3定义于块内，则pi3的值是无法确定的</span></span><br><span class="line">pi3 = pi2;</span><br><span class="line"><span class="comment">// pi3和pi2指向同一个对象i</span></span><br><span class="line">pi2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//现在pi2不指向任何对象了</span></span><br></pre></td></tr></tbody></table></figure><p>有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易,最好的办法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时，</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi = &amp;ival;</span><br><span class="line"><span class="comment">//pi的值被改变，现在pi指向了ival</span></span><br></pre></td></tr></tbody></table></figure><p>意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写出如下语句:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pi = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//ival的值被改变，指针pi并没有改变</span></span><br></pre></td></tr></tbody></table></figure><p>则* pi（也就是指针pi指向的那个对象）发生改变。</p><h3 id="其他指针操作">其他指针操作</h3><p>只要指针拥有一个合法值,就能将它用在条件表达式中。和采用算术值作为条件（参见2.1.2节，第32页）遵循的规则类似，如果指针的值是0,条件取false:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = <span class="number">0</span>;<span class="comment">// pi合法，是一个空指针</span></span><br><span class="line"><span class="type">int</span> *pi2 = &amp;ival;<span class="comment">// pi2是一个合法的指针存放着ival的地址</span></span><br><span class="line"><span class="keyword">if</span> (pi)<span class="comment">//pi的值是0，因此条件的值是false</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (pi2)<span class="comment">// pi2指向ival，因此它的值不是0，条件的值是true</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>任何非0指针对应的条件值都是true。</p><p>对于两个类型相同的合法指针，可以用相等操作符(==）或不相等操作符(!=）来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等;反之它们不相等。这里两个指针存放的地址值相同(两个指针相等）有三种可能:它们都为空、都指向同一个对象，或者都指向了同一个对象的下一地址。</p><p>需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。</p><p>因为上述操作要用到指针的值，所以不论是作为条件出现还是参与比较运算，都必须使用合法指针，使用非法指针作为条件或进行比较都会引发不可预计的后果。</p><p>3.5.3节（第105页）将介绍更多关于指针的操作。</p><h3 id="void-指针">void* 指针</h3><p>void<em>是一种特殊的指针类型,可用于存放任意对象的地址。一个void </em>指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> obj= <span class="number">3.14</span>, *pd = &amp;obj;</span><br><span class="line"><span class="comment">//正确:void*能存放任意类型对象的地址</span></span><br><span class="line"><span class="type">void</span> *pv = &amp;obj;</span><br><span class="line"><span class="comment">// obj可以是任意类型的对象</span></span><br><span class="line">pv = pd;</span><br><span class="line"><span class="comment">//pv可以存放任意类型的指针</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>利用void<em>指针能做的事儿比较有限:拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个 void </em>指针。**不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。**</p><p>概括说来，以void *的视角来看内存空间也就仅仅是内存空间,没办法访问内存空间中所存的对象，关于这点将在19.1.1节（第726页）有更详细的介绍，4.11.3节（第144页)将讲述获取void*指针所存地址的方法。</p><h3 id="练习">练习</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.18:编写代码分别更改指针的值以及指针所指对象的值。</span></span><br><span class="line"><span class="comment">//练习2.19:说明指针和引用的主要区别。</span></span><br><span class="line"><span class="comment">//练习2.20:请叙述下面这段代码的作用。</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *pl = &amp;i;</span><br><span class="line">*p1 = *p1 * *pl;</span><br><span class="line"><span class="comment">//练习2.21:请解释下述定义。在这些定义中有非法的吗?如果有，为什么?</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">(a) <span class="type">double</span>* dp = &amp;i; (b)<span class="type">int</span> *ip = i; (c) <span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="comment">//练习2.22:假设p是一个int型指针，请说明下述代码的含义。</span></span><br><span class="line"><span class="keyword">if</span> (p)<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span>(*p)<span class="comment">// ...</span></span><br><span class="line"><span class="comment">//练习2.23:给定指针p，你能知道它是否指向了一个合法的对象吗?如果能，叙述判断的思路;如果不能，也请说明原因。</span></span><br><span class="line"><span class="comment">//练习2.24:在下面这段代码中为什么p合法而lp非法?</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">void</span> *p = &amp;i;</span><br><span class="line"><span class="type">long</span> * lp = &amp;i;</span><br></pre></td></tr></tbody></table></figure><hr><h4 id="答案">答案</h4><p>答案<span class="github-emoji" style="display:inline;vertical-align:middle"><span>🏮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3ee.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.18:编写代码分别更改指针的值以及指针所指对象的值。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">int</span> *q = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改指针的值</span></span><br><span class="line">p = q; <span class="comment">// 现在p和q指向相同的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改指针所指对象的值</span></span><br><span class="line">*p = <span class="number">20</span>; <span class="comment">// 现在a的值变为20</span></span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.19:说明指针和引用的主要区别。</p><ol type="1"><li>指针是一个变量，其存储的是另一个变量的地址。而引用是一个别名，它和被它引用的变量共享同一内存地址。</li><li>指针可以被赋予空值（即<code>NULL</code>），而引用必须在定义时初始化，并且不能被赋予空值。</li><li>对指针的操作不会影响其指向的变量，除非通过指针进行赋值或解引。而对引用的操作会影响其引用的变量。</li></ol><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.20:请叙述下面这段代码的作用。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *pl = &amp;i;</span><br><span class="line">*p1 = *p1 * *pl;</span><br></pre></td></tr></tbody></table></figure><p>它首先定义了一个整型变量<code>i</code>并赋值为42，然后定义了一个指向<code>i</code>的指针<code>pl</code>。接着，它尝试通过<code>p1</code>修改<code>p1</code>所指向的变量的值，使其变为<code>p1</code>所指向的值与<code>i</code>值的乘积。</p><p>就是说先定义并初始化了一个变量i，然后pl指向i，也就是<em>pl就是i的值，即42，然后</em>pl= <em>p1 </em> <em>pl; 于是 </em>pl=42 <em>42；又由于然后pl指向i，所以i此时也被更改为42 </em> 42</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.21:请解释下述定义。在这些定义中有非法的吗?如果有，为什么?</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">(a) <span class="type">double</span>* dp = &amp;i; (b)<span class="type">int</span> *ip = i; (c) <span class="type">int</span> *p = &amp;i;</span><br></pre></td></tr></tbody></table></figure><ol type="a"><li><p>非法。因为<code>i</code>是整型变量，而<code>double</code>类型和整型不兼容。</p></li><li><p>非法。因为<code>i</code>是一个整型变量，不能直接作为指针赋值。</p></li><li><p>合法</p></li></ol><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>5⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0035-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.22:假设p是一个int型指针，请说明下述代码的含义。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p)<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span>(*p)<span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>if(p)</code>检查<code>p</code>是否不为<code>NULL</code>，即<code>p</code>是否指向了一个有效的内存地址。</li><li><code>if(*p)</code>检查<code>p</code>所指向的内存地址的内容是否不为零（或其他非真值）。</li></ul><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>6⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0036-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.23:给定指针p，你能知道它是否指向了一个合法的对象吗?如果能，叙述判断的思路;如果不能，也请说明原因。</p><p>不能。判断指针是否指向一个合法的对象，需要检查指针是否为<code>NULL</code>，以及它所指向的地址是否有效。然而，这并不总是安全的，因为指针可能指向一个有效的地址，但该地址的内容可能是不合法的或者已经被释放。</p><p>所以不论是作为条件出现还是参与比较运算，都必须使用合法指针，使用非法指针作为条件或进行比较都会引发不可预计的后果。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>7⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0037-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.24:在下面这段代码中为什么p合法而lp非法?</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">void</span> *p = &amp;i;</span><br><span class="line"><span class="type">long</span> * lp = &amp;i;</span><br></pre></td></tr></tbody></table></figure><p>void* 是一种特殊的指针类型,可用于存放任意对象的地址。一个void *指针存放着一个地址。在这段代码中，<code>p</code>是合法的，因为它被初始化为指向<code>i</code>的地址，这是一个有效的整型地址。</p><p><code>lp</code>是非法的，因为<code>int</code>和<code>long</code>类型不兼容。虽然<code>lp</code>被赋予了<code>i</code>的地址，但这个地址对于<code>long</code>类型的数据是不正确的，因此这种用法是非法的。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习 关于引用</title>
      <link href="/2024/05/21/rvalue-reference/"/>
      <url>/2024/05/21/rvalue-reference/</url>
      
        <content type="html"><![CDATA[<p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🙋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>本文主要讲讲C++的引用 是基础入门篇~</p><blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 关于引用 几个比较重要的点</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>引用相当于<strong>为一个已经存在的对象所起的另外一个名字</strong></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌺</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 另外要注意 类型不能混用</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🐳</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f433.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>相信看完后 你会有所收获~</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>⛵</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26f5.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><h1 id="引用">引用</h1><p>C++11中新增了一种引用:所谓的<strong>“右值引用(rvaluereference)”,我们将在13.6.1节(第471页)做更详细的介绍。这种引用主要用于内置类</strong>。严格来说,当我们使用术语“引用（reference)”时，指的其实是“左值引用（Ivaluereference)”。</p><p>引用（reference）为对象起了另外一个名字，<strong>引用类型引用(refersto)另外一种类型</strong>。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival =<span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival;</span><br><span class="line"><span class="comment">// refVal 指向ival（是ival的另一个名字)</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2;</span><br><span class="line"><span class="comment">//报错:引用必须被初始化</span></span><br></pre></td></tr></tbody></table></figure><p>一般在初始化变量时，初始值会被拷贝到新建的对象中。<strong>然而定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</strong></p><p>引用并非对象，相反的，<strong>它只是为一个已经存在的对象所起的另外一个名字。</strong></p><p>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refval = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//把2赋给refVal指向的对象，此处即是赋给了ival</span></span><br><span class="line"><span class="type">int</span> ii = refval;<span class="comment">//与ii = ival执行结果一样</span></span><br></pre></td></tr></tbody></table></figure><p>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确: refval3绑定到了那个与refval绑定的对象上，这里就是绑定到ival上</span></span><br><span class="line"><span class="type">int</span> &amp;refVal3 = refVal;</span><br><span class="line"><span class="comment">//利用与refval绑定的对象的值初始化变量i</span></span><br><span class="line"><span class="type">int</span> i = refval; <span class="comment">//正确:i被初始化为ival的值</span></span><br></pre></td></tr></tbody></table></figure><p>因为引用本身不是一个对象，所以<strong>不能定义引用的引用。</strong></p><h2 id="引用的定义">引用的定义</h2><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">1024</span>,i2 =<span class="number">2048</span>;<span class="comment">// i和i2都是int</span></span><br><span class="line"><span class="type">int</span> &amp;r = i, r2= i2; <span class="comment">// r是一个引用，与i绑定在一起，r2是int</span></span><br><span class="line"><span class="type">int</span> i3 = <span class="number">1024</span>, &amp;ri = i3;<span class="comment">// i3是int,ri是一个引用，与i3绑定在一起</span></span><br><span class="line"><span class="type">int</span> &amp;r3 = i3,&amp;r4= i2; <span class="comment">// r3和r4都是引用</span></span><br></pre></td></tr></tbody></table></figure><p>除了2.4.1节（第55页）和15.2.3节(第534页）将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，<strong>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</strong>，相关原因将在2.4.1节详述:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;refVal4 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//错误:引用类型的初始值必须是一个对象</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal5 = dval;</span><br><span class="line"><span class="comment">//错误:此处引用类型的初始值必须是int型对象</span></span><br></pre></td></tr></tbody></table></figure><h2 id="练习">练习</h2><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>👊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 检验一下成果叭~​</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.15:下面的哪个定义是不合法的?为什么?</span></span><br><span class="line">(a)<span class="type">int</span> ival = <span class="number">1.01</span>;</span><br><span class="line">(b) <span class="type">int</span> &amp;rval1 = <span class="number">1.</span></span><br><span class="line">(c)<span class="type">int</span> &amp;rval2 = ival;</span><br><span class="line">(d) <span class="type">int</span> &amp;rval3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2.16:考查下面的所有赋值然后回答:哪些赋值是不合法的?为什么?哪些赋值是合法的?它们执行了什么样的操作?</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,&amp;rl = i;</span><br><span class="line"><span class="type">double</span> d= <span class="number">0</span>,&amp;r2=d;</span><br><span class="line">(a) r2 = <span class="number">3.14159</span>;</span><br><span class="line">(b)r2= rl;</span><br><span class="line">(c) i = r2;</span><br><span class="line">(d)rl = d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2.17:执行下面的代码段将输出什么结果?</span></span><br><span class="line"><span class="type">int</span> i, &amp;ri = i;</span><br><span class="line">i = <span class="number">5</span>; ri = <span class="number">10</span>;</span><br><span class="line">std::cout&lt;&lt; i&lt;&lt;<span class="string">" "</span>&lt;&lt;ri &lt;&lt;std::endl;</span><br></pre></td></tr></tbody></table></figure><hr><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>答案答案</p><blockquote><p>//练习2.15:下面的哪个定义是不合法的?为什么?</p></blockquote><ol type="a"><li><p><code>int ival = 1.01;</code>是不合法的。因为<code>int</code>类型只能存储整数，不能存储浮点数<code>1.01</code>。</p></li><li><p><code>int &amp;rval1 = 1;</code>是不合法的。因为<code>1</code>是一个字面量，它代表了整数1，但字面量不能被直接赋值给引用。而且，引用的定义需要一个已存在的变量作为其目标。</p></li><li><p><code>int &amp;rval2 = ival;</code>是合法的，假设<code>ival</code>已经正确定义并且是一个<code>int</code>类型的变量。</p></li><li><p><code>int &amp;rval3;</code>是合法的，但<code>rval3</code>未被初始化，它将包含未定义的值。</p></li></ol><blockquote><p>练习2.16:考查下面的所有赋值然后回答:哪些赋值是不合法的?为什么?哪些赋值是合法的?它们执行了什么样的操作?</p></blockquote><ol type="a"><li><p><code>r2 = 3.14159;</code>是合法的。它将<code>double</code>类型的字面量<code>3.14159</code>赋值给<code>r2</code>，<code>r2</code>是一个<code>double</code>类型的引用。</p></li><li><p><code>r2 = rl;</code>是不合法的。因为<code>rl</code>是一个<code>int</code>类型的引用，而<code>r2</code>是一个<code>double</code>类型的引用。类型不匹配。</p></li><li><p><code>i = r2;</code>是不合法的。因为<code>i</code>是一个<code>int</code>类型的变量，而<code>r2</code>是一个<code>double</code>类型的引用。尝试将一个<code>double</code>类型的值赋给一个<code>int</code>类型的变量会导致数据丢失。</p></li><li><p><code>rl = d;</code>是合法的，但可能导致数据丢失。因为<code>rl</code>是一个<code>int</code>类型的引用，而<code>d</code>是一个<code>double</code>类型的值。<code>int</code>类型不能准确表示<code>double</code>类型的值，所以只有<code>d</code>的整数部分会被存储在<code>rl</code>指向的<code>int</code>类型变量中。</p></li></ol><blockquote><p>练习2.17:执行下面的代码段将输出什么结果?</p></blockquote><p>虽然<code>i</code>的值被<code>5</code>所赋值，随后<code>ri</code>被赋值为<code>10</code>，但<code>std::cout</code>会输出<code>i</code>和<code>ri</code>当前的值（不是所赋的值），此时<code>i</code>由于<code>ri</code>的赋值操作而覆盖了原本的值，<code>ri</code>输出为<code>10</code>。引用只是为其他变量提供了一个别名，并不复制原变量的值。所以<code>i</code>也是<code>10</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习  关于无符号数的计算</title>
      <link href="/2024/05/20/C-Calculation-of-unsigned-numbers/"/>
      <url>/2024/05/20/C-Calculation-of-unsigned-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="c-学习-关于无符号数的计算">C++ 学习 关于无符号数的计算</h1><blockquote><p>这篇blog 来源于C++ 的学习 当然C语言同样适用</p><p>C++ Primer 的笔记</p></blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>让我们从一个问题开始 如果你回答对了 那么就可以跳过了~</p><p>对于下面的问题</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读程序写结果。</span></span><br><span class="line"><span class="type">unsigned</span> u = <span class="number">10</span>,u2= <span class="number">42</span>;</span><br><span class="line">std::cout &lt;&lt; u2 - u&lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;u - u2 &lt;&lt; std:: endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>,i2 =<span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt; i2 -i&lt;&lt; std::endl;  </span><br><span class="line">std::cout &lt;&lt; i - i2&lt;&lt; std::endl; </span><br><span class="line">std::cout &lt;&lt; i - u&lt;&lt; std::endl; </span><br><span class="line">std::cout &lt;&lt; u- i&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> k1 = <span class="number">42</span>,k2 = <span class="number">10</span>;</span><br><span class="line">std::cout&lt;&lt;k2-k1&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;k1-k2&lt;&lt;std::endl;</span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>尝试一下最终输出什么结果</p><hr><p>揭晓答案！</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">4294967264</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">-32</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4294967264</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></tbody></table></figure><p>🤭 你答对了嘛 没有的话 可以接下去看（我刚开始也是懵的其实~）</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌺</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 首先明确一下，不管是C还是C++ 类型都是很重要的！所以先看看类型转换相关的内容，然后再来讨论上面无符号表达式转换的内容~</p><h2 id="关于类型转化">关于类型转化</h2><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>C/C++里面类型是很重要的！你能判断出下面每执行一行后，相应变量的值不？（嘻嘻梅开二度~）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b=<span class="number">32</span>;</span><br><span class="line"><span class="type">int</span> i=b;</span><br><span class="line">i=<span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> pi=i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c= <span class="number">-1</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> c2=<span class="number">256</span>;</span><br></pre></td></tr></tbody></table></figure><hr><p>答案揭晓！</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b=<span class="number">32</span>;<span class="comment">//b为真</span></span><br><span class="line"><span class="type">int</span> i=b;<span class="comment">//i=1</span></span><br><span class="line">i=<span class="number">3.14</span>;<span class="comment">//i=3</span></span><br><span class="line"><span class="type">double</span> pi=i;<span class="comment">//pi=3.0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c= <span class="number">-1</span>;<span class="comment">//若char 为8bit c为255</span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> c2=<span class="number">256</span>; <span class="comment">//若char 为8bit 那么c2是未定义的 溢出啦</span></span><br></pre></td></tr></tbody></table></figure><p>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false,否则结果为true。</p><p>当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true 则结果为1。</p><p>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</p><p>当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</p><p>当我们赋给无符号类型一个超出它表示范围的值时,结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsignedchar可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsignedchar所得的结果是255。</p><p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的(undefined)。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</p><h2 id="含有无符号类型的表达式">含有无符号类型的表达式</h2><p>尽管我们不会故意给无符号对象赋一个负值，却可能(特别容易)写出这么做的代码。例如,<strong>当一个算术表达式中既有无符号数又有int值时，</strong><strong>那个int值就会转换成无符号数</strong>。把int转换成无符号数的过程和把int直接赋给无符号变量一样:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> u= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i =<span class="number">-42</span>;</span><br><span class="line">std::cout &lt;&lt; i+i&lt;&lt; std::endl; <span class="comment">//输出-84</span></span><br><span class="line">std::cout&lt;&lt; u +i &lt;&lt; std::endl;<span class="comment">//如果int占32位，输出4294967264</span></span><br><span class="line"><span class="comment">//理由是 int 是8个字节 那就是32位 最大为2的32次方-1 也就是4294967295  也就是当-42  先转无符号数（也就是-1对应的是4294967295，依次类推）然后相加 </span></span><br><span class="line"><span class="comment">//10+（-42）=10+（4294967295-42+1）=4294967264</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>关于无符号数和有符号数</p><p><a href="https://www.cnblogs.com/lazycoding/archive/2011/03/21/unsigned-signed.html">理解有符号数和无符号数</a></p></blockquote><p>在第一个输出表达式里，两个（负）整数相加并得到了期望的结果。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>在第二个输出表达式里，相加前首先<strong>把整数-42转换成无符号数。把负数转换成无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。</strong></p><p>当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> ul = <span class="number">42</span>，u2 = <span class="number">10</span>;</span><br><span class="line">std::cout&lt;&lt; ul -u2&lt;&lt; std::endl; <span class="comment">//正确:输出32</span></span><br><span class="line">std::cout &lt;&lt; u2 - ul&lt;&lt; std::endl;<span class="comment">//正确:不过，结果是取模后的值  也是 10-42=10+（-42）=10+（4294967295-42+1）=4294967264</span></span><br></pre></td></tr></tbody></table></figure><p>无符号数不会小于0这一事实<strong>同样关系到循环的写法</strong>。例如，在1.4.1节的练习(第11页)中需要写一个循环，通过控制变量递减的方式把从10到0的数字降序输出。这个循环可能类似于下面的形式:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">std:: cout&lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure><p>可能你会觉得反正也不打算输出负数，可以用无符号数来重写这个循环。然而，这个不经意的改变却意味着死循环:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:变量u永远也不会小于0，循环条件一直成立</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> u= <span class="number">10</span>; u &gt;= <span class="number">0</span>;--u)</span><br><span class="line">std::cout&lt;&lt;u&lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure><p>来看看当u等于0时发生了什么，这次迭代输出0，然后继续执行for语句里的表达式。表达式--u从u当中减去1，得到的结果-1并不满足无符号数的要求，此时像所有表示范围之外的其他数字一样，<strong>-1被自动地转换成一个合法的无符号数。假设int类型占32位，则当u等于0时，--u的结果将会是4294967295。</strong></p><p>一种解决的办法是，用while语句来代替for语句，因为前者让我们能够在输出变量之前（而非之后）先减去1:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> u= <span class="number">11</span>;<span class="comment">//确定要输出的最大数，从比它大1的数开始</span></span><br><span class="line"><span class="keyword">while</span> (u &gt;<span class="number">0</span>){</span><br><span class="line">    <span class="comment">//先减1，这样最后一次迭代时就会输出0</span></span><br><span class="line">    --u;</span><br><span class="line">    std::cout &lt;&lt;u&lt;&lt;std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改写后的循环先执行对循环控制变量减1的操作，这样最后一次迭代时，进入循环的u值为1。此时将其减1，则这次迭代输出的数就是0;下一次再检验循环条件时，u的值等于0而无法再进入循环。因为我们要先做减1的操作，所以初始化u的值应该比要输出的最大值大1。这里，u初始化为11，输出的最大数是10。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>提示:切勿混用带符号类型和无符号类型</strong></p><p>如果表达式里<strong>既有带符号类型又有无符号类型,当带符号类型取值为负时会出现异常结果</strong>，这是因为带符号数会自动地转换成无符号数。例如,在一个形如a*b的式子中,如果a=-1,b=-1，而且a和b都是int,则表达式的值显然为-1。然而,<strong>如果a是int，而b是unsigned,则结果须视在当前机器上int所占位数而定。在我们的环境里，结果是4294967295</strong></p><hr><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤙</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f919.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 好，结束！！撒花</p><p>现在回到开始的问题你会分析了不？</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.3:读程序写结果。</span></span><br><span class="line"><span class="type">unsigned</span> u = <span class="number">10</span>,u2= <span class="number">42</span>;</span><br><span class="line"><span class="comment">//usigned 8位  </span></span><br><span class="line">std:: cout &lt;&lt; u2 - u&lt;&lt; std::endl;<span class="comment">//32</span></span><br><span class="line">std::cout &lt;u - u2 &lt;&lt; std:: endl;<span class="comment">//10+4294967295-42+1=4294967264</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>,i2 =<span class="number">42</span>;</span><br><span class="line"><span class="comment">//int 32位 4294967296-1=4294967295</span></span><br><span class="line">std::cout&lt;&lt; i2 -i&lt;&lt; std::endl;  <span class="comment">//32</span></span><br><span class="line">std::cout &lt;&lt; i - i2&lt;&lt; std::endl; <span class="comment">//-32</span></span><br><span class="line">std::cout &lt;&lt; i - u&lt;&lt; std::endl; <span class="comment">//0</span></span><br><span class="line">std::cout &lt;&lt; u- i&lt;&lt; std::endl;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> k1 = <span class="number">42</span>,k2 = <span class="number">10</span>;</span><br><span class="line">std::cout&lt;&lt;k2-k1&lt;&lt;endl;<span class="comment">//10+4294967295-42+1=4294967264</span></span><br><span class="line">std::cout&lt;&lt;k1-k2&lt;&lt;endl;<span class="comment">//32</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容易坑 </tag>
            
            <tag> C++ </tag>
            
            <tag> 无符号数的计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读——Factor Graphs for Robust GNSS</title>
      <link href="/2024/05/18/%E8%AE%BA%E6%96%87-Review-of-Factor-Graphs-for-Robust-GNSS/"/>
      <url>/2024/05/18/%E8%AE%BA%E6%96%87-Review-of-Factor-Graphs-for-Robust-GNSS/</url>
      
        <content type="html"><![CDATA[<h1 id="review-of-factor-graphs-for-robust-gnss">Review of Factor Graphsfor Robust GNSS</h1><blockquote><p>Cite : Das S, Watson R, Gross J. Review of factor graphs for robustGNSS applications. arxiv preprint arxiv:2112.07794. 2021 Dec 14.</p></blockquote><p>本文是该文的翻译版 适合大概的因子图综述阅读</p><h2 id="什么是因子图">什么是因子图</h2><p>概率建模是任何一种估计问题的一个非常重要的工具。这导致了图形模型[1]的发展，该模型使用图中的顶点对系统的已知变量和未知变量进行建模，并定义它们之间的边来表示它们之间的关系。由于系统建模中固有的不确定性，这些关系是概率性的。</p><p>一个因子图连接了这些图形化的许多类型的模型，如马尔可夫随机场，贝叶斯网络，坦纳图[2]。<strong>因子图的主要动机是将许多变量的全局函数表示为具有变量的较小子集的局部函数的乘积。因子图不是一种方法，而是一种使用其局部性结构建模任何系统的框架，即每个变量只依赖于其他几个局部变量，并且独立于其他局部变量。</strong>正如在[3]中所解释的那样，正是这种局部性特性使它在建模各种问题中非常有用，包括映射、视觉惯性测程法、运动规划、轨迹估计和深度学习。<strong>因子图被定义为一个二部图有两种类型的顶点，一个是变量（即状态向量）顶点是估计和另一个是因子顶点编码约束（例如，一组GNSS观察）应用于变量的顶点。一条边只能存在于因子顶点和变量顶点之间。因子顶点表示局部函数，它依赖于与它的变量顶点共享它的边。</strong></p><p>机器人技术中一个常见的估计问题是利用因子图框架来估计未知机器人姿态以及根据问题的其他参数。这是通过求解最大后验（MAP）问题来实现的，该问题使状态和测量值之间的概率约束因子的乘积最大化。[4]给出了一个严格的数学描述，如何解决这个最大化问题在机器人感知领域。</p><p>因子图已被视为解决估计问题的替代框架，并已被证明是非常有效的特定应用，在克隆同步定位和映射（SLAM）。由于该方法的灵活性和通过提供GTSAM[5]、g2o [6]、Ceres[7]等开源图优化库而易于实现，该框架得到了广泛的使用。<strong>虽然因子图框架已被证明对许多应用程序是有益的，但应该注意的是，框架可以等同于（即，它是一种遗传化）现有的状态估计实现（例如，卡尔曼滤波器和它的许多变体）</strong>。为了开始这个比较，我们将注意到因子图最终编码了一个目标函数，该函数通过非线性优化程序（例如，高斯-牛顿，莱夫-恩伯格-马夸特）重复重新线性化来求解。先前的工作已经证明，对扩展卡尔曼滤波的测量更新迭代和迭代之间的系统模型等价于高斯-牛顿优化[8]。结果表明，<strong>在一定的约束条件下，批处理模式下的因子图等价于反向平滑扩展卡尔曼滤波器（EKF）[9]，使系统和观测模型重新线性化并迭代。</strong></p><h2 id="使用因子图有什么优势">使用因子图有什么优势</h2><p>因子图优化比标准的非迭代卡尔曼滤波器具有一些优势，对某些应用具有一定的价值。</p><p>首先，像任何优化问题一样，<strong>它使用多次迭代来最小化成本</strong>，而不是像标准卡尔曼滤波器那样对每个状态只进行一次迭代。其次，它还将标准卡尔曼滤波器的<strong>非线性测量模型线性化</strong>，而不是用标准卡尔曼滤波器进行的单线性化。因子图也被证明可以<strong>更好地利用过去和当前时代之间的时间相关性，这被归因于估计方法的批处理性质</strong>。特别是，当在批处理模式下操作时，一个因子图将<strong>相当于一个前向滤波器和向后平滑器</strong>。</p><p>对于GNSS/INS应用，这些好处得到了[10]实验结果的支持，其中因子图已被证明在城市环境中比EKF表现更好。随着较长时间内新测量值的积累，<strong>批估计可能会失去实时性能</strong>。<strong>滑动窗口方法</strong>也可以使用类似于[11]来减轻计算成本。窗口大小已被发现对良好的优化结果至关重要，并可取决于环境条件[10]。<strong>因子图通过利用雅可比矩阵和信息矩阵的稀疏性来实现有效的计算。这有助于快速的矩阵分解和反替换</strong>。</p><p>直接从图形中删除早期的姿态可能会导致信息丢失。这可以避免使用平方根信息形式中的边缘化来删除变量从贝叶斯网络从因子图使用消除算法。<strong>由于图中的稀疏性，增量QR分解也可以有效地实现</strong>[5]。除了固定滞后平滑之外，isam2公式[12]在添加一个新的约束时，通过将因子图转换为贝叶斯树[13]来实现实时性能。<strong>对于高度非线性的测量模型，这是一种更精确的增量和平滑的方法</strong>。贝叶斯树的顶点代表了在因子分解过程中由因子图得到的贝叶斯网中的团系。<strong>只有包含在新约束中的状态和贝叶斯树中的状态以及它们在贝叶斯树中的前一个状态需要更新</strong>。Watson和Gross[14]在GNSS因子图中使用了isam2，显示出比传统的EKF-精确点定位（PPP）方法有更好的定位性能。Wen等人[15]将因子图优化应用于GNSS和GNSS-实时运动学（RTK）定位问题，显示出比EKF更好的性能。</p><h2 id="因子图如何运用于gnss">因子图如何运用于GNSS</h2><p>在[14]中详细描述了用GNSS观察结果产生的因素。<strong>在GNSS因子图中通常估计的状态是重新收发器的位置、对流层延迟、载波相位偏置和接收机时钟偏置。</strong>图1提供了GNSS因子图的可视化表示，其中ψ表示状态和测量值之间可能存在的任何概率约束。</p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202405181544533.png" alt="image-20240518154433289"><figcaption aria-hidden="true">image-20240518154433289</figcaption></figure><p>在这个特定的实现中，ψ是对每个状态的先验信念，这取决于特定的数据集和环境心理特征。<span class="math inline">\(ψ^p\)</span>是<strong>沿轨迹的两个连续状态之间的运动约束</strong>，例如，可以合并来自惯性测量单元（IMU）或车轮里程表的运动数据。在GNSS/IMU导航中使用的<span class="math inline">\(ψ^b\)</span>的一个常见例子是使用IMU预积分[16]来计算两个因子图位置之间的位移，它们之间有多个IMU测量值的积分。最后，在一个状态和从该状态感知到的测量值之间的<span class="math inline">\(ψ^m\)</span>测量约束，例如GNSS伪距或载波相位测量值。为了找到GNSS因子图的MAP估计值，<strong>我们可以找到使因子乘积最大化的状态集。</strong>然而，在实践中，这个优化问题可以大大简化采用高斯噪声假设，使问题的转换最大化因素的乘积非线性最小二乘问题的每个组件是一个马氏成本，代表归一化残差的平方和，如等式提供1，其中f（∗）在不同时期的状态映射和h（∗）之间的映射是从状态空间到观测空间的映射。</p><p><span class="math inline">\(\begin{aligned}\hat{X}&amp;=\underset{x}{\operatorname*{argmin}}\left[\sum_{i=1}^I\left\|\psi_i^p\right\|_\Sigma^2+\sum_{j=1}^J\left\|\psi_j^b\right\|_\Lambda^2+\sum_{k=1}^K\left\|\psi_k^m\right\|_\Xi^2\right]\\&amp;=\underset{x}{\operatorname*{argmin}}\left[\sum_{i=1}^I\left\|x_0-x_i\right\|_\Sigma^2+\sum_{j=1}^J\left\|x_j-f_j(x_{j-1})\right\|_\Lambda^2+\sum_{k=1}^K\left\|y_k-h_k\left(x_k\right)\right\|_\Xi^2\right]\\&amp;&amp;\text{(1)}\end{aligned}\)</span></p><h2 id="在gnss中使用因子图进行鲁棒估计的方法是什么">在GNSS中使用因子图进行鲁棒估计的方法是什么？</h2><p>如前所述，因子图框架也便于添加现有的和新的鲁棒估计方法，有助于减少欺骗攻击时的定位误差或多路径或大气效应的大噪声。下面的讨论列举了一些应用于GNSS的健壮方法。桑德豪夫等人[17]定义了开关约束（SC），这是一种提升优化[18]方法，定义了观察加权函数<span class="math inline">\(Ψ（）\)</span>，它是开关变量的函数，与感兴趣的状态参数一起估计。SC方法最初是用于SLAM中的鲁棒环闭合检测的，然后扩展到GNSS用于多路径缓解[19]。当使用开关约束时，伪距因子代价函数表示为预测和实际测量之间的马氏成本的比例版本。<span class="math display">\[\left\|\mathbf{e}_k^\mathrm{switch}\right\|_{\boldsymbol{\Sigma}_k}^2=\left\|\Psi\left(s_k\right)\cdot\left(y_k-h_k(x_k)\right)\right\|_{\boldsymbol{\Sigma}_k}^2\]</span> 其中，函数 <span class="math inline">\(Ψ\)</span>是开关变量的线性函数。为这些开关变量添加先验因子，以阻止优化使所有<span class="math inline">\(s_k\)</span>变成零。还可以添加一个过渡因子来模拟<span class="math inline">\(s_{k−1}\)</span>和在下一个时间步观测到的同一卫星之间的变化。这些开关功能有助于自动减轻错误测量（例如，可疑的多路径测量），并被认为比计算昂贵的射线追踪方法[19]表现更好。在[20]中推导出了SC的一个扩展，称为<strong>动态协方差尺度</strong>（DCS），其中开关变量从优化方法中提取，并使用残差、电流测量不确定度和先验开关不确定度分别进行计算。在计算<span class="math inline">\(s_k\)</span>后，与GNSS观测因子相关的信息矩阵用$Ψ(s_k)^2$进行缩放。<strong>最大混合（MM）</strong>[21]也使用高斯混合模型（GMM）来解决假循环闭包，但不是使用多模态不确定模型时不适合最大似然的和算子，目标函数转换为使用最大算子，如等式所示3 <span class="math display">\[p\left(y_i\mid x\right)=\max_kw_kN\left(\mu_k,\Lambda_k^{-1}\right)\]</span>SC、DSC和MM的好处已经在[22,23]中评估了具有真实世界数据的GNSS因子图应用。这两项研究都表明，在对退化的GNSS观测值进行优化时，通过使用鲁棒估计技术，可以实现实质性的定位改进。</p><p>为了扩展最大混合工作<strong>，Watson等人[24]提出基于观测残差的聚类在运行时学习GMM</strong>。最初，这项工作是是在一个批处理框架中实现的.然而，后来通过一种逐步合并gmm的有效方法，它被扩展到增量[25]工作，通过一种有效的方法来逐步合并gmm。</p><p>m-估计器[26]最近也在GNSS框架中以批处理形式的[27]进行了测试，并发现它比非鲁棒估计器性能更好。m-估计器假设有一个不同于平方损失函数的损失函数。平方损失函数对离群值高度敏感，因为它在较大的残差值下积极增长。因此，引入了一组损失函数，它们的增长侵略性小于平方损失函数。Huber成本函数[28]，如等式中提供的4就是这样一个函数。<span class="math display">\[\rho(z)=\begin{cases}z^2/2&amp;|z|\leq\Delta\\\Delta|z|-\Delta^2/2&amp;|z|&gt;\Delta\end{cases}\]</span> 当目标函数被修改为利用m-估计量时，优化问题的形式如等式中所示5. <span class="math display">\[\hat{X}=\arg\min_x\sum_i\rho\left(\frac{r_i(x)}\sigma\right)\quad(5)\]</span> 式中，<span class="math inline">\(r_i (x)\)</span>为每次测量的残差，<span class="math inline">\(σ\)</span>为尺度参数。</p><p>增加∆参数会使该函数更接近平方损失函数。方程5可以用加权最小二乘法迭代求解方法[27,26]。选择一个合适的∆参数并不简单，因为它依赖于测量噪声的统计量。阿加门诺尼等人[29]利用这样一个事实，即一些m估计量，如胡贝尔，柯西，拉普拉斯有一个对应的椭圆分布来估计期望最大化（EM）框架下的∆和状态。Barron[30]联合优化了计算机视觉应用程序的状态和参数。因子图在m估计器应用中提供了更大的灵活性，<strong>因为它不仅可以帮助降低当前测量的权重，而且还可以改变过去测量的权重</strong>。如果后来发现一些过去的测量值，那么它是一个异常值，而在卡尔曼滤波器中，过去的测量值的贡献不能以实时的方式改变。大多数图形操作时间化库还内置了使用健壮的成本函数的功能，这也很有帮助。</p><p>最后，Yang等人[31]导出的鲁棒估计技术结合了计算机视觉的两个著名思想，黑-朗加拉扬<strong>对偶性[32]和分级非凸性[33]，利用鲁棒代价函数迭代解决点云重构问题。</strong>根据黑-朗加拉扬对偶性，方程5可以重写为<span class="math display">\[\hat{X},\mathbf{w}=\underset{x,w_i\in[0,1]}{\operatorname*{\arg\min}}\sum_i\left[w_ir_i^2\left(x\right)+\Phi_\rho\left(w_i\right)\right],\]</span> 其中 <span class="math inline">\(w_i\)</span>是该测量的权重，<span class="math inline">\(Φ_ρ\)</span>是一个惩罚项，它取决于权重和稳健代价ρ。分级非凸性（GNC）是一种不面临局部极小值问题的非凸函数f最小化的方法。其思想是代替函数用<span class="math inline">\(f_µ\)</span> 替代f，<span class="math inline">\(f_µ\)</span>的凸性由参数µ控制。优化从<span class="math inline">\(f_µ\)</span>和<span class="math inline">\(µ\)</span>的凸形式开始，迭代地改变，使非凸性增加。[31]将这两种方法结合起来，解决了方程5中的两个问题，</p><p>1)在优化鲁棒代价函数的同时避免局部最小值</p><p>2)将方程5转换为一个总是更容易求解的加权最小二乘问题。这个问题与GNSS的相似性对读者来说应该是显而易见的。[34]显示了在GNSS因子图中应用这种稳健估计技术在减轻城市峡谷多路径效应中的重要性。大多数这些鲁棒估计方法的批处理性质使它适合用于因子图，而不是EKF。</p><h2 id="因子图对gnss和无线电导航社区的潜在用途是什么">因子图对GNSS和无线电导航社区的潜在用途是什么？</h2><p>EKF一直是基于GNSS的状态估计的首选，因为其简单性、计算效率，以及GNSS观测模型可以用线性近似很好地建模，并且经常通过高斯误差进行很好的描述。尽管如此，但在某些情况下，无线电导航社区可能可以受益于因子图优化。</p><p>首先，最近的工作强调了机会信号（SOP）在无线电导航应用中的潜在用途和好处。SOP可能包括作为手机信号的[35,36,37]和近地轨道卫星。<strong>sop的使用通常包括对解决一个未知的或非常不确定的发射机位置和时钟偏移量的需要。</strong>因此，这类问题与SLAM有许多相似之处，因此可以从使用因子图中获得类似的好处，如基于视觉或激光雷达的姿态图SLAM所公认的那样。</p><p>其次，正如在GNSS的背景下所讨论的，许多鲁棒估计技术已经被开发出来用于因子图。<strong>对于使用容易出现多路径错误的GNSS城市环境，使用这些鲁棒因子图可能是有益的。</strong>例如，谷歌智能手机解密器挑战的获胜解决方案，包括收集到不同环境设置的各种数据集，确实是一个因子图实现[38]。</p><p>最后，因子图的采用可能是有益的，因为因子图框架已经成为机器人和自治社区中的标准状态估计范式（即，除了GNSS之外，几乎所有的传感器模态都利用并显示了因子图框架的好处）。采用GNSS因子图可以使GNSS和其他传感器模式之间更无缝集成，多个信息源的集成是任何关键导航系统的关键。</p><h2 id="其他相关问题">其他相关问题</h2><h3 id="关于本文提出的反向平滑ekf-9">关于本文提出的反向平滑EKF [9]</h3><blockquote><p>OURNAL OFGUIDANCE, CONTROL,ANDDYNAMICS Vol. 28, No. 5,September–October 2005</p></blockquote><p>推广了迭代扩展卡尔曼滤波器的原理，提出了一种新的在估计问题存在严重非线性时具有优越性能的滤波器。当非噪声可能会显著降低其他滤波器的精度或收敛可靠性时，新的滤波器是有用的。该新的滤波器利用迭代数值技术解决了当前和过去样本区间的非线性平滑问题。这种方法保留了在感兴趣的阶段之前的固定数量的阶段的非线性，并以一种近似的方式处理来自早期阶段的信息。该算法已经在一个困难的航天器姿态估计问题上进行了仿真测试，该问题包括少于三个轴的感知和显著的动态模型不确定性。该滤波器通过同时估计惯性矩参数来补偿这种不确定性。对于初始姿态或姿态率误差较大的估计问题，该滤波器和无迹卡尔曼滤波器具有更好的收敛可靠性和精度。</p><p>反向平滑扩展卡尔曼滤波器（BSEKF）比其他过滤器更直接地处理更多的非线性。EKF使用了非线性动力学和测量函数的一项或两项泰勒级数近似。展开是对后验或先验均值展开的，以可用的为准。利用这些展开式和线性卡尔曼方程动态传播，更新状态状态及其估计误差协方差。1IEKF试图通过改变一个关于一个基于先前线性化的后验状态估计来改进其测量方程的线性近似。在IEKF的一个选项中，可以实现几种重新线性化。1UKF通过非线性动力学和测度函数传播点的分布。这些点被称为西格玛点，它们被用来估计非线性函数输出分布的高斯近似值的均值和协方差。如果你要注意如何选择UKF的西格玛点，那么它将保留二阶非线性效应，这些效应被EKF，2,3的某些细节所遗漏，这就是为什么与许多EKF相比，它可以提高收敛性和准确性。</p><p>BSEKF改进的改进来自于它处理现在和过去的动力学和测量函数的非线性的方法。该方法是对IEKF原理的一种扩展。<strong>其想法是重新线化化当前和过去的测量函数，以及当前和过去的动态函数，以改进对当前和过去状态和过程噪声向量的猜测。</strong>在一个结束的时间间隔内，通过迭代的非线性平滑来选择适当的再线性化点在当前的采样时间内。这个过程产生了一个状态估计算法，该算法处理多个阶段上的所有非线性，而没有任何近似。</p><p>BSEKF在本质上与参考文献中描述的过滤器参考文献4.目前的公式的主要区别是，它适用于一般的离散时间问题，而参考文献4的滤波器直接工作于为特定应用程序导出的采样数据连续时间问题。目前的离散时间形式简化了数学如下：它既消除了指定状态向量的确定性和非确定性部分的需要，也消除了开发不包括过程噪声向量的联合概率分布的需要。</p><p><strong>BSEKF可以被归类为一种特殊的因果批处理过滤器。一个仔细的研究人员可以从文献中关于批过滤的各种想法中综合BSEKF方法，</strong>但没有一个参考文献将所有必要的组件组合在一个地方。在参考文献5中，<strong>使用移动窗口批处理过滤器nonlin-ear高斯-牛顿更新是提到执行因果非线性滤波，但公式不包括过程噪声，也没有解释重要细节如何最好地将数据从批处理窗口的影响</strong>。在参考文献6提到了一个具有类似缺点的移动窗口批处理过滤器，但给出的细节更少。在参考文献7定义了一种解决排除过程噪声的离散时间批估计问题的方法，但没有提到移动窗口实现作为因果非线性滤波的手段。在参考文献1，概述了非线性最大后验（MAP）平滑及其与动态规划的关系，但没有给出算法的解，也没有讨论用于因果滤波的移动窗口实现。</p><p>本文没有将BSEKF与使用蒙特卡罗技术的粒子滤波（PF）方法进行比较。理论上，粒子滤波器能够计算出比BSEKF或任何竞争的非线性滤波器更好的估计，但由于在状态空间中选择相关点的差异，它对具有挑战性的问题有很大的计算代价。BSEKF在精神上更类似于EKF、IEKF和UKF，因为每个算法都是一种使用有界计算数的近似方法。将这种方法与在无限次计算的极限下精确的方法进行比较似乎没有什么意义。另一方面，对于极端非线性问题，一个有用的方法可能是将BSEKF和PF技术技术结合起来。前者可用于指导粒子（状态空间中的点）的选择，以有效地实现后者。本文的其余部分分为三个主要部分，以及一些结论。在第二部分，非线性离散时间滤波问题被定义为一个地图估计问题，以及EKF、IEKF和UKF如何使用近似来解决它的各个方面谈论。本文描述了BSEKF如何比任何其他任何过滤器更少地逼近MAP问题，并详细描述了如何实现该算法。在摘要给出了一个同时进行参数计算的姿态估计问题。IV部分是BSEKF、EKF和UKF滤波结果。本文的结论在V.部分</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 因子图 </tag>
            
            <tag> 综述 </tag>
            
            <tag> 鲁棒性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文粗略阅读——Sqare Root SAM</title>
      <link href="/2024/05/12/%E8%AE%BA%E6%96%87%E2%80%94%E2%80%94SAM/"/>
      <url>/2024/05/12/%E8%AE%BA%E6%96%87%E2%80%94%E2%80%94SAM/</url>
      
        <content type="html"><![CDATA[<h1 id="sqare-root-sam">Sqare Root SAM</h1><p>Simultaneous Localization and Mapping via Square Root InformationSmoothing 基于平方根信息平滑法的同步定位和映射</p><blockquote><p>后面的其他部分 和 因子图优化相关问题重了</p></blockquote><h2 id="摘要">摘要</h2><p>我们研究平滑方法作为一个可行的替代扩展卡尔曼滤波的解决方案。<strong>特别地，我们研究了将相关信息矩阵或度量雅可比矩阵分解为平方根形式的方法。</strong>与EKF相比，这种技术有几个显著的优势：<strong>它们更快又精确，可以批量或增量模式使用，可以更好地处理非线性过程和测量模型，并以更低的成本产生整个机器人轨迹。</strong>此外，以一种间接但引人注目的方式，列排序启发式自动利用了SLAM问题的地理本质中固有的局部性。在本文中，我们提出了这些方法背后的理论，以及根据与SLAM问题相关的图形模型对因子分解的解释。我们在大规模环境中展示了模拟结果和实际的SLAM实验，这强调了这些方法作为基于EKF的方法的替代方案的潜力。</p><h2 id="介绍">1.介绍</h2><p>其中最早和最流行的方法是基于扩展的卡尔曼滤波器（EKF）[68,60,59,2,69,51,49]。EKF递归地估计机器人当前姿态和所有地标的位置（地图）上的高斯密度。然而，众所周知，EKF的计算复杂度很快就变得相当棘手，因此大量的工作都集中在修改和扩展过滤方法，以应对更大规模的环境。[62,17, 21, 8, 44, 47,37, 63, 48, 5, 75, 38,65].然而，当应用于固有的非线性SLAM问题[43]时，过滤本身已经被证明是不一致的，即，即使是占用大量实验的平均值也偏离了真正的解。由于这主要是由于在过滤框架中无法撤销的线性化选择，最近人们对SLAM问题的平滑版本产生了相当大的兴趣</p><h3 id="smoothing-and-mapping-or-sam">Smoothing and Mapping or SAM</h3><p>SLAM的平滑方法不仅涉及最新的机器人位置，还涉及整个机器人的轨迹。许多作者考虑了平滑机器人轨迹的问题，这特别适用于传感器，如激光距离查找器，容易在附近的机器人姿态之间产生成对约束。更一般地说，我们可以考虑完整的SLAM问题[74]，即最优估计整个传感器姿态集以及环境中所有特征的参数的问题。事实上，这个问题在测量[35]、摄影测量[7,36,66,10]、被称为“束调整”和计算机视觉[24,70,71,76,40]、被称为“运动结构”方面有着悠久的历史。特别是在过去的五年里，有一系列的工作，这些想法被应用到SLAM的背景下。</p><p>在本文中，<strong>我们展示了平滑是如何成为基于过滤的方法的一种非常快速的替代方法，并且在许多情况下，保持轨迹周围有助于而不是损害性能</strong>。特别地，与全SLAM相关的优化问题可以用稀疏线性代数简明地表示，它传统上涉及最小二乘问题[34]的解。在这个框架中，我们研究了将信息矩阵I或度量雅可比矩阵A分解为平方根形式，并应用于同时平滑和映射（SAM）的问题。因为它们是基于矩阵平方根的，所以我们将这类方法称为平方根SAM，或简称√SAM，首先在[18]中引入。我们认为√SAM是SLAM比EKF更好的解决SLAM问题的方法：</p><ol type="1"><li>与扩展的卡尔曼滤波协方差或信息矩阵相比，两者都随着时间的推移而完全密集。<strong>与平滑相关联的信息矩阵I是和保持稀疏的。</strong></li><li>在典型的映射场景中，这个矩阵I，或者，度量雅可比矩阵A，是映射协方差结构的更紧凑的表示</li><li>两种稀疏，可以分别用稀疏分解或QR分解有效地分解，分别，生成一个平方根信息矩阵R可以用来立即获得机器人的最佳轨迹和地图。</li></ol><p>在序列估计文献中，分解信息矩阵被称为平方根信息滤波(SRIF），并于1969年开发用于喷气推进实验室的水手10号金星任务（如[3]所述）。使用协方差或信息矩阵的平方根可以得到更准确和稳定的算法，并且引用梅贝克[57]的话，“许多实践者以相当大的逻辑认为，应该始终采用平方根滤波器，而不是标准的卡尔曼滤波器递归”</p><p>梅贝克简要地讨论了SRIF关于平方根过滤的章节，以及它和其他平方根类型的算法是Bierman[3]的一本书的主题。但是，从文献文献数量较少来判断，SRIF和平方根信息平滑器（SRIS）并不常用。</p><h3 id="稀疏线性代数图论和稀疏sam">稀疏线性代数，图论，和稀疏√SAM</h3><p>性能的关键是利用稀疏线性代数中的大量工作，并充分利用与平滑SLAM问题相关的矩阵的稀疏性。性能上最显著的改进来自于在分解矩阵时选择一个良好的变量排序。为了更好地理解这一事实，我们需要研究类似于slam的问题、线性代数和图论之间的密切关系，图论一直是稀疏线性代数30多年的中心[31]。例如，<strong>虽然QR分解通常被用作“黑盒”算法，但它实际上是在图上的一种优雅的计算。这是一个反复出现的主题：线性代数的最新进展是数值方法和高级图论的混合，与图形模型文献中常见的推理算法有许多共同的特征。</strong>特别是，稀疏最小二乘解的图论算法是变量消去，其中每个变量（如机器人姿态或地标位置）都用其他变量表示。剔除变量的顺序对QR和Cholesky等矩阵分解算法的运行时间有很大的影响。找到一个最优排序是一个np-完整的问题，但是有一些排序启发式和近似算法在一般问题[1,41]上表现良好，并被内置到像MATLAB这样的程序中。</p><p>虽然通用的排序方法极大地提高了性能，但在对变量进行排序时，通过利用SLAM问题的特定图形结构，还可以获得另外15倍的改进。从图表的角度来看SLAM本身有丰富的历史，特别是在过去几年[61,58,29,63,25,30,75,26,74]导致了一些新颖和令人兴奋的发展。下面我们将更仔细地研究图形模型视图和SLAM的稀疏线性代数公式之间的紧密联系。众所周知，信息矩阵I与连接机器人姿态和地标的无向图相关联（见[75]）。不太容易理解的事实是，测量雅可比矩阵A是与SLAM相关的因子图的矩阵。此外，平方根信息矩阵R，即分解I或A的结果，本质上对应于一个结树，从图形模型[11]的推理中知道，最近也应用于SLAM[63]。利用领域知识来获得良好的排序也是线性代数（如[15]）的一种趋势，我们相信，通过将这个问题看作是一个图上的计算问题，甚至可以开发出更有效的算法。</p><h2 id="slam-and-graph">2. SLAM and Graph</h2><p>SLAM是指在定位机器人环境的同时定位机器人的问题，如图1的例子所示。在本节中，我们将介绍SLAM问题，我们使用的符号，并展示文献中已知的三个主要图形模型表示如何对SLAM问题产生独特的视图，从而强调问题的某些方面。在本文的后面，我们建立了这些图和它们的（稀疏）矩阵等价物之间的联系。</p><p>下面我们假设我们熟悉基于EKF的SLAM[69,49,8,21]方法。我们不重新推导出扩展的卡尔曼滤波器。相反，在第3节中，我们立即采取了一种平滑的方法，其中地图和机器人的轨迹都被恢复。</p><h3 id="slam-as-a-belief-net">SLAM as a Belief Net</h3><blockquote><p>信念网也叫贝叶斯网络</p></blockquote><p>根据FastSLAM和其他[61,58,63,29,25,74]设定的趋势，我们通过引用一个信念网络表示来表述这个问题。信念网是一个有向无环图，它编码一组变量的条件独立结构，其中每个变量只直接依赖于图中的前身。我们所采用的模型如图2所示。这里我们用xi表示机器人的时间步长状态，i∈0..M，lj的地标，j∈1..N，用zk测量，用k∈1..K.该网络对应的联合概率模型为</p><p><span class="math inline">\(P(X,L,Z)=P(x_0)\prod_{i=1}^MP(x_i|x_{i-1},u_i)\prod_{k=1}^KP(z_k|x_{i_k},l_{j_k})\)</span></p><p>其中P（x0）为初始状态的先验，P（xi|xi−1，ui）为运动模型，由控制输入ui参数化，P（z|x，l）为地标测量模型。以上假设在地标l上有一个统一的先验。此外，它假设数据关联问题已经得到解决，即每个测量zk所对应的指标ik和jk都是已知的。</p><p>SLAM问题的贝叶斯信念网络表示。机器人的状态x由顶部的马尔可夫链控制，而机器人的环境在底部由一组地标l表示。中间层的测量z由机器人的状态和测量的地标参数控制。<span class="math display">\[{x_i=f_i(x_{i-1},u_i)+w_i\quad\Leftrightarrow\quadP(x_i|x_{i-1},u_i)\propto\exp-\frac12\|f_i(x_{i-1},u_i)-x_i\|_{\Lambda_i}^2}\]</span>其中，fi（.）是一个过程模型，以及具有正态分布的具有协方差矩阵Λi的零均值过程噪声，和<span class="math display">\[z_k=h_k(x_{i_k},l_{j_k})+v_k\quad\Leftrightarrow\quadP(z_k|x_{i_k},l_{j_k})\propto\exp-\frac{1}{2}\|h_k(x_{i_k},l_{j_k})-z_k\|_{\Sigma_k}^2\]</span>其中，hk（）是一个测量方程，它是正态分布的零平均测量噪声与协方差Σk。在||e||Σ被定义为给定一个协方差矩阵Σ的马氏距离的平方。</p><p>上述方程分别模拟了机器人对控制输入及其传感器的响应行为。</p><blockquote><p>这两个式子展示的是状态空间模型中的状态转移的描述，一个是通过随机方程的形式，另一个是通过条件概率密度的形式.</p><p>在状态空间模型中，每个状态<span class="math inline">\(x_i\)</span>是基于上一个状态<span class="math inline">\(x_{i-1}\)</span>和一些控制输入<span class="math inline">\(u_i\)</span>,通过一个确定性的函数 <span class="math inline">\(f_i\)</span> 来预测的，并加上一些随机噪声<span class="math inline">\(w_i\)</span>。随机噪声通常假定为高斯分布，也就是正态分布，具有零均值和一定的协方差矩阵<span class="math inline">\(Q_i\)</span>。</p><p><img src="D:\typora\pic\image-20240510171449639.png" alt="image-20240510171449639" style="zoom:67%;"></p></blockquote><h3 id="slam-as-a-factor-gragh">SLAM as a Factor Gragh</h3><p>虽然信念网是思考SLAM问题的生成方面的一种非常自然的表示，但因子图与潜在的优化问题有更紧密的联系。由于测量值z_k在图2是已知的（证据，在图形模型的术语中），我们可以自由地消除它们作为变量。相反，我们把它们作为实际未知数上的联合概率因子的参数，这自然导致了众所周知的因子图表示，这是一类二部图图形模型，可以用来表示这种因子密度[46]。在因子图中，有未知数的节点和定义在它们上的概率因子的节点，图的结构表示每个因子涉及哪些未知数。图1中的示例的因子图如图3所示。可以看出，地标测量zk和测程链接ui都有因子节点.</p><blockquote><p>在讨论SLAM（Simultaneous Localization andMapping）问题时，我们通常需要处理大量的变量和测量数据。信念网（或贝叶斯网络）和因子图是两种常用的图形表示，用以表达这些变量之间的依赖关系。这两种表示方式各有优缺点，而对于SLAM这类优化问题，因子图提供了一种更直接且与问题求解密切相关的表示形式。</p><h3 id="为什么可以自由消除测量值-z_k-作为变量">为什么可以自由消除测量值( z_k ) 作为变量</h3><p>在因子图中，我们通常关注的是如何根据已知的测量值（如传感器数据）来推断机器人的位置和地图的配置。测量值( z_k )通常被视为“已知”的，它们是收集到的传感器数据，不是需要求解的未知数。在构建模型时，我们不需要将这些测量值作为待求解的变量；它们是给定的条件或“证据”，已经存在并用于影响其他未知变量的估计。</p><h3 id="为什么我们把它们作为实际未知数上的联合概率因子的参数">为什么我们把它们作为实际未知数上的联合概率因子的参数</h3><p>在因子图表示中，每一个因子通常表示变量之间的概率关系。例如，在SLAM中，一个因子可能表示在特定的位置和地图配置下获得某个测量值的概率。这样，测量值( z_k )作为参数出现在因子中，而非作为独立的变量。这使得因子图直接反映了未知变量（如机器人位置和地图配置）之间的条件依赖关系。通过这种方式，因子图将关注点集中在如何根据测量数据来推断或优化未知变量上，而非处理测量数据本身作为未知数。</p><h3 id="这自然导致了众所周知的因子图表示">这自然导致了众所周知的因子图表示</h3><p>因子图的这种表示方式使得它非常适合于SLAM这类问题的求解，因为SLAM本质上是一个基于大量测量数据对未知状态进行优化的问题。在因子图中，各个因子直接关联到一组变量，并定义这些变量间的局部关系，这对于执行如图搜索、优化和推断等操作是非常有效的。相对于信念网，因子图提供了一种更为紧凑和针对优化问题的自然表示，使得算法能更直接地操作相关的概率分布，从而更有效地实现SLAM。</p><p>总之，因子图通过将测量值作为已知的参数而不是变量来简化问题表示，使得模型更直接地关联到优化问题本身，这对于高效解决SLAM等复杂问题至关重要。</p></blockquote><blockquote><p>因子图是图形模型中的一种，它用于表示多个变量间复杂的依赖关系。在因子图中，节点表示变量（例如，在SLAM中的机器人位置和地图的特征点），而边则表示这些变量之间的条件依赖，即因子。因子通常定义了一组变量之间的概率关系，这些概率关系直接反映了变量间如何相互影响。</p><h3 id="反映未知变量之间的条件依赖关系">反映未知变量之间的条件依赖关系</h3><p>在SLAM问题中，机器人的位置和地图的特征点都是未知变量，它们之间的关系通过传感器的测量数据（如激光雷达、摄像头等）被间接地捕获。因子图通过以下方式来反映这些未知变量之间的条件依赖关系：</p><ol type="1"><li><strong>变量节点</strong>：表示SLAM中的每一个未知元素，如每个时刻的机器人位置、地图上的每一个特征点。</li><li><strong>因子节点</strong>：表示测量数据与这些未知变量之间的概率函数。例如，<strong>一个因子节点可以表示在给定机器人位置和方向的情况下，预期的激光雷达测量与实际测量之间的误差概率分布。</strong></li></ol><h3 id="集中关注点在未知变量的推断或优化上">集中关注点在未知变量的推断或优化上</h3><p>因子图将关注点放在了如何使用这些条件依赖关系来推断或优化未知变量上，而不是将测量数据本身作为解决问题的一部分。这是通过以下步骤实现的：</p><ol type="1"><li><p><strong>整合测量数据</strong>：测量数据作为参数整合到因子节点中，而不是作为独立的求解变量。<strong>这意味着我们不需要对测量数据本身进行优化或求解，而是使用这些数据作为已知的信息来帮助确定未知变量的最可能值。</strong></p></li><li><p><strong>优化或推断</strong>：使用图中的结构和因子定义，我们可以应用优化算法（如非线性最小二乘、梯度下降）或概率推断方法（如粒子滤波、贝叶斯推断）来估计这些未知变量的值。算法会根据因子图中定义的数学关系和输入的测量数据，寻找使得整个系统概率最大（或误差最小）的未知变量的配置。</p></li></ol><p>通过这种方式，因子图能够有效地利用每个测量的信息，同时保持对未知变量间复杂关系的清晰表示，从而使得求解过程更为直接和高效。因此，因子图在SLAM及其他涉及大量变量和数据的领域中非常受欢迎。</p></blockquote><p>在SLAM问题中，我们（通常）只考虑单个和成对的派系，导致一组未知Θ上的以下因子图表达式：</p>{{$$P(\Theta)\propto\prod_i\phi(\theta_i)\prod_{\{i,j\},i<j}\psi_{ij}(\theta_i,\theta_j) $$="" }}="" <p="">通常，势φ（θi）在未知θi∈Θ处编码先验或单一测量约束，而成对势ψij（θi，θj）与涉及两个未知θiandθj之间关系的测量或约束有关。注意，第二个产品是成对的团系{i，j}，计算一次。方程(1)和(4)之间的等价性可以很容易地通过下列各式来建立<span class="math display">\[\phi_0(x_0)\propto P(x_0)\\\psi_{(i-1)i}(x_{i-1},x_i)\proptoP(x_i|x_{i-1},u_i)\\\psi_{i_kj_k}(x_{i_k},l_{j_k})\proptoP(z_k|x_{i_k},l_{j_k})\]</span>图1对应的完整SLAM问题的因子图表示。未知的姿态和地标分别对应于圆形和正方形的变量节点，而每个测量值对应于一个因子节点（填充的黑色圆圈）。<p></p><h3 id="slam-as-a-markov-random-field">SLAM as a Markov RandomField</h3><p>最后，用图形模型来表示SLAM问题的第三种方法是通过马尔可夫随机场，其中消除了因子节点本身。一个MRF的图是无向的，并且没有因子节点：它的邻接结构表示哪些变量是由一个共同的因子（度量或约束）连接起来的。在这个抽象级别上，形式(4)完全对应于一个成对的马尔可夫随机场[78]的表达式，因此是mrf和因子图是这里的等价表示。图1中的示例的MRF如图4所示。请注意，它看起来与图3非常相似，但是MRF是一个完全不同于因素图的结构（无向图和二部图）。</p><h2 id="sam-as-a-least-squares-problem">3.SAM as a Least SquaresProblem</h2><p>虽然前一节涉及建模，但我们现在讨论推理，即，给定我们可用的所有测量值，获得未知数集的最优估计。我们使用平滑而不是滤波，也就是说，我们想要恢复整个轨迹X={xi}和映射L={lj}的最大后验估计，给定测量值Z={zk}和控制输入U={ui}。让我们在Θ=（X，L）中收集X和L中的所有未知数。在上述假设下，我们通过最大化方程1中的联合概率P（X，L，Z）得到最大后验（MAP）估计。</p><p><span class="math display">\[\begin{aligned}\Theta^*\triangleq\underset{\Theta}{\operatorname*{argmax}}P(X,L|Z)&amp;=\quad\underset{\Theta}{\operatorname*{argmax}}P(X,L,Z)\\&amp;=\quad\underset{\Theta}{\operatorname*{argmin}}-\logP(X,L,Z)\end{aligned}\]</span></p><p>这使我们通过(2)和(3)得出以下非线性最小二乘问题： <span class="math display">\[\Theta^*\triangleq\underset{\Theta}{\operatorname*{argmin}}\left\{\sum_{i=1}^M\|f_i(x_{i-1},u_i)-x_i\|_{\Lambda_i}^2+\sum_{k=1}^K\|h_k(x_{i_k},l_{j_k})-z_k\|_{\Sigma_k}^2\right\}\]</span>对于先前的P（x0），我们将假设x0是给定的，因此它被视为一个常数。这大大简化了本文档其余部分中的方程式。这是很常见的事情。在实践中：坐标系的原点是任意的，我们可以把x0固定在原点。该阐述很容易适应这种假设无效的情况。</p><p>在实践中，人们总是考虑公式(5)的线性化版本。如果过程模型和测量方程是非线性的，并且没有良好的线性化点，非线性优化方法，如高斯-牛顿迭代或莱文堡-马夸特算法将求解(5)的一系列线性近似，以接近最小[20]。这类似于[68,69,50]首创的针对SLAM的扩展卡尔曼滤波方法，但允许多次迭代以收敛，同时控制在哪个区域愿意信任线性假设（因此，这些方法通常被称为区域信任方法）。</p><p>我们现在将非线性最小二乘目标函数(5)中的所有项线性化。在最低点时，我们将假设一个好的线性化点是可用的，或者我们正在进行一个非线性优化方法的一次迭代。在任何一种情况下，我们都可以将(5)中的过程项线性化如下：<span class="math display">\[f_i(x_{i-1},u_i)-x_i\approx\left\{f_i(x_{i-1}^0,u_i)+F_i^{-1}\deltax_{i-1}\right\}-\left\{x_i^0+\delta x_i\right\}=\left\{F_i^{i-1}\deltax_{i-1}-\delta x_i\right\}-a_i\quad(6)\\]</span> <span class="math inline">\(\text{where }F_i^{i-1}\text{ isthe Jacobian of }f_i(.)\text{ at the linearization point}x_{i-1}^0,\text{defined by}\)</span> <span class="math display">\[F_i^{i-1}\triangleq\frac{\partial f_i(x_{i-1},u_i)}{\partialx_{i-1}}\Bigg|_{x_{i-1}^0}$​\]</span> <span class="math inline">\(a_i\stackrel{\Delta}{=}x_i^0-f_i(x_{i-1}^0,u_i)\)</span>是测程预测误差（注意，<span class="math inline">\(u_i\)</span>是这里是给出的，因此是常数）。(5)中的线性化测量项也同样得到，<span class="math display">\[h_k(x_{i_k},l_{j_k})-z_k\approx\left\{h_k(x_{i_k}^0,l_{j_k}^0)+H_k^{i_k}\deltax_{i_k}+J_k^{j_k}\delta l_{j_k}\right\}-z_k=\left\{H_k^{i_k}\deltax_{i_k}+J_k^{j_k}\delta l_{j_k}\right\}-c_k\]</span></p><p><span class="math display">\[H_k^{i_k}\triangleq\frac{\partial h_k(x_{i_k},l_{j_k})}{\partialx_{i_k}}\bigg|_{(x_{i_k}^0,l_{j_k}^0)}J_k^{j_k}\triangleq\frac{\partialh_k(x_{i_k},l_{j_k})}{\partial l_{j_k}}\bigg|_{(x_{i_k}^0,l_{j_k}^0)}\\]</span></p><p><span class="math inline">\(c_k\triangleqz_k-h_k(x_{i_k}^0,l_{j_k}^0)\)</span>是测量预测误差。</p><p>分别使用线性化的过程和测量模型(6)和(7)，(5)开始 <span class="math display">\[\delta^*=\underset{\delta}{\operatorname*{argmin}}\left\{\sum_{i=1}^M\|F_i^{i-1}\deltax_{i-1}+G_i^i\deltax_i+a_i\|_{\Lambda_i}^2+\sum_{k=1}^K\|H_k^{i_k}\deltax_{i_k}+J_k^{j_k}\delta l_{j_k}-c_k\|_{\Sigma_k}^2\right\}\]</span>也就是说，我们得到了一个需要有效求解的δ中的线性最小二乘问题。为了避免处理<span class="math inline">\(\deltax_{i}\)</span>的一种特殊方法，我们引入了矩阵<span class="math inline">\(G_i^i=-I_{d\times d},\)</span>，xi维数为d。</p><p>我们总是可以通过预乘以<span class="math inline">\(F_i^{i-1},G_i^i,\)</span>和<span class="math inline">\(a_i\)</span>的每个项<span class="math inline">\(\Lambda_i^{-T/2},\)</span>来消除<span class="math inline">\(\Lambda_i,\)</span>(8)，对于测量协方差矩阵Σk也是如此。对于标量测量，这仅仅意味着将每一项除以测量的标准差。下面我们假设已经这样做了，然后去掉马氏符号。</p><p>最后，将雅可比矩阵收集为矩阵a，并将向量纳入右侧（RHS）向量b，得到以下标准最小二乘问题，<span class="math display">\[\delta^*=\underset{\sim}{\operatorname*{argmin}}\left\|A\delta-b\right\|_2^2\]</span>这是我们下面的起点。A可以变得非常大，但却非常稀疏，如图5所示。如果dx、dl和dz是状态、地标和测量值的尺寸，则A的大小为（NdxKdz）×（Ndx Mdl）。此外，A具有典型的块状结构，例如，具有M = 3、N = 2和K= 4： <span class="math display">\[\left.A=\left[\begin{array}{cccccc}G_1^1&amp;&amp;&amp;&amp;&amp;\\F_2^1&amp;G_2^2&amp;&amp;&amp;&amp;\\&amp;F_3^2&amp;G_3^3&amp;&amp;&amp;\\H_1^1&amp;&amp;&amp;J_1^1&amp;&amp;\\H_2^1&amp;&amp;&amp;&amp;J_2^2&amp;\\&amp;H_3^2&amp;&amp;J_3^1&amp;&amp;\\&amp;&amp;H_4^3&amp;&amp;J_4^2&amp;\end{array}\right.\right],\quadb=\left[\begin{array}{c}a_1\\a_2\\a_3\\c_1\\c_2\\c_3\\c_4\end{array}\right]\]</span>上半部分描述了机器人的运动，下半部分是测量值。不同类型（和尺寸）的地标和/或测量值易于混合。</p><h2 id="a-linear-algebra-perspective线性代数透视">4. A Linear AlgebraPerspective（线性代数透视）</h2><p><a href="https://www.bilibili.com/video/BV1Ag411M76G/?share_source=copy_web&amp;vd_source=8d5f94cac4ef1f7256e3572189ec255b">cholesky分解是什么</a></p><p>在本节中，我们将简要回顾 Cholesky 和 QR 因式分解及其在 (9)中全秩线性最小二乘 (LS) 问题中的应用。(9) 中的全秩线性最小二乘 (LS)问题的应用。这些材料已广为人知，给出它们主要是为了回顾线性代数算法与下一节的图论观点进行对比。论述紧跟[34]，更深入的论述可参阅[34]。</p><p>原始问题是一个典型的最小二乘问题，目的是找到向量 <span class="math inline">\(\delta\)</span>，使得 <span class="math inline">\(A\delta - b\)</span> 的欧几里得范数（即 <span class="math inline">\(L_2\)</span> 范数）最小化：</p><p><span class="math display">\[\delta^* = \underset{\delta}{\operatorname*{argmin}} \|A\delta - b\|_2^2\]</span></p><p>最小化函数 <span class="math inline">\(\|A\delta - b\|_2^2\)</span>可以表示为：</p><p><span class="math display">\[\|A\delta - b\|_2^2 = (A\delta - b)^T (A\delta - b)\]</span></p><p>展开此式：</p><p><span class="math display">\[= (A\delta)^T (A\delta) - 2b^T (A\delta) + b^T b\]</span></p><p><span class="math display">\[= \delta^T A^T A \delta - 2b^T A \delta + b^T b\]</span></p><p>为了找到这个函数的最小值，我们对 <span class="math inline">\(\delta\)</span>求导，并设其导数为零。由于这里是一个二次式，其导数可以用来找到极小值点：</p><p><span class="math display">\[\frac{\partial}{\partial \delta} (\delta^T A^T A \delta - 2b^T A \delta+ b^T b) = 0\]</span></p><p>求导得：</p><p><span class="math display">\[2A^T A \delta - 2A^T b = 0\]</span></p><p>简化此式，我们得到：</p><p><span class="math display">\[A^T A \delta = A^T b\]</span></p><p>这就是所谓的<strong>正规方程</strong>，它提供了一个求解 <span class="math inline">\(\delta\)</span> 的直接方法，即通过求解线性方程组<span class="math inline">\(A^T A \delta = A^T b\)</span>来找到原始最小二乘问题的解。</p><p>这样，我们从最小化欧几里得范数的问题过渡到解线性方程的问题，两者实际上是等价的。解<span class="math inline">\(A^T A \delta = A^T b\)</span> 不仅找到了使得<span class="math inline">\(A\delta\)</span> 最接近 <span class="math inline">\(b\)</span> 的 <span class="math inline">\(\delta\)</span>，而且还以线性方程组的形式给出了直接的计算方法。这也是为什么在实际应用中（尤其是在数据拟合和机器学习中）我们经常需要计算<span class="math inline">\(A^T A\)</span> 和 <span class="math inline">\(A^T b\)</span></p><h3 id="cholesky分解">Cholesky分解</h3><p>对于全秩m×n矩阵a，具有m≥n，通过求解正规方程可以得到(9)的唯一LS解：<span class="math inline">\(A^TA\delta^*=A^Tb\)</span></p><p>这通常是通过信息矩阵I的Cholesky因子分解来完成的，定义和分解如下：<span class="math inline">\(\mathcal{I}\triangleq A^TA=R^TR\)</span></p><p>Cholesky三角分解R是一个上三角n×n矩阵，使用Cholesky分解矩阵计算，即对称正定矩阵的LU分解的一个变体。对于密集矩阵，Cholesky分解需要n<sup>3</sup>/3的运算量。<span class="math display">\[{\text{first }R^T}y=A^Tb\text{ and then }R\delta^*=y\]</span> 在此之后，可以通过求解找到δ<sup>∗</sup>通过反向替代。</p><p>Cholesky分解需要n<sup>3</sup>/3的运算量。计算一半的对称A<sup>T</sup>A，需要mn<sup>2</sup>复杂度，整个算法，包括计算一半的对称A<sup>T</sup>A，需要（m+n/3）n<sup>2</sup>复杂度。</p><p>对于图1的例子，I和它的cholelesky三角形R在图5中与A一起显示。请注意，当A的列以典型的方式排序时，I的非常典型的块结构，例如，首先是轨迹X，然后映射L（下面我们将其称为XL排序）<span class="math display">\[\left.\mathcal{I}=\left[\begin{array}{cc}A_X^TA_X&amp;\mathcal{I}_{XL}\\\mathcal{I}_{XL}^T&amp;A_L^TA_L\end{array}\right.\right]\]</span> <span class="math inline">\(\mathcal{I}_{XL}\triangleqA_X^TA_L\)</span>对机器人状态X和映射L之间的相关性进行编码，对角线块为带对角线。</p><p>避免计算平方根的Cholesky分解的一个变体是LDL分解，它计算一个下三角矩阵L和一个对角矩阵D<span class="math display">\[\mathcal{I}=R^TR=LDL^T\]</span>另一种更精确和数值稳定的Cholesky分解的方法是通过QR分解而不计算信息矩阵I。相反，我们计算A本身的QR分解及其相应的RHS：<span class="math display">\[\left.Q^TA=\left[\begin{array}{c}R\\0\end{array}\right.\right]\quadQ^Tb=\left[\begin{array}{c}d\\e\end{array}\right]\]</span>这里Q是一个m×m正交矩阵，R是上三角的Cholesky三角。分解密集矩阵A的首选方法是逐列计算R，从左到右进行。对于每一列j，对角线下的所有非零元素都通过将左边的A与Householder反射矩阵Hj相乘而归零。经过n次迭代后，A被完全分解。<span class="math display">\[\left.H_n..H_2H_1A=Q^TA=\left|\begin{array}{c}R\\0\end{array}\right.\right|\]</span> 正交矩阵Q通常不形成：相反，转换后的RHS <span class="math inline">\(Q^Tb\)</span>是通过将b作为A的附加一列来计算的。因为Q因子是正交的，我们有：<span class="math display">\[\left\|A\delta-b\right\|_2^2=\left\|Q^TA\delta-Q^Tb\right\|_2^2=\left\|R\delta-d\right\|_2^2+\left\|e\right\|_2^2\]</span> 显然，||e||将是最小二乘残差，通过求解平方系统可以得到LS解δ∗:Rδ= d</p><p>通过反向替代。QR的成本主要由Householder反射的成本决定，即2（m−n/3）n<sup>2</sup></p><p>比较QR和Cholesky分解，我们发现两种算法都需要O（mn<sup>2</sup>）运算(m&gt;n)，但QR分解要慢2倍。虽然这些数字只对密集矩阵有效，但我们已经看到，在实践中，LDL和Cholesky因子分解在稀疏问题上也远远优于QR因子分解，而不仅仅是一个常数因子。</p><h2 id="a-graphical-model-perspective图像模型透视图">5.A Graphical ModelPerspective(图像模型透视图)</h2><h3 id="matrices-graphs-矩阵-图">5.1 Matrices ⇔ Graphs （矩阵 图）</h3><p>从上面的说明中，现在可以很容易地认识到，测量雅可比矩阵A是与SLAM相关的因子图的矩阵。我们可以从两个层面上理解这个说法。首先，A的每个块对应于最小二乘准则(8)中的一项，要么是一个地标测量，要么是一个测程约束，并且每一个块行对应于因子图中的一个因子。在每个块行中，稀疏性模式表示哪些未知的姿态和/或地标与该因素相连。因此，A的块结构完全对应于与SAM相关的因子图的邻接矩阵。</p><p>其次，在标量水平上，每一行Ai在A（见图5）对应于稀疏矩阵最小二乘准则(9)中的一个标量项<span class="math inline">\(\|A_i\delta-b_i\|_2^2\)</span>，如 <span class="math display">\[\left\|A\delta-b\right\|_2^2=\sum_i\left\|A_i\delta-b_i\right\|_2^2\]</span> 因此，这定义了一个精细结构的因图，通过 <span class="math display">\[P(\delta)\propto\exp-\frac12\left\|A\delta-b\right\|_2^2=\prod_i\exp-\frac12\left\|A_i\delta-b_i\right\|_2^2\]</span>重要的是要认识到，在这个更精细的观点中，SLAM问题的块结构被丢弃了，并且它是这个图被通用的线性代数方法所检验。通过使用块结构来代替，我们将能够做得更好。</p><p>如之前在[75]以及其他文献中提到的，信息矩阵Ⅰ=A<sup>T</sup>A是与SLAM问题关联的马尔可夫随机场(MRF）的矩阵表达形式。同时，从块级别来看，A<sup>T</sup>A的稀疏模式完全等同于相应MRF的邻接矩阵。方程5中的目标函通过哈默斯利-克利福德定理[77]对应于成对马尔可夫随机场（MRF）[77,78]。而在这个MRF中，节点对应于机器人的状态和地标。链接代表里程计或地标测量。</p><p>在文献[63,75]中，采用马尔可夫随机场（MRF）图的视角来揭示SLAM滤波版本中固有的相关性结构。<strong>研究表明，当将过去的轨迹<span class="math inline">\(𝑋_{1:𝑀−1}\)</span>边缘化时，信息矩阵不可避免地变得完全密集</strong>。因此，这些方法的重点是选择性地移除链接以减少滤波器的计算成本，并取得了显著的成功。相比之下，本文考虑的是与平滑信息矩阵<span class="math inline">\(I\)</span>关联的MRF，该信息矩阵不会变得密集，因为过去的状态从未被边缘化。</p><h3 id="因式分解变量消除">5.2 因式分解⇔变量消除</h3><p>剩下的一个问题是平方根信息矩阵R对应于什么图？请记住，R是在第4节中对I或A进行因素分解的结果。Cholesky或QR因子分解最常被用作“黑盒”算法，但实际上它们与最近在图形模型[11]中开发的推理方法相似。从下面可以看到，R与结树基本对应，从图形模型的推理中知道，最近也在SLAM中应用</p><p>两种因式分解方法，QR和Cholesky（或LDL），都基于变量消除算法[4,11]。这两种方法的区别在于QR通过消除因子图中的变量节点得到<span class="math display">\[A=QR\]</span>，而Cholesky或LDL则从马尔可夫随机场(MRF)开始，因此得到<span class="math display">\[A^TA = R^TR\]</span>。这两种方法都是从<span class="math display">\[\delta_1\]</span>开始，一次消除一个变量，<span class="math display">\[\delta_1\]</span>对应于<span class="math display">\[A\]</span>或<span class="math display">\[\mathcal{I}\]</span>的最左列。消除的结果是<span class="math display">\[\delta_1\]</span>现在表示为所有其他未知数<span class="math display">\[\delta_{j&gt;1}\]</span>的线性组合，系数位于对应的<span class="math display">\[R_1\]</span>行中。然而，在此过程中，新的依赖性被引入到所有与<span class="math display">\[\delta_1\]</span>相连的变量之间，这导致图中添加了边。然后以类似方式处理下一个变量，直到所有变量都被消除。这正是图形模型推理中熟悉的公理化和三角化过程。消除所有变量的结果是一个有向的、三角化（弦图）的图，在我们的示例中显示在图6中。</p><blockquote><p>这段话描述的是在处理线性系统或矩阵分解时，如何使用变量消除算法，具体包括QR分解和Cholesky分解（或LDL分解）。以下是每部分的具体解释：</p><ol type="1"><li><p><strong>变量消除算法</strong>:这是一种算法框架，用于通过逐步简化变量来处理数学问题。在矩阵分解的上下文中，这意味着选择某个变量并重新组织方程，使得这个变量可以通过其它变量线性表示。</p></li><li><p><strong>QR分解和Cholesky分解的对比</strong>:</p><ul><li><strong>QR分解</strong>(<span class="math display">\[A =QR\]</span>)：这是通过在因子图中消除变量节点实现的。在此过程中，矩阵<span class="math display">\[A\]</span>被分解为一个正交矩阵<span class="math display">\[Q\]</span>和一个上三角矩阵<span class="math display">\[R\]</span>。QR分解特别适用于求解具有线性独立列的线性系统。</li><li><strong>Cholesky分解</strong>(<span class="math display">\[A^TA =R^TR\]</span>)：这种方法以马尔可夫随机场(MRF)为起点。在数学上，这涉及到将矩阵<span class="math display">\[A\]</span>的转置与<span class="math display">\[A\]</span>本身相乘，得到的结果是一个对称正定矩阵，然后对这个矩阵进行因式分解以得到一个上三角矩阵<span class="math display">\[R\]</span>。此方法适用于正定矩阵的分解。</li></ul></li><li><p><strong>变量消除过程</strong>:</p><ul><li>从<span class="math display">\[\delta_1\]</span>开始，它是矩阵<span class="math display">\[A\]</span>或<span class="math display">\[\mathcal{I}\]</span>的最左列所对应的变量。这个变量被消除或解算出来，并用其它变量(<span class="math display">\[\delta_{j&gt;1}\]</span>)的线性组合表示。</li><li>在消除<span class="math display">\[\delta_1\]</span>的过程中，会在图中介入新的依赖性，这些依赖性在与<span class="math display">\[\delta_1\]</span>相连的所有变量之间形成新的边。这是因为消除一个变量通常会使其相关的其他变量之间产生直接的联系，这些联系在原始图中可能并不存在。</li></ul></li><li><p><strong>公理化和三角化过程</strong>:</p><ul><li>这是图形模型推理中的常见步骤。消除变量的过程不仅涉及代数运算，还涉及图的结构变化，比如添加新的边来填充环路，使得图变成有向且无环的。</li></ul></li><li><p><strong>结果</strong>:</p><ul><li>完成所有变量的消除后，结果是一个有向的、三角化（或称为弦图）的图。在此上下文中，这意味着所有的变量都通过某种方式关联，并且关联结构支持高效的图形模型推理。</li></ul></li></ol><p>这些概念通常用于数值分析、统计建模和计算机视觉等领域，用于优化算法的效率并减少计算复杂性。</p></blockquote><p>一旦获得了弦图 <span class="math inline">\((R!)\)</span>，我们就可以得到 <span class="math inline">\(R\)</span>的消元树，它被定义为消元后弦图的深度优先生成树，并且在反向替代阶段中用于说明计算流程。为了说明这一点，图7展示了使用<strong>先消除地标再消除姿态</strong>的著名启发式方法所获得的弦图（我们将其称为<span class="math inline">\(LX\)</span> 排序）。相应的消元树在图 8中展示。树的根对应于最后一个被消除的变量 <span class="math inline">\(\delta_n\)</span>，它是在反向替代（方程13）中首先被计算的。然后，计算沿树向下进行，尽管这通常按逆列顺序完成，但在不相连的子树中的变量可以按任何顺序计算。实际上，如果只对某些变量感兴趣，那么没有必要计算不包含这些变量的任何子树。</p><p>然而，分析并没有就此结束。<span class="math inline">\(R\)</span>的图具有一个可以完全封装在称为团树（cliquetree）的根树数据结构中的团结构 [64,4]，在人工智能文献中也称为连接树（junction tree）[11]。例如，图 1问题上的 <span class="math inline">\(LX\)</span> 排序的团树在图 9中展示。对应关系几乎是一对一的：每个 <span class="math inline">\(R\)</span>准确对应一个团树，反之亦然，仅需在团内进行列重排。团树也是多前端 QR 方法[56] 的基础，我们在下面的模拟中也对此进行了评估。在多前端 QR因式分解中，计算从树的叶子到根进行，以分解一个稀疏矩阵，然后从根到叶子进行反向替代步骤。关于平方根信息矩阵和团树之间关系的完整处理超出了当前论文的范围，但在其他工作中，我们已经在分布式推断的新算法中使用了团树结构[19]。</p><h3 id="提高性能减少填料">5.3提高性能⇔减少填料</h3><p>良好性能的最重要的因素是变量的顺序。<strong>不同的变量顺序</strong>可以显著地产生或多或少的填充，定义为在因子分解过程中添加到图中的边的量。由于每条边对应于Choleseky三角形R中的非零，计算R和反向替换的成本在很大程度上取决于发生的填充量。不幸的是，找到一个最优排序是np完备的。发现近似最优排序的算法是稀疏线性代数研究的一个活跃领域。一种常用的处理中型问题的方法是联合[1]，另一种基于图论的常用方法是广义嵌套解剖[53,52]。</p><p>假设最优排序通常是遥不可及的，启发式或领域知识可以比通用算法做得更好。一个简单的想法是使用一个标准的方法如colamd，但它工作块的稀疏模式而不是通过原来的测量雅可比a正如我们上面提到的，块结构是真正的知识SLAM问题，不能访问colamd或任何其他近似排序算法。虽然对colamd性能的影响可以忽略不计，但我们发现，让它在SLAMMRF上工作，而不是直接在稀疏矩阵上工作，有时可以提高2到100倍，15是一个很好的经验法则。</p><p>请注意，在某些情况下，任何排序都会导致相同的大填充。最坏的情况是一个完全连接的二部2MRF：每个地标都可以从每个位置看到。在这种情况下，消除任何变量将完全连接所有变量的另一边，之后集团树的结构是完全已知的：如果首先选择一个姿势，根将整个地图，和所有姿态将计算一旦地图。反之亦然，如果选择了一个地标，那么轨迹将是团树根团，计算将通过（昂贵的）轨迹优化进行，然后是（非常便宜的）地标计算。最重要的是，这两种情况构成了“舒尔补体”技巧的基础，它在结构中从运动应用[76,40]中闻名，也在GraphSLAM[74]中使用。</p><p>然而，上面概述的最坏情况是机器人技术中的一个例外：传感器的范围有限，并且被墙壁、物体、建筑物等遮挡。这在大规模映射应用程序中尤其如此，它本质上意味着MRF通常将是稀疏连接的，即使它是一个大的连接组件。</p><blockquote><p>这一段文本详细解释了如何利用QR和Cholesky（或LDL）因子分解方法来处理矩阵，以及这些方法与图形模型中的推理如何相互关联。下面我将逐步解释这些内容：</p><ol type="1"><li><strong>因子分解方法</strong>:<ul><li><strong>QR 和Cholesky（或LDL）因子分解</strong>：这两种方法都基于变量消除算法。QR方法通过从因子图中消除变量节点来获得<span class="math display">\[A =QR\]</span>，而Cholesky或LDL方法从马尔可夫随机场(MRF)出发，得到 <span class="math display">\[A^T A = R^T R\]</span>。</li><li><strong>变量消除过程</strong>：从 <span class="math display">\[\delta_1\]</span> 开始，逐一消除变量，<span class="math display">\[\delta_1\]</span> 是矩阵 <span class="math display">\[A\]</span> 或 <span class="math display">\[\mathcal{I}\]</span>的最左列。消除的结果是，<span class="math display">\[\delta_1\]</span>被表示为所有其他未知数 <span class="math display">\[\delta_{j&gt;1}\]</span> 的线性组合，系数存放在<span class="math display">\[R_1\]</span>行中。这个过程引入了新的依赖性，导致图中增加了边。</li></ul></li><li><strong>图的形成与消元树</strong>:<ul><li><strong>形成弦图</strong>：通过上述变量消除，最终得到一个有向的、三角化（弦图）的图。</li><li><strong>消元树</strong>：一旦得到弦图，可以定义一个消元树，这是消元后弦图的深度优先生成树。这个树在反向替代阶段中非常有用，用于指导计算流程。</li></ul></li><li><strong>团树结构</strong>:<ul><li><strong>团树（clique tree）或连接树（junction tree）</strong>：<span class="math display">\[R\]</span>的图具有可以完全封装在团树数据结构中的团结构。团树几乎与 <span class="math display">\[R\]</span> 一一对应，每个 <span class="math display">\[R\]</span>精确对应一个团树，反之亦然，只需在团内进行列重排。</li><li><strong>多前端QR方法</strong>：在多前端QR因式分解中，计算从树的叶子到根进行，以分解一个稀疏矩阵，然后从根到叶子进行反向替代步骤。这种方法基于团树结构进行计算。</li></ul></li><li><strong>应用与扩展</strong>:<ul><li>在其他工作中，已经在分布式推断的新算法中使用了团树结构。这显示了此类数学工具不仅限于单一应用，而是可以广泛应用于各种复杂问题的求解中。</li></ul></li></ol><p>这段描述不仅阐述了两种主要的因子分解方法的技术细节，还链接了这些数学技术和图形模型理论的关系，尤其是在如何使用图结构来优化计算和推理过程中。</p></blockquote><h2 id="square-root-sam">6 Square Root SAM</h2><p>在本节中，我们将获取我们从上面所知道的所有内容，并说明三个简单的√SAM变体，这取决于它们是以批处理还是增量模式运行，以及是否涉及非线性。</p><h3 id="batchsam">6.1 Batch√SAM</h3><p>一个批量版本的平方根信息平滑和映射是很简单的，也是解决一个大的、稀疏的最小二乘问题的一种通用的标准方法：</p><p><span class="math display">\[\begin{aligned}&amp;\frac{\textbf{Algorithm 1 Batch}\sqrt{\text{SAM}}}{\text{I. Build the measurement Jacobian}A\mathrm{~and~the~RHS~}b\text{ as explained in Section3.}}\\&amp;2.\text{ Find a good column odering }p,\text{ and reorder}A_p\xleftarrow{p}A\\&amp;3.\text{ Solve }\delta_p^*=\text{ argmin}_\delta\left\|A_p\delta_p-b\right\|_2^2\text{ using ether the Choleskyor QR factorization method}\\&amp;\text{from Section 4}\\&amp;4.\text{Recover the optimal solution by }\delta\xleftarrow{r}\delta_p,\text{with}r=p^{-1}\end{aligned}\]</span></p><ol type="1"><li>建立第3节所述的雅可比值A和RHS b</li><li>找到一个好的列排序p，并重新排序App←a</li><li>使用第4节中的Cholesky或QR分解方法 解决 δ∗p=argminδkApδp−bk22</li><li>用δr←δp恢复最优解，用r=p−1</li></ol><p>在测试中，我们获得了稀疏LDL分解[13]的最佳性能，如上所述，它是计算I =LDL<sup>T</sup>的一个变体，D为对角矩阵，L是对角上的三角矩阵。同样的算法也适用于非线性情况，但被非线性优化器简单地调用。但是，请注意，排序只需要计算一次。</p><h2 id="其他">其他</h2><h3 id="消元树">消元树</h3><p>消元树是一种用来表示消除过程中变量依赖关系的树状结构，它帮助指导了矩阵分解过程中的计算流程，特别是在反向替代阶段。这里用一个具体的例子来说明这一点：</p><p>假设我们有一个系统的矩阵 <span class="math display">\[A\]</span>，我们想要进行Cholesky分解（假设<span class="math display">\[A\]</span>是对称正定的）。我们首先选择一个变量来消除，这通常是基于某种启发式方法，比如最小填充法或最小度法。</p><p>考虑以下矩阵：</p><p><span class="math display">\[A = \begin{bmatrix}4 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 4 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 4 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 3 \\\end{bmatrix}\]</span></p><p><strong>第一步：消除第一个变量</strong></p><p>我们首先消除第一个变量，这会影响与它直接相连的变量（这里是第二个变量）。消除第一个变量后，更新矩阵（做适当的行和列操作）可能会导致非零元素填充原本为零的位置，即产生“填充”。</p><p><strong>弦图的形成</strong></p><p>在这个过程中，如果我们将每个变量和与它相邻的变量视为图的一个节点和边，消除一个变量相当于在图中移除一个节点及其相关的边，并可能在未被消除的相邻节点间添加新的边（如果它们之前不直接相连）。这个操作最终形成了一个弦图，即每个循环都至少有一个弦（非环的边）的图。</p><p><strong>构建消元树</strong></p><p>在构建弦图的基础上，消元树被定义为消除过程中的依赖关系图。例如：</p><ol type="1"><li>将第一个被消除的变量作为树的根节点。</li><li>每次消除一个变量后，将受到影响的变量作为当前消除变量的子节点添加到树中。</li></ol><p>对于上面的矩阵，消元树可能如下：</p><ul><li>根节点为第一个被消除的变量。</li><li>第二个被影响的变量成为第一个节点的子节点。</li><li>依次类推，直到所有变量都被放置在树中。</li></ul><p><strong>在反向替代阶段的作用</strong></p><p>在进行例如Cholesky分解后，求解线性系统 <span class="math display">\[Ax = b\]</span> 需要先进行前代（使用 <span class="math display">\[L\]</span> 矩阵）和后代（使用 <span class="math display">\[L^T\]</span>矩阵）。在后代过程中，消元树指导了计算的顺序：从树的叶子（最先消除的变量）开始，逐步向根节点（最后消除的变量）进行，确保在计算当前变量值之前，所有依赖于它的变量值已经被计算。</p><p>通过这种方式，消元树不仅帮助优化计算过程，还确保了在计算过程中遵循正确的依赖关系，有效地利用了矩阵的稀疏性质。</p><h3 id="滤波器与平滑器">滤波器与平滑器</h3><p>在SLAM（Simultaneous Localization andMapping，即同时定位与建图）问题中，信息矩阵 (I)是一个关键的概念，用于表示机器人的状态（如位置和方向）以及环境中地标的不确定性。信息矩阵是协方差矩阵的逆，其中每个元素反映了状态变量之间的条件依赖性。</p><p><strong>滤波器与平滑器的区别</strong></p><p>在SLAM中，主要有两种处理信息的方法：滤波和平滑。</p><ol type="1"><li><strong>滤波</strong>：<ul><li>在滤波过程中，为了保持计算的实时性和可管理性，通常只会保留当前状态的信息，而把旧的状态信息“边缘化”（即从当前考虑的状态集中移除）。<strong>这种边缘化过程会引入额外的非零元素到信息矩阵中，因为边缘化旧状态意味着需要将这些状态的信息“分摊”到剩余的状态上</strong>。结果是信息矩阵变得密集，即使原来很多状态之间是条件独立的。</li><li>为了处理这种密集化，研究者通常会采用各种技术（如稀疏化技术）来移除信息矩阵中的某些链接，以减少计算负担。</li></ul></li><li><strong>平滑</strong>：<ul><li>平滑处理，相比于滤波，不会边缘化任何过去的状态。相反，它保留了所有历史和当前的状态信息，因此可以在整个时间线上提供更精确的状态估计。</li><li>在平滑方法中，由于不进行边缘化操作，所以不会引入额外的非零元素导致信息矩阵密集化。这意味着信息矩阵能够保持其原始的稀疏结构，其中非零元素主要集中在时间线上相邻状态之间的依赖关系。这种稀疏性是因为在大多数SLAM场景中，只有时间上相邻的状态或空间上邻近的地标才具有直接的相互依赖。</li></ul></li></ol><p><strong>结论</strong></p><p>因此，在与平滑信息矩阵 (I)关联的MRF中，信息矩阵保持稀疏，主要是因为平滑处理不涉及边缘化过去的状态。这样，每个状态只与其直接相关的少数几个其他状态或地标相关联，而不是与整个历史状态集相关联，从而避免了矩阵的密集化。这种方法不仅保持了计算效率，而且通常能提供比滤波更为精确的状态估计。</p><p><strong>滤波</strong>是一种在线处理方式，即它只处理当前和过去的信息，通常用于实时系统中。在滤波过程中，随着新数据的持续加入，为了维持计算的可管理性，旧的数据或状态往往需要被边缘化（移除），这导致信息矩阵趋向于变得密集。</p><p><strong>平滑</strong>则是一种离线处理方式，它考虑全部的数据（包括过去和未来的数据）。在平滑处理中，由于不需要边缘化任何状态（因为所有状态对计算都是可用的），所以关联的信息矩阵维持稀疏性，这是因为不存在需要通过边缘化引入新依赖的需求。</p><h4 id="滤波">滤波</h4><p>当然可以，让我们通过一个具体的例子来解释为什么在SLAM中进行滤波操作时，边缘化过去的状态会导致信息矩阵变得密集。</p><p><strong>示例情景</strong></p><p>假设一个机器人在一个简单的环境中沿直线移动，每移动一段距离记录一次位置，形成状态序列(X_1, X_2, X_3, ,X_t)。每个状态都与其前后状态有直接的连接（例如通过里程计测量），并可能与环境中的某些地标有关联。</p><p>在开始，信息矩阵 (I)是稀疏的，因为只有时间上相邻的状态或与某个地标直接相关的状态之间存在连接。例如，如果(X_1)和(X_2)通过里程计相关联，那么在信息矩阵中，(I_{1,1})，(I_{1,2})，和(I_{2,2})是非零的。</p><p><strong>边缘化过程</strong></p><p>当机器人继续前进并且需要在滤波器中处理新的状态时（比如(X_{t+1})），为了保持计算的可管理性，较早的状态（比如(X_1))可能会被边缘化掉。边缘化(X_1)意味着我们需要从当前激活的状态集中移除(X_1)的影响。</p><ul><li>原本(X_1)直接影响(X_2)，在边缘化(X_1)后，我们必须将(X_1)对(X_2)的影响“转移”给与(X_2)相关的其他状态，比如(X_3)。这意味着原先(X_1)与(X_3)可能没有直接关系，但在边缘化(X_1)后，(X_2)与(X_3)之间的关系需要加强，以反映从(X_1)到(X_3)的间接影响。</li></ul><p><strong>结果</strong></p><p>这个转移过程在信息矩阵中表现为原先为零的元素变成非零，因为(X_2)和(X_3)现在有了新的依赖关系。随着越来越多状态的边缘化，这种间接依赖会累积，导致信息矩阵逐渐从稀疏变为密集。</p><p><strong>几何直观</strong></p><p>可以想象，每个状态不仅与其直接的邻居有联系，还因为边缘化而与更多其他状态产生了联系。随着时间的推移，几乎每个状态都以某种方式间接地与其他所有状态连接，从而增加了信息矩阵中的非零元素数量，使矩阵变得密集。</p><p>这种密集化不仅增加了计算的复杂度，还可能影响滤波器的性能，因此在实际应用中，开发者会寻找各种方法（例如使用稀疏近似或选择性地保留关键状态）来尽可能减少这种影响。</p><h4 id="平滑">平滑</h4><p>我们可以用一个具体的数学例子来解释SLAM问题中平滑方法的信息矩阵是如何维持其稀疏性的。在这个例子中，我们考虑一个小规模的机器人轨迹，其中机器人在四个时间点上测量其位置。我们将看到在不进行边缘化的情况下，信息矩阵如何保持其结构。</p><p>假设有四个状态 (X_1, X_2, X_3,X_4)，它们代表机器人在四个连续时间点的位置。在SLAM中，通常只有连续的状态之间存在直接的测量依赖关系。</p><p>在平滑方法中，信息矩阵 (I)初始化时将反映状态之间的这些直接依赖关系。例如，如果我们假设每个状态只与其前后状态有关系，并且每个这样的依赖对信息矩阵贡献(1) 的信息值，那么信息矩阵可能看起来像这样：</p><p><span class="math display">\[I = \begin{bmatrix}1 &amp; -1 &amp; 0 &amp; 0 \\-1 &amp; 2 &amp; -1 &amp; 0 \\0 &amp; -1 &amp; 2 &amp; -1 \\0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\]</span> 这里，对角线上的元素 (2)表示一个状态依赖于其前后状态的信息总和（除了边界条件，即 (X_1) 和(X_4)）。非对角线的 (-1) 表示状态 (X_i) 与 (X_{i+1}) 和 (X_{i-1})之间的信息依赖。</p><p>在平滑方法中，由于不进行边缘化操作，我们保留所有历史状态的数据。这意味着在任何给定的时刻，我们都可以访问到所有历史和未来的状态信息，而不是只有当前和未来的状态。因此，信息矩阵的非零结构不会改变——它始终保持与初始时刻相同的稀疏模式。</p><p>这种方法的优点是，信息矩阵维持了其稀疏性，这大大减少了计算的复杂性和内存需求。例如，当使用稀疏矩阵技术处理大型SLAM问题时，这一特性非常重要。每个状态只与直接相邻的状态有关系，没有因边缘化而引入的额外复杂依赖关系。</p><p>这样的稀疏结构是高效处理大规模SLAM问题的关键，因为它减少了必须处理的数据量，并允许使用优化的数值方法来处理信息矩阵。</p><p><strong>为什么在平滑中仍然会有变量消除</strong></p><p>尽管在平滑处理中，信息矩阵维持其稀疏性质，我们仍可能需要执行某种形式的变量消除，这主要是为了效率和算法实现上的考虑。例如，在求解线性系统时（如<span class="math display">\[Ax =b\]</span>），通常会采用一些数学技术来简化问题，比如通过Cholesky分解等。在这个过程中，创建弦图和消元树是为了优化这些数学操作：</p><ol type="1"><li><p><strong>弦图的创建</strong>：在进行Cholesky分解等操作前，弦图能帮助我们识别并利用信息矩阵的稀疏结构，以减少计算过程中的填充（非零元素的添加）。</p></li><li><p><strong>消元树的建立</strong>：即便信息矩阵是稀疏的，构建消元树可以进一步提高解线性系统的效率。消元树能够指导计算顺序，确保依赖关系得到正确处理，并优化内存访问模式。</p></li></ol><p>因此，尽管平滑信息矩阵在理论上不需要通过边缘化来维护其稀疏性，但在实际计算和算法实现中，变量消除和相关的图形表示（如弦图和消元树）仍然是优化性能和保证算法效率的重要工具。</p><h3 id="qr分解">QR分解</h3><p>QR分解是将矩阵 ( A ) 分解成一个正交矩阵 ( Q ) 和一个上三角矩阵 ( R )的方法。如果 ( A ) 是一个 ( m n ) 矩阵且 ( m n)，那么分解形式通常写为：</p><p><span class="math display">\[A = QR\]</span></p><p>其中，( Q ) 是 ( m m ) 正交矩阵（( Q^T Q = QQ^T = I )），( R ) 是 ( mn ) 的上三角矩阵，其中除了前 ( n )行可能有非零元素外，其余部分全为零。在许多实际情况中，我们更关心 ( R )的前 ( n n ) 部分，因为它是一个完全的上三角矩阵。</p><p><strong>为什么 ( R ) 下面有一个0</strong></p><p>在 ( Q^T A = ) 的表达式中，( R ) 是 ( n n )的上三角矩阵，而下面的0表示在 ( Q^T ) 作用后，剩下 ( m-n )行都被消减到了零。这是因为 ( Q ) 通过正交变换将 ( A )的所有向量投影到一个由 ( A ) 的列空间张成的正交子空间。</p><p><strong>如何进行QR分解</strong></p><p>QR分解可以通过多种方式进行，包括Householder反射、Gram-Schmidt正交化或Givens旋转等。其中，Householder反射是最常用的方法，因为它具有很好的数值稳定性。</p><p><strong>Householder反射</strong>:</p><ol type="1"><li>选取一个列向量，构造一个反射矩阵 ( H)，使得除了第一项外，该列的其余项变为零。</li><li>重复应用上述过程，每次将 ( A )的一个列向量（逐步从左到右）变为期望的上三角形式。</li><li>通过连续左乘不同的Householder矩阵（( H_1, H_2, , H_n)），我们最终得到 ( Q^T A = )。</li></ol><p><strong>QR分解在最小二乘中的应用</strong></p><p>在最小二乘问题中，我们通常要最小化 ( |A- b|_2^2)。通过QR分解，我们可以转化这个问题为：</p><p><span class="math display">\[\|Q^T(A\delta - b)\|_2^2 = \|R\delta - Q^Tb\|_2^2\]</span></p><p>由于 ( Q ) 是正交的，所以转换不会改变二范数。因此，问题简化为最小化 (|R- d|_2^2 )（其中 ( d ) 是 ( Q^Tb ) 的前 ( n ) 个元素）加上 ( |e|_2^2)（其中 ( e ) 是 ( Q^Tb ) 的剩余 ( m-n ) 个元素，代表方程的残差）。</p><p>由于 ( R ) 是上三角的，这个问题可以通过反向替换直接求解 ( R= d)，从而找到最小二乘解 ( ^* )。</p><p>在说明为什么在 ( A = QR ) 分解中，矩阵 ( R ) 除了前 ( n )行可能有非零元素外，其余部分全部为 0之前，有必要澄清上面的描述有些不够精确。对于标准的 ( A = QR )分解，特别是当 ( A ) 是 ( m n ) 矩阵且 ( m n )时，我们应该更明确地表示这个关系。</p><p><strong>正确的 ( R ) 矩阵结构</strong></p><p>在 ( A = QR ) 分解中，( R ) 实际上是一个 ( n n ) 的上三角矩阵，而不是( m n ) 的矩阵。这是因为 ( Q ) 是一个 ( m m ) 的正交矩阵，而 ( R )是一个 ( m n ) 的矩阵，其中只有顶部的 ( n n ) 部分是上三角形的，其余 (m-n ) 行则全部为零。这样，( QR ) 的乘积仍然能重构出原始的 ( m n ) 矩阵 (A )。</p><p><strong>为什么 ( R ) 的下部为零</strong></p><ol type="1"><li><p><strong>正交变换的作用</strong>：在 ( QR ) 分解中，( Q )的作用是通过正交变换（如Householder变换或Givens旋转）逐步将 ( A )的列向量变为上三角形式。每次变换主要集中在将当前处理的列下方的元素变为零。</p></li><li><p><strong>维度限制</strong>：当处理到 ( A ) 的第 ( n ) 列时，如果 (m &gt; n )，则在 ( n )行之下没有更多的列元素可以继续处理。因此，在完成所有列的变换后，( R )矩阵中 ( n ) 行以下的部分将会保持为零。这是因为这部分 ( Q )中的变换已经将 ( A ) 的所有相关信息“推”到了其前 ( n )行中的上三角形状。</p></li></ol><p>因此，( R ) 矩阵的结构确保了 ( QR ) 分解的过程只影响 ( A ) 的前 ( n )行，而其余 ( m-n ) 行为零，确保 ( QR ) 乘积可以精确重构原始矩阵 ( A)。这种结构特点是 ( QR )分解的一个重要特性，使得它在解决线性最小二乘问题和其他矩阵相关计算中非常有效。</p><h3 id="信息矩阵i">信息矩阵I</h3><p>在机器人定位和地图构建的问题中，通常涉及到估计机器人在环境中的位置（轨迹(X)）以及环境本身的结构（地图 (L)）。在这种情况下，信息矩阵()，也被称为费舍尔信息矩阵，是用来表示这些未知量的不确定性和相互依赖关系的关键工具。</p><p>信息矩阵 () 是由雅可比矩阵 (A)（或系统的设计矩阵）通过 (A^T A)计算得到的。这个矩阵可以从以下几个方面描述机器人轨迹和地图内部的信息：</p><ol type="1"><li><strong>量化不确定性</strong>:<ul><li><strong>对角线元素</strong>：信息矩阵的对角线元素量化了每个参数（位置或地图特征）的信息量或确信度。对角线元素的值越大，表示对应参数的不确定性越小，我们对该参数的估计越精确。</li><li><strong>非对角线元素</strong>：非对角线元素描述了参数之间的依赖关系或相关性。例如，如果位置(x_i) 和位置(x_j)（或地图特征）在矩阵中的对应元素非零，这表明这两个位置（或特征）的估计值相互依赖。</li></ul></li><li><strong>编码相关性</strong>:<ul><li>分块 (<em>{XL}) 和 (</em>{XL}^T) 特别重要，因为它们编码了轨迹 (X)和地图 (L)之间的相关性。这意味着机器人在特定位置的估计如何依赖于地图的特定特征，反之亦然。这种相关性对于同时定位和地图构建（SLAM）至关重要，因为它帮助系统同时解决导航和地图创建的问题。</li></ul></li><li><strong>优化和解算</strong>:<ul><li>在实际应用中，基于信息矩阵的结构，可以采用更有效的数值方法来解决估计问题，如使用稀疏矩阵技术处理大规模SLAM问题。信息矩阵的稀疏性表明很多参数之间的依赖性较低，这可以大大减少计算量。</li></ul></li></ol><p>总之，信息矩阵 ()不仅提供了对机器人轨迹和地图每一部分的内部信息的详尽描述，而且还通过其结构揭示了不同部分之间的相互作用和依赖性，从而在理论和实践中都是解决SLAM问题的核心部分。</p><p>这段话描述的是矩阵()，它代表了信息矩阵，在这个具体例子中，它是用于机器人状态估计的问题。矩阵() 是通过矩阵 (A) 的转置乘以 (A) 计算得到的，这里 (A)被分为两部分：对应于机器人轨迹 (X) 的 (A_X) 和对应于地图 (L) 的(A_L)。</p><p>矩阵 () 的结构表明它分为四个部分：</p><ol type="1"><li>(A_X^T A_X)：这是左上角的块，代表轨迹 (X) 内部的信息。</li><li>(A_L^T A_L)：这是右下角的块，代表地图 (L) 内部的信息。</li><li>(<em>{XL}) 和 (</em>{XL}^T)：这两个块分别位于非对角线的位置，(_{XL}A_X^T A_L) 和其转置表示轨迹 (X) 和地图 (L) 之间的相关性。</li></ol><p><span class="math display">\[\mathcal{I}_{XL} \triangleq A_X^T A_L\]</span></p><p>表示的是 (A_X) 和 (A_L) 之间的交叉信息，它编码了机器人状态 (X) 和地图(L) 之间的相关性。对角线块 (A_X^T A_X) 和 (A_L^T A_L)表明它们是“带对角线”的，这通常意味着这些块主要关注各自的内部结构和相互作用，而不是外部的。</p><h3 id="关于ax-b-中a和b的物理意义">关于AX-b 中A和b的物理意义</h3><p>在SLAM（Simultaneous Localization andMapping）问题中，机器人的动态与环境交互通过一系列的状态转移和观测更新来描述。矩阵( A )在这个问题中的作用，是将这些动态和交互的关系转化为数学形式，特别是以线性化的方式来近似非线性系统的行为。下面详细解释这一点：</p><p><strong>机器人的动态</strong></p><p>机器人的动态指的是机器人如何根据其控制指令（如速度和方向）从一个状态（位置和方向）移动到另一个状态。这些动态通常可以用一个非线性函数( f ) 表示：</p><p><span class="math display">\[x_i = f(x_{i-1}, u_i)\]</span></p><p>其中，( x_i ) 和 ( x_{i-1} ) 分别是连续两个时间步的状态，( u_i )是在时间 ( i ) 应用的控制指令。在SLAM问题的线性化处理中，我们对函数 ( f) 在某个点进行泰勒展开，通常是在预测状态附近，得到：</p><p><span class="math display">\[x_i \approx F_i^{i-1} x_{i-1} + G_i^i u_i\]</span></p><p>其中，( F_i^{i-1} ) 和 ( G_i^i )是偏导数矩阵，代表状态和控制输入对新状态的线性影响。这一部分在矩阵 ( A )中以块的形式出现，描绘了状态之间的转移关系。</p><p><strong>环境的观测</strong></p><p>环境的观测描述了机器人如何通过其传感器（如摄像头、激光雷达）观察到周围环境，特别是地标的位置。这些观测同样可以表示为一个非线性关系( h )：</p><p><span class="math display">\[z_k = h(x_{i_k}, l_{j_k})\]</span></p><p>其中，( z_k ) 是第 ( k ) 次观测，( x_{i_k} ) 是观测时的机器人状态，(l_{j_k} )是被观测的地标。同样地，通过在预测观测点附近进行泰勒展开，我们得到观测的线性化模型：</p><p><span class="math display">\[z_k \approx H_k^{i_k} x_{i_k} + J_k^{j_k} l_{j_k}\]</span></p><p>这里的 ( H_k^{i_k} ) 和 ( J_k^{j_k} )代表观测模型的线性化矩阵，反映了状态和地标位置对观测结果的线性影响。这部分在矩阵( A ) 中也以块的形式呈现。</p><p><strong>总结</strong></p><p>因此，矩阵 ( A )通过其块状结构和各个元素，捕捉了机器人如何移动（动态）和如何观察周围环境（观测）的数学描述。这不仅包括了机器人状态的转移关系，还包括了状态与环境地标之间的相互作用。通过优化问题最小化( |A- b|_2^2)，我们实际上是在调整对机器人状态和地图的估计，使得这些线性化的预测尽可能贴近实际观测，从而实现同时定位与地图构建的目的。在SLAM（Simultaneous Localization and Mapping）问题中，矩阵 ( A ) 和向量( b ) 代表了机器人定位与地图构建问题的线性化模型。这里详细解释矩阵 ( A )的意义和重要性：</p><p><strong>矩阵 ( A ) 的意义：</strong></p><ol type="1"><li><strong>物理意义</strong>：矩阵 ( A )表示系统状态变量之间的关系，以及状态变量与观测之间的线性关系。具体来说：<ul><li><strong>运动模型部分</strong>：矩阵 ( F_i^{i-1} ) 和 ( G_i^i )表示从状态 ( x_{i-1} ) 到状态 ( x_i )的线性化运动模型。这些块表示了机器人如何从一个位置（和/或方向）移动到下一个位置，通常基于机器人的控制指令如转向和前进。</li><li><strong>观测模型部分</strong>：矩阵 ( H_k^{i_k} ) 和 ( J_k^{j_k} )表示状态 ( x_{i_k} ) 和地标 ( l_{j_k} ) 如何影响第 ( k )次观测。这反映了如何从当前状态和地标位置预测观测值（例如，从摄像头或激光雷达）。</li></ul></li><li><strong>计算意义</strong>：在最优化问题中，我们通常求解最小化 (|A-b|_2^2)，这是一个最小二乘问题，意味着我们在寻找最佳的状态变量更新 ()，使得线性化模型的预测尽可能接近实际观测和运动指令的结果。</li></ol><p><strong>为什么 ( A ) 重要：</strong></p><ul><li>( A )矩阵捕捉了机器人动态和环境的整体结构，这是理解和解决SLAM问题的核心。正确构建和更新这个矩阵对于准确地估计机器人的状态和地图至关重要。</li><li>矩阵的稀疏性表明大多数状态变量不直接相互影响，这在数值计算上是有利的。稀疏矩阵技术可以显著提高求解SLAM问题的效率。</li></ul><p>因此，( A )矩阵不仅在物理上描绘了机器人在环境中的动态和相互作用，而且它是数学上解决状态估计问题的基础。通过理解和利用这种结构，可以更有效地实现机器人的自主导航和环境感知。</p><p>在SLAM（Simultaneous Localization and Mapping）问题中，矩阵 ( A )和向量 ( b )的物理意义及其在优化问题中的作用是核心部分，反映了状态估计的数学模型与实际操作间的联系。以下是使用LaTeX 语法格式输出的详细解释：</p><p><strong>矩阵 ( A ) 和向量 ( b ) 的物理意义</strong></p><ol type="1"><li><strong>矩阵 ( A )</strong>：矩阵 ( A )在SLAM中代表系统的线性化状态转移和观测模型。它是状态和观测之间关系的线性近似表示，包含了如下两个主要部分：<ul><li><strong>状态转移模型</strong>：通过 ( F_i^{i-1} ) 和 ( G_i^i )描述的块，这些块说明了给定控制输入 ( u_i ) 下，机器人状态从 ( x_{i-1} )转移到 ( x_i ) 的预测模型。</li><li><strong>观测模型</strong>：通过 ( H_k^{i_k} ) 和 ( J_k^{j_k} )描述的块，这些块表明如何从当前的状态和地标位置预测可能的观测结果 ( z_k)。</li></ul></li><li><strong>向量 ( b )</strong>：向量 ( b )通常包含观测数据与由模型预测的状态转移或观测的差异。在SLAM中，( b )可能由实际观测值 ( z_k )减去根据当前状态估计和地标估计得到的预测观测值构成。</li></ol><p><strong>最小化正规方程 ( A^T A x = A^T b )</strong></p><p>在SLAM问题的线性化模型中，我们通常希望找到一个状态变量的更新量 ()，使得模型预测尽可能贴近实际的观测。具体来说，我们尝试最小化以下目标函数：</p><p><span class="math display">\[\| A \delta - b \|_2^2\]</span></p><p>这里：</p><ul><li>( | |_2^2 ) 表示二范数的平方，用于度量误差的大小。</li><li>( A ) 表示对当前状态估计的改正（或更新）。</li><li>( b ) 是观测数据与模型预测之间的差异。</li></ul><p><strong>通过最小化这个误差，我们在数学上是在寻找一个向量 ( )，使得 (A ) 尽可能接近 ( b)，即尝试对预测的状态和观测进行校正，以逼近真实的观测值。</strong></p><p>解决这个最小化问题通常涉及到求解正规方程：</p><p><span class="math display">\[A^T A \delta = A^T b\]</span></p><ul><li>( A^T A ) 是一个方阵，通常更易于处理，尤其是当 ( A )是稀疏或结构化的时，这种方法效率更高。</li><li>( A^T b )是一个向量，表示在当前误差度量下，最佳更新方向的投影。</li></ul><p>简而言之，矩阵 ( A ) 和向量 ( b )在SLAM中承载着将复杂的非线性系统模型化并使之适合数学优化的重任。通过这种优化，我们能够不断提高对机器人在未知环境中位置及其环境地图的估计精度。</p><h3 id="因子图的迭代优化算法">因子图的迭代优化算法</h3><p>图优化的迭代优化通常涉及到通过逐步优化来调整和改进图中的节点估计（即状态变量），以最小化整个图中所有误差函数（因子）的总和。这个过程通常使用类似于高斯-牛顿或者Levenberg-Marquardt（LM）算法的优化方法。</p><p><strong>图优化迭代过程</strong></p><ol type="1"><li><strong>初始化</strong>：<ul><li>节点的初始估计通常基于传感器的原始数据或某些先验知识。</li></ul></li><li><strong>构建误差函数</strong>：<ul><li>对于图中的每一个因子，构建一个误差函数，该函数衡量当前节点状态估计与观测数据之间的差异。</li></ul></li><li><strong>线性化误差函数</strong>：<ul><li>在当前估计点附近对误差函数进行线性化，通常是通过计算误差函数相对于每个节点状态的雅可比矩阵。</li></ul></li><li><strong>构建正规方程</strong>：<ul><li>将所有线性化的误差函数组合成一个大的系统方程。这通常表现为一个大的稀疏线性系统，可以写成<span class="math display">\[ H\delta = b \]</span> 的形式，其中 ( H )是信息矩阵（或海森矩阵），而 ( b ) 是基于误差的向量。</li></ul></li><li><strong>求解线性系统</strong>：<ul><li>使用直接求解器（如Cholesky分解）或迭代求解器（如共轭梯度法）来解决上述线性系统，以找到状态更新()。</li></ul></li><li><strong>更新状态估计</strong>：<ul><li>将解得的 () 应用到当前的状态估计中，更新所有节点的状态。</li></ul></li><li><strong>迭代和收敛检查</strong>：<ul><li>检查解的改进程度，如果未达到预设的收敛标准（如状态改变量的大小低于某个阈值或达到最大迭代次数），则重复步骤2-6。</li></ul></li><li><strong>最终优化结果</strong>：<ul><li>当迭代收敛时，当前的状态估计被认为是优化的解，即图中所有节点的最优估计。</li></ul></li></ol><p><strong>使用Levenberg-Marquardt方法的特别说明</strong></p><p>Levenberg-Marquardt算法是高斯-牛顿算法的一个变种，通过引入一个调整参数（阻尼因子）来平衡算法的迭代速度与稳定性。这个阻尼因子可以动态调整，以在必要时约束更新步长，从而提高收敛性和算法的鲁棒性。</p><p>图优化的迭代优化是一个强大的工具，特别适用于大规模、复杂的环境建模，如同时定位与地图创建（SLAM）等应用场景中。通过迭代改进，算法能够有效地精炼传感器数据与模型之间的不一致，最终达到高精度的状态估计。</p><h3 id="为什么用cholesky-分解求解正规方程">为什么用Cholesky分解求解正规方程</h3><p>当然可以，这里是使用 LaTeX 语法重新整理的解释：</p><p><strong>为什么使用 Cholesky 分解？</strong></p><ol type="1"><li><strong>效率和稳定性</strong>：<ul><li><strong>效率</strong>：Cholesky分解相比于其他方法（如LU分解或QR分解）通常更为高效。它的计算复杂度大约是<span class="math display">\[\frac{1}{3} n^3\]</span> 对于 <span class="math display">\[n \times n\]</span>矩阵，而LU分解和QR分解的计算复杂度分别大约是 <span class="math display">\[\frac{2}{3} n^3\]</span> 和 <span class="math display">\[2n^3\]</span>。这使得Cholesky分解成为求解大型正定线性系统的首选方法。</li><li><strong>稳定性</strong>：对于对称正定矩阵，Cholesky分解非常稳定。由于对称性和正定性保证了分解的成功执行，它避免了在数值分解过程中的潜在不稳定性。</li></ul></li><li><strong>数值属性</strong>：<ul><li>在数值线性代数中，Cholesky分解对于对称正定矩阵来说是一种数值上稳定的方法，特别是当矩阵<span class="math display">\[A^T A\]</span>的条件数相对较低时。这是因为它直接利用了矩阵的对称性和正定性。</li></ul></li><li><strong>简化求解过程</strong>：<ul><li>通过Cholesky分解，矩阵 <span class="math display">\[A^T A\]</span>被分解为一个下三角矩阵 <span class="math display">\[L\]</span>和其转置的上三角矩阵 <span class="math display">\[L^T\]</span>的乘积，即 <span class="math display">\[A^T A = LL^T\]</span>。这种分解简化了线性系统的求解，因为只需先解下三角系统 <span class="math display">\[L \mathbf{y} = A^T \mathbf{b}\]</span>获得临时向量 <span class="math display">\[\mathbf{y}\]</span>，然后解上三角系统 <span class="math display">\[L^T \mathbf{x} = \mathbf{y}\]</span> 获取最终解<span class="math display">\[\mathbf{x}\]</span>。</li><li>这种分步求解的过程比直接求解原方程更易于处理，并且可以有效地利用现代计算机体系结构。</li></ul></li></ol><p><strong>总结</strong></p><p>由于上述优点，Cholesky分解成为解决正定线性系统（特别是在涉及正规方程时）的理想选择，提供了一种高效、稳定的方法来求解最小二乘问题中的线性系统。这在实际应用中，如图优化、信号处理、统计数据分析等领域，具有广泛的应用。</p><h3 id="为什么要引进g_ii-i_dtimes-d">为什么要引进<span class="math inline">\(G_i^i=-I_{d\times d}\)</span></h3><p>在因子图和图优化中进行线性化处理时，引入矩阵<span class="math inline">\(G_i^i = -I_{d \timesd}\)</span>是为了便于表达和操作线性化的状态变化量。这里，$ I_{d d} $表示( d )-维的单位矩阵。矩阵 ( G_i^i ) 的作用是在数学表达式中简化状态变量 (x_i ) 的运算，从而使得该线性系统易于使用线性代数技术求解。</p><p><strong>背景</strong></p><p>在线性化的SLAM或图优化问题中，我们通常处理的是两类项：</p><ol type="1"><li><strong>过程模型项</strong>：它们涉及从一个状态 ( x_{i-1} )到下一个状态 ( x_i ) 的过渡，如机器人的运动模型。</li><li><strong>测量模型项</strong>：涉及从状态变量到测量变量的映射，如从机器人的位置到传感器观测的映射。</li></ol><p><strong>引入 $G_i^i = -I_{d d} $</strong></p><p>在方程 (6) 中，我们考虑了状态变量 ( x_i ) 和 ( x_{i-1} )之间的关系。线性化后的模型需要处理这些状态变量的增量 ( x_i ) 和 (x_{i-1} )。线性化过程后的表达式为：</p><p><span class="math display">\[f_i(x_{i-1}, u_i) - x_i \approx \{ f_i(x_{i-1}^0, u_i) + F_i^{i-1}\delta x_{i-1} \} - \{ x_i^0 + \delta x_i \}\]</span> 要将这个方程转换成标准的线性形式，我们需要确保 ( x_i ) 和 (x_{i-1} ) 在同一方程中有适当的正负号。在这里，引入 ( G_i^i = -I_{d d} )允许我们将 ( x_i ) 项简单地表示为加法形式的负增量，即：</p><p><span class="math display">\[F_i^{i-1} \delta x_{i-1} - \delta x_i = F_i^{i-1} \delta x_{i-1} + G_i^i\delta x_i\]</span> 这样，线性方程更容易处理，因为它将状态变化量 ( x_i )直接以线性代数的标准形式表示，允许使用矩阵运算直接进行计算。</p><p><strong>线性最小二乘问题</strong></p><p>通过引入 ( G_i^i = -I_{d d})，整个问题可表示为一个标准的线性最小二乘问题：</p><p><span class="math display">\[\delta^* = \underset{\delta}{\operatorname*{argmin}} \left\{\sum_{i=1}^M \| F_i^{i-1} \delta x_{i-1} + G_i^i \delta x_i + a_i\|_{\Lambda_i}^2 + \sum_{k=1}^K \| H_k^{i_k} \delta x_{i_k} + J_k^{j_k}\delta l_{j_k} - c_k \|_{\Sigma_k}^2 \right\}\]</span>这个形式使得应用线性代数和优化方法成为可能，从而可以有效求解大规模SLAM问题。</p><h3 id="因子图的即插即用">因子图的即插即用</h3><p>因子图对于处理传感器更新频率不一致问题提供了一种灵活且有效的方式，特别是在复杂的多传感器融合系统中。这主要得益于因子图在处理多源信息与维持全局状态估计方面的灵活性。</p><p>在因子图中，每个传感器的输入可以被视为一个因子，它只与图中的某些变量（例如机器人的某个位置）相关联。当新的传感器数据到来时，可以简单地将相应的新因子添加到图中，而无需重新配置整个系统。这使得因子图非常适合于处理具有不同更新频率的传感器数据。</p><p><strong>具体例子</strong></p><p>假设一个机器人装备了一个高频率的IMU（惯性测量单元）和一个低频率的GPS。IMU能够提供高频率但低精度的位置和方向更新，而GPS提供低频率但高精度的位置测量。</p><ol type="1"><li><strong>构建因子图</strong>：机器人的每个状态（位置和姿态）都是图中的一个节点。IMU和GPS的每次读数分别产生一个新的因子，这些因子与特定的状态节点相连接。</li><li><strong>IMU因子</strong>：IMU的数据频繁更新，为图中相邻的状态节点间提供动态的约束（如速度和方向）。</li><li><strong>GPS因子</strong>：GPS数据不频繁，但每当数据到来时，会在因子图中创建一个新的因子，这个因子直接将GPS测量的位置与最近的状态节点相关联。</li><li><strong>因子更新</strong>：无论何时收到新的传感器数据，都只需将对应的新因子添加到图中并重新优化，而不必修改或重处理整个图。</li></ol><p><strong>与卡尔曼滤波的比较</strong></p><p>卡尔曼滤波器（包括其扩展和无迹变体）通常需要处理所有传感器数据的固定结构和预设的处理流程。每个传感器都需要在每个时间步被处理，即使某些传感器的数据并未更新。</p><ul><li><strong>即插即用</strong>：卡尔曼滤波处理新传感器集成通常需要重新设计滤波过程和状态协方差的计算，而因子图可以更容易地通过添加新的因子来整合新传感器，无需重新设计或重新初始化整个系统。</li><li><strong>处理非同步数据</strong>：卡尔曼滤波器对于非同步传感器数据处理通常需要额外的插值或同步机制，而因子图可以更自然地通过在适当的时间点插入因子来处理这种数据。</li></ul><p>因子图的这种灵活性使其非常适合于动态环境中的实时应用，特别是当涉及多个传感器，且这些传感器可能动态变化（如增加或移除传感器）时。因子图提供了一种高效、灵活且可扩展的方法来处理这种复杂性。</p><p>卡尔曼滤波器（KF）是一种适用于线性系统（或近似线性）的递推滤波方法，它依赖于数据输入的同步和连续性。在实际应用中，如自动驾驶车辆、机器人导航或多传感器融合系统中，传感器可能无法以同一频率或同步的方式产生数据。这会给基于卡尔曼滤波的系统设计带来挑战。</p><p><strong>卡尔曼滤波器和非同步数据处理</strong></p><p>当使用卡尔曼滤波器处理来自不同传感器的数据时，若这些传感器的更新频率不一致或数据非同步接收，可能需要进行额外处理以保证数据的时序一致性。这主要是因为卡尔曼滤波器在每个时间步更新状态估计时都假定接收到的数据是当前时刻的准确反映。</p><p><strong>举例说明</strong></p><p>假设有一个移动机器人使用两种传感器：一个激光雷达（LIDAR）和一个轮速计。激光雷达每100毫秒更新一次位置信息，而轮速计每30毫秒更新一次速度信息。如果直接将这些数据输入到一个卡尔曼滤波器，可能会出现问题，因为两种数据的时间戳不匹配。</p><p>为了同步这些传感器数据，一个常见的方法是使用插值：</p><ul><li><strong>插值</strong>：例如，可以使用线性插值或更复杂的插值方法（如样条插值）来估计激光雷达测量间隙中的位置数据，或者在轮速计测量间隙中估计速度，以便在非测量时刻提供数据估计。</li><li><strong>数据缓冲</strong>：另一种方法是对快速更新的传感器（轮速计）数据进行缓冲，直到慢速传感器（激光雷达）的下一次数据到来，然后一起处理这些数据。</li></ul><p>卡尔曼滤波器（KF）处理的核心在于它按照严格的时序顺序处理观测数据来更新状态估计。这个处理过程基于两个关键假设：系统的动态是已知的，并且观测数据是同步到特定的时间点的。当观测数据来自频率不同或非同步的多个传感器时，这些假设可能不再成立，直接接受数据而不进行任何处理可能会导致以下问题：</p><p><strong>1. 误差累积</strong></p><p>卡尔曼滤波器在每个时间步更新其状态估计时，假设最新的观测数据反映了当前的系统状态。如果直接使用非同步的观测数据，滤波器可能无法准确地关联观测数据与其对应的状态，从而导致误差累积。例如，如果一个传感器的数据延迟或提前了，而滤波器误以为这些数据是最新的，那么更新的状态估计可能会基于错误的信息。</p><p>卡尔曼滤波器（KF）处理的核心在于它按照严格的时序顺序处理观测数据来更新状态估计。这个处理过程基于两个关键假设：系统的动态是已知的，并且观测数据是同步到特定的时间点的。当观测数据来自频率不同或非同步的多个传感器时，这些假设可能不再成立，直接接受数据而不进行任何处理可能会导致以下问题：</p><p><strong>1. 误差累积</strong></p><p>卡尔曼滤波器在每个时间步更新其状态估计时，假设最新的观测数据反映了当前的系统状态。如果直接使用非同步的观测数据，滤波器可能无法准确地关联观测数据与其对应的状态，从而导致误差累积。例如，如果一个传感器的数据延迟或提前了，而滤波器误以为这些数据是最新的，那么更新的状态估计可能会基于错误的信息。</p><p><strong>2. 时间戳不匹配</strong></p><p>在处理来自不同传感器的数据时，每个传感器的输出通常带有时间戳。如果这些时间戳不一致，直接接受数据意味着滤波器可能会在错误的时间点应用观测数据，导致状态更新不准确。这对于那些高度依赖精确时间信息的应用（如导航和跟踪系统）尤为重要。</p><p><strong>3. 数据丢失或重叠</strong></p><p>非同步数据可能导致数据在时间轴上出现重叠或缺口。例如，一个传感器可能在另一个传感器的两次读数之间多次更新，或者在长时间内没有更新。这种情况下，直接处理可能导致某些观测数据被忽略或重复计算，影响滤波器的性能。</p><p><strong>解决方法：插值和数据缓冲</strong></p><p>为了解决这些问题，卡尔曼滤波器通常采用以下策略：</p><ul><li><p><strong>插值</strong>：通过插值方法（如线性插值、样条插值等）创建虚拟的观测数据，填补时间上的缺口，使得每个时间步都有相应的数据输入。这有助于保持滤波器的连续性和准确性。</p></li><li><p><strong>数据缓冲</strong>：将来自不同传感器的数据存储在缓冲区中，直到收集到所有相关传感器的数据为止。然后，根据这些数据的时间戳一起处理它们。这样可以保证数据在时间上的一致性，减少由于时间错配引起的误差。</p></li></ul><p>这两种方法使得卡尔曼滤波器能够更加稳定和准确地处理来自多源的非同步数据，从而提高系统的整体性能。</p><p>在处理来自不同传感器的数据时，每个传感器的输出通常带有时间戳。如果这些时间戳不一致，直接接受数据意味着滤波器可能会在错误的时间点应用观测数据，导致状态更新不准确。这对于那些高度依赖精确时间信息的应用（如导航和跟踪系统）尤为重要。</p><p><strong>3. 数据丢失或重叠</strong></p><p>非同步数据可能导致数据在时间轴上出现重叠或缺口。例如，一个传感器可能在另一个传感器的两次读数之间多次更新，或者在长时间内没有更新。这种情况下，直接处理可能导致某些观测数据被忽略或重复计算，影响滤波器的性能。</p><p><strong>解决方法：插值和数据缓冲</strong></p><p>为了解决这些问题，卡尔曼滤波器通常采用以下策略：</p><ul><li><p><strong>插值</strong>：通过插值方法（如线性插值、样条插值等）创建虚拟的观测数据，填补时间上的缺口，使得每个时间步都有相应的数据输入。这有助于保持滤波器的连续性和准确性。</p></li><li><p><strong>数据缓冲</strong>：将来自不同传感器的数据存储在缓冲区中，直到收集到所有相关传感器的数据为止。然后，根据这些数据的时间戳一起处理它们。这样可以保证数据在时间上的一致性，减少由于时间错配引起的误差。</p></li></ul><p>这两种方法使得卡尔曼滤波器能够更加稳定和准确地处理来自多源的非同步数据，从而提高系统的整体性能。</p><p><strong>因子图的优势</strong></p><p>相比之下，因子图提供了一个更灵活的框架来处理非同步数据。因子图是一种图形模型，它以图的形式表示变量之间的条件依赖关系。在因子图中，每个传感器的读数可以作为一个因子被添加到图中，这些因子与它们影响的状态变量相关联。如果传感器数据是非同步的，可以：</p><ul><li><strong>动态添加因子</strong>：根据每个传感器的时间戳动态地向图中添加新的因子。这意味着每个传感器更新只影响相关的状态变量，不需要人为地同步所有数据。</li><li><strong>时间标记</strong>：每个因子可以携带时间信息，因此状态更新可以在正确的时间点进行，与数据实际测量的时间相匹配。</li></ul><p>因此，因子图模型通过在合适的时间点添加因子来自然地处理非同步的传感器数据，从而避免了在卡尔曼滤波器中必须进行的数据插值或同步。这样不仅简化了处理过程，而且可能提高了系统的整体性能和精度。</p><h3 id="因子图优化更新节点状态"><strong>因子图优化更新节点状态</strong></h3><ul><li><strong>应用方式</strong>：图优化通常处理的是整个数据集（如历史路径或多个观测数据点），并且通常适用于离线或批处理模式，适用于大规模空间问题，如SLAM。而EKF通常在线性化当前或最近的状态来进行实时更新，适用于需要快速反应的动态系统，如实时机器人导航。</li><li><strong>数据处理方式</strong>：EKF以递归方式连续更新状态，侧重于实时估计；图优化则可能在获得新数据后对整个历史数据进行重新优化，侧重于精度和全局一致性。</li></ul><p>让我们逐一探讨这两个问题：</p><p><strong>1. 根据导数信息计算状态更新量的例子</strong></p><p>考虑一个简单的SLAM问题，其中机器人需要确定它的位置 ( x )和地图上一个地标的位置 ( l )。假设有一个观测 ( z )与机器人的位置和地标之间的距离相关。</p><p><strong>步骤</strong></p><ul><li><p><strong>误差函数</strong>：设 ( h(x, l) ) 是从机器人位置 ( x )到地标 ( l ) 的预测测量，误差函数 ( e ) 可表示为 ( e = z - h(x, l))。</p></li><li><p><strong>雅可比矩阵</strong>：计算误差 ( e ) 关于状态 ( x )和地标位置 ( l ) 的雅可比矩阵 ( J_x ) 和 ( J_l )。</p></li><li><p><strong>更新公式</strong>：使用高斯牛顿法，更新公式可以写作：</p><p><span class="math display">\[\begin{pmatrix} \Delta x \\ \Delta l \end{pmatrix} = -(J^T J + \lambdaI)^{-1} J^T e\]</span></p><p>其中 ( J ) 是组合了 ( J_x ) 和 ( J_l ) 的雅可比矩阵，( )是为了提高数值稳定性而添加的阻尼因子（Levenberg-Marquardt算法中使用），(I ) 是单位矩阵。</p></li><li><p><strong>状态更新</strong>：计算得到的 ( x ) 和 ( l )用来更新当前状态和地标位置。</p></li></ul><p><strong>2. 增量式图优化方法的实际操作</strong></p><p>在实时系统如自动驾驶车辆中，增量图优化主要关注最近的观测和状态，以减少每次更新所需的计算资源。</p><p><strong>步骤</strong></p><ul><li><strong>局部图更新</strong>：每当接收到新的观测数据时，只更新与这些新数据直接相关的节点和边，这些通常是最近的机器人状态和相关地标。</li><li><strong>窗口优化</strong>：一种常见的策略是固定滑动窗口方法，即仅在固定大小的最近状态窗口内进行优化。较旧的状态和地标，一旦它们超出窗口，可以被边缘化（从优化问题中移除但考虑其对现有状态的统计影响）或锁定。</li><li><strong>增量求解器</strong>：使用专门设计的增量求解器，如 iSAM 或g2o，这些工具能够有效地更新信息矩阵和求解增量更新问题。</li><li><strong>实时反馈</strong>：通过快速更新仅涉及局部改动的解决方案，系统能够快速地对新数据做出响应。</li></ul><p>这种增量更新方法能够显著降低因每个新观测而进行全局优化的计算成本，使系统更适合实时应用场景，如自动驾驶或动态环境中的机器人导航。</p><h3 id="如何根据联合概率密度分布-求解">如何根据联合概率密度分布求解</h3><p>在解决导航和地图构建的问题中，目标通常是找到一组变量（机器人的位置和地图配置）的配置，<strong>这些配置最能解释观测数据和已知信息。</strong>这里的“解释”通常是指在给定模型下，找到最大化联合概率<span class="math inline">\(P(X, L, Z)\)</span> 的 (X)（位置）和(L)（地图）的配置。这种方法是基于最大似然估计或最大后验估计的原理。</p><p><strong>最大似然估计和最大后验估计</strong></p><ul><li><p><strong>最大似然估计（MLE）</strong>:在这种情况下，我们寻找的是最大化观测数据 (Z) 出现概率的位置 (X) 和地图(L) 配置，不考虑位置和地图的先验概率。数学上表达为 <span class="math inline">\(\arg\max_{X, L} P(Z|X, L)\)</span>。</p></li><li><p><strong>最大后验估计（MAP）</strong>:更常见的是，我们寻找能够最大化后验概率<span class="math inline">\(P(X, L| Z)\)</span>的 (X) 和 (L)。由于根据贝叶斯公式，<span class="math inline">\(P(X, L | Z) \propto P(Z | X, L) P(X,L)\)</span>，这不仅考虑了观测数据的似然度，还包括了关于位置和地图的先验知识。</p></li></ul><p><strong>计算过程</strong></p><ol type="1"><li><strong>定义概率模型</strong>:<ul><li>状态转移概率 <span class="math inline">\(P(x_i | x_{i-1},u_i)\)</span>描述了给定前一状态和控制输入后，当前状态的概率。</li><li>观测模型 <span class="math inline">\(P(z_k | x_{i_k},l_{j_k})\)</span>描述了给定当前状态和地图配置时，观测数据出现的概率。</li><li>先验<span class="math inline">\(P(X,L)\)</span>可能基于以前的知识或假设（如位置的均匀分布，或地图的某些特征）。</li></ul></li><li><strong>优化过程</strong>:<ul><li>在实践中，最大化<span class="math inline">\(P(X, L | Z)\)</span>通常涉及到优化算法，如梯度上升、期望最大化（EM）算法或其他非线性优化技术。</li><li>在机器人技术中，常见的优化工具包括粒子滤波（用于非线性/非高斯问题）和卡尔曼滤波（用于线性/高斯问题）。</li></ul></li><li><strong>联合概率和解释</strong>:<ul><li>我们不是寻找最小的联合概率，而是寻找最大化后验概率的 (X, L)配置，因为后验概率高意味着给定观测数据和先验知识下，该配置更可能是正确的。</li></ul></li></ol><p><strong>结论</strong></p><p>通过最大化后验概率<span class="math inline">\(P(X, L |Z)\)</span>，我们找到一组 (X) 和 (L)，使得在已有的观测 (Z)和可能的先验知识下，这组配置是最有可能的。这就是如何使用联合概率模型来优化并解释机器人的导航和地图构建问题。这种方法使得可以在不确定的环境中做出最好的估计和决策。</p><h3 id="为什么用联合概率密度来描述导航问题">为什么用联合概率密度来描述导航问题</h3><p>在导航和其他机器人感知系统中，状态估计问题经常涉及位置（X），地图（L）和观测数据（Z）的不确定性。利用联合概率密度函数来表示这些变量，可以系统地包含所有相关的不确定性和依赖关系，从而使得可以进行精确的推断和决策。以下是详细解释为什么采用这种表示方法：</p><p>在导航问题中：</p><ul><li><strong>X</strong>表示机器人的位置状态序列，即在不同时间点的位置状态。</li><li><strong>L</strong> 表示环境的地图，包括可能的地标或其他特征。</li><li><strong>Z</strong>表示机器人的观测数据序列，即机器人通过其传感器相对于环境特征的观测。</li></ul><p><strong>概率模型表示</strong></p><ol type="1"><li><p><strong>初始状态的概率</strong>(P(x_0))：这是机器人在开始导航前的位置状态的初始概率分布。这通常是基于先验知识或初始观测所给定的。</p></li><li><p><strong>状态转移概率</strong> (<em>{i=1}^M P(x_i|x</em>{i-1},u_i))：这一部分表示机器人位置的演化，其中每个状态 (x_i) 取决于前一个状态(x_{i-1}) 和执行的控制指令(u_i)。状态转移概率捕捉了系统动态和可能的过程噪声。</p></li><li><p><strong>观测模型</strong> (<em>{k=1}^K P(z_k|x</em>{i_k},l_{j_k}))：每个观测 (z_k) 都依赖于特定时刻 (i_k) 的位置 (x_{i_k})和相关联的地图特征(l_{j_k})。观测模型描述了如何根据机器人的当前位置和周围环境的地标特征产生观测数据，包括观测噪声。</p></li></ol><p><strong>联合概率密度函数的优势</strong></p><p>使用联合概率密度函数 (P(X, L, Z)) 的优势在于：</p><ul><li><strong>全面性</strong>：通过整合所有可能的不确定性来源（控制输入的不确定性、位置的不确定性和观测的不确定性），这种方法提供了一个全面的系统描述。</li><li><strong>条件依赖性的显式表达</strong>：明确表达了各状态和观测之间的条件依赖关系，这对于理解和实现滤波器和估计算法至关重要。</li><li><strong>灵活性</strong>：这种表示允许使用各种概率推断技术，如卡尔曼滤波、粒子滤波或图优化，来估计位置和地图。</li><li><strong>信息整合</strong>：可以有效地整合多时刻和多来源的信息，优化状态估计和地图构建。</li></ul><p>总之，联合概率密度函数通过对所有变量的依赖关系进行建模，为解决导航中的状态估计问题提供了一个强大的数学框架，使得可以利用概率方法处理不确定性和推导最优解。这种方法是解决SLAM问题的基石，也是现代自动驾驶和机器人导航系统中不可或缺的一部分。</p><p>再尝试用一个更简单和直观的方式来理解为什么在导航中的状态估计问题可以通过一个联合概率密度函数来表示。我们可以通过具体的例子和逐步解析来帮助理解。</p><p><strong>一个具体的例子</strong></p><p>假设我们有一个机器人在一个未知的环境中导航。机器人的任务是理解自己的位置（状态X），探索并绘制周围的地图（L），同时根据自己的传感器收集信息（观测Z）。</p><ol type="1"><li><strong>初始状态 (P(x_0))</strong>:<ul><li>在一开始，我们只知道机器人可能在一个初始位置，比如我们可以假设它以某个概率分布（如高斯分布）位于起点附近。</li></ul></li><li><strong>状态转移 (P(x_i|x_{i-1}, u_i))</strong>:<ul><li>每次机器人移动，它的新位置 (x_i) 将基于前一个位置 (x_{i-1})和其执行的移动指令(u_i)（比如向前移动一米）。这个过程不是完全准确的，因此我们使用概率模型（如另一个高斯分布）来表示可能的新位置。</li></ul></li><li><strong>观测模型 (P(z_k|x_{i_k}, l_{j_k}))</strong>:<ul><li>同时，机器人会使用传感器（如摄像头或激光雷达）观测周围环境。这些观测(z_k) 取决于机器人的当前位置 (x_{i_k}) 和它所观测到的环境特征(l_{j_k})（比如附近的一个门或窗户）。观测也不是完全精确的，同样用概率模型来描述。</li></ul></li></ol><p><strong>为什么使用联合概率密度函数</strong></p><p>当我们想要同时考虑所有这些因素来估计机器人的最可能的位置、绘制地图和解释观测数据时，我们可以构造一个联合概率模型(P(X, L, Z))：</p><ul><li><strong>综合所有信息</strong>：这个联合模型把所有关于机器人位置的不确定性、地图的不确定性和观测数据的不确定性都整合在一起。我们通过计算这个联合概率来寻找最有可能解释所有观测数据和已知信息的位置和地图配置。</li><li><strong>条件依赖关系</strong>：这个模型同时还能清晰地表达各种条件依赖关系，例如观测依赖于位置和地图的某些特定特征，位置的更新依赖于先前的位置和移动指令。</li><li><strong>灵活的推断和优化</strong>：有了这个联合模型，我们可以利用不同的数学工具和算法（如贝叶斯滤波器、粒子滤波、最大似然估计等）来推断未知的状态和地图。</li></ul><p>总结来说，这个联合概率密度函数提供了一种全面并且系统的方法来考虑和处理导航问题中的所有不确定性和依赖性。这种方法使得可以更有效地进行状态估计和环境映射，帮助机器人更好地理解和操作在其所处的环境中。</p><h3 id="因子图通过将测量值作为已知的参数而不是变量来简化问题表示">因子图通过将测量值作为已知的参数而不是变量来简化问题表示？</h3><p>因子图通过将测量值作为已知的参数而不是变量来简化问题表示，使得模型更直接地关联到优化问题本身，这对于高效解决SLAM等复杂问题至关重要。这段话怎么理解？通过将测量值作为已知的参数而不是变量来简化问题表示？</p><p>这段话指出因子图在处理如SLAM这样的问题时的一个关键特性：将测量数据视为已知参数，而不是作为需要求解的变量。这种处理方式在建模和求解复杂系统时有几个重要的好处：</p><p><strong>简化问题表示</strong></p><ol type="1"><li><p><strong>明确角色分配</strong>：在SLAM等问题中，我们的主要目标是推断或优化未知的状态变量（如机器人的位置、地图的特征点等），而测量数据（如来自传感器的读数）是用来帮助确定这些未知变量的。将测量值视为已知参数，意味着这些数据在模型中的角色是辅助性的，它们用于构建关于未知变量的条件概率表达，而不是自身需要被解决的问题。</p></li><li><p><strong>减少求解复杂度</strong>：如果将测量值也视为变量，那么问题的复杂度会显著增加，因为这样不仅需要推断未知的状态变量，还要同时解决这些测量值的准确性和可靠性问题。将测量值作为参数，可以直接使用这些数据来形成对未知变量的概率描述，从而简化了模型和计算。</p></li></ol><p><strong>直接关联到优化问题本身</strong></p><ol type="1"><li><p><strong>更加聚焦核心任务</strong>：在SLAM等应用中，核心任务是基于测量数据推断或更新未知的状态变量。将测量数据视为参数，可以使模型更加集中于如何利用这些数据来改善对未知变量的估计，而非分散注意力于处理测量数据本身的不确定性。</p></li><li><p><strong>提高算法效率</strong>：当模型聚焦于核心变量时，优化算法可以更有效地调整和优化这些变量的值以达到最佳估计。这通常会导致更快的计算速度和更好的优化性能，因为算法可以直接利用固定的、已知的测量数据来逐步改进状态估计。</p></li></ol><p>总之，将测量值作为已知参数处理，有助于因子图更加高效和直接地应对复杂的优化问题，如SLAM，这样做能够减轻计算负担，同时提高问题求解的准确性和效率。这种方法使得模型设计和算法实现都更加直接和实用，特别是在实时或资源受限的应用场景中。</p></j}\psi_{ij}(\theta_i,\theta_j)>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 因子图理论 </tag>
            
            <tag> SAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>因子图优化相关问题</title>
      <link href="/2024/05/04/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/04/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="因子图优化相关问题">因子图优化相关问题</h1><blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>这篇blog主要是记录毕设一些因子图相关的问题不太好手动理解的点 主要途径就是通过看论文 还有gpt搜集到的一些理解的东西记录一下</p></blockquote><h2 id="为什么用联合概率密度来描述导航问题">为什么用联合概率密度来描述导航问题</h2><h3 id="解释1">解释1</h3><p>在导航和其他机器人感知系统中，状态估计问题经常涉及位置X，地图L和观测数据Z的不确定性。<strong>利用联合概率密度函数来表示这些变量，可以系统地包含所有相关的不确定性和依赖关系，从而使得可以进行精确的推断和决策。</strong>以下是详细解释为什么采用这种表示方法：</p><p>在导航问题中：</p><ul><li><strong>X</strong>表示机器人的位置状态序列，即在不同时间点的位置状态。</li><li><strong>L</strong> 表示环境的地图，包括可能的地标或其他特征。</li><li><strong>Z</strong>表示机器人的观测数据序列，即机器人通过其传感器相对于环境特征的观测。</li></ul><p><strong>概率模型表示</strong></p><ol type="1"><li><strong>初始状态的概率</strong> <span class="math inline">\(P(x_0)\)</span>：这是机器人在开始导航前的位置状态的初始概率分布。这通常是基于先验知识或初始观测所给定的。</li><li><strong>状态转移概率</strong> <span class="math inline">\(\prod_{i=1}^M P(x_i|x_{i-1}, u_i)\)</span>：这一部分表示机器人位置的演化，其中每个状态 <span class="math inline">\(x_i\)</span> 取决于前一个状态 <span class="math inline">\(x_{i-1}\)</span> 和执行的控制指令 <span class="math inline">\(u_i\)</span>。<strong>状态转移概率捕捉了系统动态和可能的过程噪声</strong>。</li><li><strong>观测模型</strong> <span class="math inline">\(\prod_{k=1}^KP(z_k|x_{i_k}, l_{j_k})\)</span>：每个观测 <span class="math inline">\(z_k\)</span> 都依赖于特定时刻 <span class="math inline">\(i_k\)</span>的位置 $x_{i_k} $ 和相关联的地图特征<span class="math inline">\(l_{j_k}\)</span>。<strong>观测模型描述了如何根据机器人的当前位置和周围环境的地标特征产生观测数据，包括观测噪声。</strong></li></ol><p><strong>联合概率密度函数的优势</strong></p><p>使用联合概率密度函数 $P(X, L, Z) $ 的优势在于：</p><ul><li><strong>全面性</strong>：通过整合所有可能的不确定性来源（控制输入的不确定性、位置的不确定性和观测的不确定性），这种方法提供了一个全面的系统描述。</li><li><strong>条件依赖性的显式表达</strong>：明确表达了各状态和观测之间的条件依赖关系，这对于理解和实现滤波器和估计算法至关重要。</li><li><strong>灵活性</strong>：这种表示允许使用各种概率推断技术，如卡尔曼滤波、粒子滤波或图优化，来估计位置和地图。</li><li><strong>信息整合</strong>：可以有效地整合多时刻和多来源的信息，优化状态估计和地图构建。</li></ul><p>总之，联合概率密度函数通过对所有变量的依赖关系进行建模，为解决导航中的状态估计问题提供了一个强大的数学框架，使得可以利用概率方法处理不确定性和推导最优解。这种方法是解决SLAM问题的基石，也是现代自动驾驶和机器人导航系统中不可或缺的一部分。</p><p><strong>一个具体的例子</strong></p><p>再尝试用一个更简单和直观的方式来理解为什么在导航中的状态估计问题可以通过一个联合概率密度函数来表示。我们可以通过具体的例子和逐步解析来帮助理解。</p><p>假设我们有一个机器人在一个未知的环境中导航。机器人的任务是理解自己的位置（状态X），探索并绘制周围的地图（L），同时根据自己的传感器收集信息（观测Z）。</p><ol type="1"><li><strong>初始状态<span class="math inline">\(P(x_0)\)</span></strong>:<ul><li>在一开始，我们只知道机器人可能在一个初始位置，比如我们可以假设它以某个概率分布（如高斯分布）位于起点附近。</li></ul></li><li><strong>状态转移<span class="math inline">\(P(x_i|x_{i-1},u_i)\)</span></strong>:<ul><li>每次机器人移动，它的新位置<span class="math inline">\(x_i\)</span>将基于前一个位置 <span class="math inline">\(x_{i-1}\)</span>和其执行的移动指令<span class="math inline">\(u_i\)</span>（比如向前移动一米）。这个过程不是完全准确的，因此我们使用概率模型（如另一个高斯分布）来表示可能的新位置。</li></ul></li><li><strong>观测模型 <span class="math inline">\(P(z_k|x_{i_k},l_{j_k})\)</span></strong>:<ul><li>同时，机器人会使用传感器（如摄像头或激光雷达）观测周围环境。这些观测<span class="math inline">\(z_k\)</span>取决于机器人的当前位置 <span class="math inline">\(x\)</span>和它所观测到的环境特征<span class="math inline">\(l_{j_k}\)</span>（比如附近的一个门或窗户）。观测也不是完全精确的，同样用概率模型来描述。</li></ul></li></ol><h3 id="解释2"><strong>解释2</strong></h3><p>当我们想要同时考虑所有这些因素来估计机器人的最可能的位置、绘制地图和解释观测数据时，我们可以构造一个联合概率模型<span class="math inline">\(P(X, L, Z)\)</span>：</p><ul><li><strong>综合所有信息</strong>：这个<strong>联合模型把所有关于机器人位置的不确定性、地图的不确定性和观测数据的不确定性都整合在一起</strong>。我们通过<strong>计算这个联合概率来寻找最有可能解释所有观测数据和已知信息的位置和地图配置</strong>。</li><li><strong>条件依赖关系</strong>：这个模型同时还能清晰地表达各种条件依赖关系，例如观测依赖于位置和地图的某些特定特征，位置的更新依赖于先前的位置和移动指令。</li><li><strong>灵活的推断和优化</strong>：有了这个联合模型，我们可以利用不同的数学工具和算法（如贝叶斯滤波器、粒子滤波、最大似然估计等）来推断未知的状态和地图。</li></ul><p>总结来说，这个<strong>联合概率密度函数提供了一种全面并且系统的方法来考虑和处理导航问题中的所有不确定性和依赖性</strong>。这种方法使得可以更有效地进行状态估计和环境映射，帮助机器人更好地理解和操作在其所处的环境中。</p><h2 id="如何根据联合概率密度分布-求解">如何根据联合概率密度分布求解</h2><p>在解决导航和地图构建的问题中，目标通常是找到一组变量（机器人的位置和地图配置）的配置，<strong>这些配置最能解释观测数据和已知信息。</strong>这里的“解释”通常是指在给定模型下，找到最大化联合概率<span class="math inline">\(P(X, L, Z)\)</span> 的 <span class="math inline">\(X\)</span>（位置）和<span class="math inline">\(L\)</span>（地图）的配置。这种方法是基于最大似然估计或最大后验估计的原理。</p><p><strong>最大似然估计和最大后验估计</strong></p><ul><li><p><strong>最大似然估计（MLE）</strong>:在这种情况下，我们寻找的是最大化观测数据 (Z) 出现概率的位置<span class="math inline">\(X\)</span> 和地图<span class="math inline">\(L\)</span>配置，不考虑位置和地图的先验概率。数学上表达为 <span class="math inline">\(\arg\max_{X, L} P(Z|X, L)\)</span>。</p></li><li><p><strong>最大后验估计（MAP）</strong>:更常见的是，我们寻找能够最大化后验概率<span class="math inline">\(P(X, L| Z)\)</span>的 <span class="math inline">\(X\)</span> 和<span class="math inline">\(L\)</span>。由于根据贝叶斯公式，<span class="math inline">\(P(X, L | Z) \propto P(Z | X, L) P(X,L)\)</span>，这不仅考虑了观测数据的似然度，还包括了关于位置和地图的先验知识。</p></li></ul><p><strong>计算过程</strong></p><ol type="1"><li><strong>定义概率模型</strong>:<ul><li>状态转移概率 <span class="math inline">\(P(x_i | x_{i-1},u_i)\)</span>描述了给定前一状态和控制输入后，当前状态的概率。</li><li>观测模型 <span class="math inline">\(P(z_k | x_{i_k},l_{j_k})\)</span>描述了给定当前状态和地图配置时，观测数据出现的概率。</li><li>先验<span class="math inline">\(P(X,L)\)</span>可能基于以前的知识或假设（如位置的均匀分布，或地图的某些特征）。</li></ul></li><li><strong>优化过程</strong>:<ul><li>在实践中，最大化<span class="math inline">\(P(X, L | Z)\)</span>通常涉及到优化算法，如梯度上升、期望最大化（EM）算法或其他非线性优化技术。</li><li>在机器人技术中，常见的优化工具包括粒子滤波（用于非线性/非高斯问题）和卡尔曼滤波（用于线性/高斯问题）。</li></ul></li><li><strong>联合概率和解释</strong>:<ul><li>我们不是寻找最小的联合概率，而是寻找最大化后验概率的 <span class="math inline">\(X,L\)</span>配置，因为后验概率高意味着给定观测数据和先验知识下，该配置更可能是正确的。</li></ul></li></ol><p>通过最大化后验概率<span class="math inline">\(P(X, L |Z)\)</span>，我<strong>们找到一组X和L，使得在已有的观测Z和可能的先验知识下，这组配置是最有可能的</strong>。这就是<strong>如何使用联合概率模型来优化并解释机器人的导航和地图构建问题</strong>。这种方法使得可以在不确定的环境中做出最好的估计和决策。</p><h2 id="关于概率推导">关于概率推导</h2><p>导航定位系统状态量的最大后验估计问题可以转换为在已知系统观测信息的前提下，求解最大化系统的状态信息的概率密度。如式所示: <span class="math display">\[X^{MAP}=\arg\max_Xp(X_m\mid Z_j)=\arg\max_X\frac{p(Z_j\midX_m)p(X_m)}{p(Z_j)}\]</span> 由于观测的数据<span class="math inline">\(Z_j\)</span>是已知的，且与待估计的状态是独立的，于是有：​<span class="math display">\[p(X_m\mid Z_j)\propto p(Z_j\mid X_m)p(X_m)\\X^{MAP}=\arg\max_Xp(Z_j\midX_m)p(X_m)\]</span></p><h3 id="在给定系统状态的情况下每个观测数据是独立的-为什么观测模型还依赖于系统状态">在给定系统状态的情况下，每个观测数据是独立的。为什么观测模型还依赖于系统状态？</h3><h4 id="解释1-1">解释1</h4><p>在给定系统状态的情况下，每个观测数据是独立的，这意味着每个观测数据<span class="math inline">\(z_k\)</span>的生成不受其他观测数据的影响。但是，观测数据和系统状态之间仍然可能存在依赖关系，这种依赖关系通常由观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>来描述。</p><p>观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>表示系统状态<span class="math inline">\(x_{i_k}\)</span>到观测数据<span class="math inline">\(z_k\)</span>之间的映射关系。即使在给定系统状态的情况下，不同的系统状态可能会导致不同的观测数据。这种依赖关系可以是物理上的，也可以是统计上的。例如，在一个移动机器人的定位问题中，机器人的位置状态会影响传感器测量值的期望值，即观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>。即使在给定机器人位置的情况下，由于传感器的测量误差，不同的位置状态也会导致不同的观测数据。</p><p>因此，虽然在给定系统状态的情况下，每个观测数据是独立的，但观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>仍然依赖于系统状态，因为观测数据的生成过程与系统状态之间可能存在依赖关系。</p><h4 id="解释2-1">解释2</h4><p>在给定观测数据<span class="math inline">\(z\)</span>的情况下，观测模型的确不应该直接依赖于系统状态<span class="math inline">\(x\)</span>，因为观测数据<span class="math inline">\(z\)</span>已经被视为已知值，与系统状态无关。</p><p>在导航定位系统中，观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>通常描述了系统状态<span class="math inline">\(x_{i_k}\)</span>到观测数据<span class="math inline">\(z_k\)</span>之间的映射关系。这个映射关系可以是物理上的，例如，通过测量信号强度来估计距离，或者是统计上的，例如，通过回归模型来预测观测数据的期望值。</p><p>然而，当我们使用高斯分布来表示观测数据<span class="math inline">\(z_k\)</span>在给定状态<span class="math inline">\(x_{i_k}\)</span>下的条件概率时，我们需要考虑观测模型和观测噪声。这里的高斯分布是一个常用的假设，用于表示观测数据的不确定性，其中噪声项<span class="math inline">\(\nu_k\)</span>通常被假设为零均值的高斯分布。</p><p>因此，虽然在给定观测数据<span class="math inline">\(z\)</span>的情况下，观测模型不应该直接依赖于系统状态<span class="math inline">\(x\)</span>，但在贝叶斯推断中，我们可能仍然需要考虑观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>的形式，以便通过高斯分布来表示观测数据的条件概率分布。然而，需要注意的是，高斯分布中的参数应该是与系统状态无关的，因为在给定观测数据的情况下，观测模型不应该依赖于系统状态。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>具体的例子</p><p>当处理导航定位系统时，一个常见的观测是通过GPS接收器收集到的位置数据。在这种情况下，我们可以将观测模型视为将系统状态（例如，实际位置）映射到观测数据（例如，GPS接收器报告的位置）的函数。</p><p>假设我们想要估计一个移动机器人的位置。机器人当前的真实位置是系统的状态，我们用<span class="math inline">\(x_i\)</span>表示。而机器人所收集到的GPS数据就是观测数据，用<span class="math inline">\(z_i\)</span>表示。GPS数据可能会受到多种因素的影响，例如大气干扰、多径效应等，因此我们会有一个观测噪声的模型。</p><p>假设我们的观测模型是一个简单的线性模型，即：</p><p><span class="math display">\[z_i = x_i + \nu_i\]</span></p><p>其中，<span class="math inline">\(\nu_i\)</span>是观测噪声，表示GPS测量的误差。</p><p>在这个例子中，观测模型<span class="math inline">\(h(x_i)\)</span>是直接将系统状态<span class="math inline">\(x_i\)</span>映射到观测数据<span class="math inline">\(z_i\)</span>上，这是一个物理上的映射关系。但是，为了考虑观测噪声的影响，我们可能会假设<span class="math inline">\(\nu_i\)</span>是一个零均值的高斯随机变量。</p><p>因此，我们可以使用高斯分布来描述观测数据<span class="math inline">\(z_i\)</span>在给定状态<span class="math inline">\(x_i\)</span>下的条件概率分布，即：</p><p><span class="math display">\[p(z_i \mid x_i) \propto \exp \left(-\frac{1}{2\sigma^2} \|z_i - x_i\|^2 \right)\]</span></p><p>其中，<span class="math inline">\(\sigma^2\)</span>是观测噪声的方差，<span class="math inline">\(\|.\|\)</span>表示向量的范数。</p><p>需要注意的是，在这个例子中，虽然我们使用了一个与系统状态<span class="math inline">\(x_i\)</span>相关的观测模型<span class="math inline">\(h(x_i)\)</span>，但是在贝叶斯推断中，我们最终要估计的是系统状态<span class="math inline">\(x_i\)</span>的后验分布<span class="math inline">\(p(x_i \mid z_i)\)</span>，而不是观测模型<span class="math inline">\(h(x_i)\)</span>本身。因此，我们仍然可以利用贝叶斯定理来计算后验分布，如前面提到的那样。</p><h2 id="关于残差">关于残差</h2><p>残差不仅仅反映了异常值的存在，它还反映了模型预测值与实际观测值之间的差异，包括了模型未能完全解释的部分以及数据中的随机噪声。</p><p>在统计学和机器学习中，<strong>残差通常被定义为观测值与模型的预测值之间的差异</strong>。如果我们的模型能够很好地拟合数据，那么残差应该是很小的。然而，<strong>当数据中存在异常值或者模型不够准确时，残差可能会变得较大，因为观测值与模型的预测值之间的差异会增大。</strong></p><p>因此，残差不仅反映了异常值的存在，还反映了其他因素导致的预测误差。但是，由于异常值往往会导致较大的残差，因此在一定程度上残差可以用来间接地检测异常值的存在。</p><p>当我们使用鲁棒核函数时，对于较大的残差会施加较小的权重，使得异常值的影响降低，从而更有可能得到更好的优化结果。因此，虽然残差不仅仅反映了异常值的存在，但异常值对于残差的贡献往往是较大的，因此对异常值施加较小的权重可以减小它们对优化过程的影响。</p><h2 id="关于鲁棒核函数">关于鲁棒核函数</h2><p>对于常规的最小二乘法，异常值的存在会对优化结果产生较大的影响，因为它们对残差的贡献很大，导致最小二乘法过度拟合这些异常值。这<strong>是因为最小二乘法对所有的残差都施加相同的惩罚，而对于异常值来说，它们的残差通常会比较大。</strong></p><p>相比之下，鲁棒核函数（如Huber损失函数）会在残差较小的时候施加较小的惩罚，而在残差较大的时候施加较大的惩罚。这使得鲁棒核函数能够更好地适应数据中的异常值，并且对异常值的影响较小。因此，当使用鲁棒核函数进行优化时，异常值不会对优化过程产生过大的影响，从而使得优化结果更加稳健。</p><p>总的来说，使用鲁棒核函数能够减少异常值对优化过程的影响，使得优化结果更具有鲁棒性，更能反映数据的真实情况。</p><h3 id="为什么残差可以体现异常值">为什么残差可以体现异常值</h3><p>残差对于异常值的影响在于它们对误差的贡献程度。在最小二乘法中，所有残差都会以相同的权重参与到优化过程中，这意味着即使存在异常值，它们也会对最终拟合结果产生显著影响，因为异常值通常会导致较大的残差。</p><p>然而，当使用鲁棒核函数（如Huber损失函数）时，对于较小的残差，它们只会受到较小的惩罚，而对于较大的残差，它们会受到更大的惩罚。这样的设计使得鲁棒核函数能够更好地适应异常值的存在，因为异常值通常会导致较大的残差。因此，使用鲁棒核函数时，异常值的影响会被减弱，从而使得优化过程更加稳健，并且更能够反映数据的真实情况。</p><p>总的来说，鲁棒核函数通过调整对残差的惩罚来减少异常值对优化过程的影响，从而使得优化结果更具有鲁棒性。</p><p>残差是指观测值与拟合值之间的差异，它们在统计学和优化问题中经常被使用。在回归或拟合问题中，残差可以看作是模型未能解释的部分，包括了模型无法捕捉到的数据的波动性或噪声。当数据中存在异常值时，这些异常值往往会导致较大的残差，因为它们与模型的预期值相差较大。</p><p>因此，残差的大小和分布可以在一定程度上反映数据中的异常值。当数据中存在异常值时，通常会观察到较大的残差值，因为异常值与其他数据点的差异较大。这使得残差成为了一种检测异常值的方式，因为异常值通常会导致残差的偏离。</p><p>在统计建模和优化问题中，我们通常会对残差进行分析和处理，以便更好地理解数据的特征并提高模型的拟合效果。例如，在回归分析中，我们可以检查残差的分布是否满足模型假设，并根据需要调整模型。在优化问题中，我们可以使用残差来评估优化算法的效果，并进一步改进算法，以使残差逐渐减小。</p><p>因此，残差在一定程度上可以反映异常值的存在和影响，它们是在统计建模和优化问题中常用的工具，用于识别和处理数据中的异常情况。</p><h3 id="什么是残差较大的时候-施加较大的惩罚">什么是残差较大的时候施加较大的惩罚</h3><p>当我们说在残差较大的时候施加较大的惩罚时，意味着在优化过程中对于较大的残差值，我们会给予更大的权重或惩罚，以使得这些较大的残差不会对优化结果产生过大的影响。这样的做法可以减少异常值对优化过程的影响，使得优化结果更加鲁棒。</p><p>让我们通过一个简单的线性回归的例子来说明这个概念。假设我们有一组数据<span class="math inline">\((x_i, y_i)\)</span>，我们想要用线性模型<span class="math inline">\(y = mx + b\)</span>来拟合这些数据。然而，数据中存在一些异常值，这些异常值可能会导致较大的残差。在普通的最小二乘法中，我们会平方残差并求和，以最小化这些残差的平方和，即最小化目标函数：</p><p><span class="math display">\[\text{minimize } \sum_i (y_i - (mx_i +b))^2\]</span></p><p>然而，当存在异常值时，它们会导致较大的残差，从而对最小二乘法产生较大的影响。为了降低异常值的影响，我们可以使用Huber损失函数来代替平方损失，它在残差较小的情况下类似于平方损失，而在残差较大的情况下则类似于绝对值损失。这样的损失函数将对较大的残差施加较大的惩罚，从而减小了异常值对优化结果的影响。</p><p>Huber损失函数的形式如下：</p><p><span class="math display">\[L(r) =\begin{cases}\frac{1}{2} r^2, &amp; \text{if } |r| \leq \delta \\\delta (|r| - \frac{1}{2}\delta), &amp; \text{if } |r| &gt; \delta\end{cases}\]</span></p><p>其中，<span class="math inline">\(r\)</span>表示残差，<span class="math inline">\(\delta\)</span>是一个阈值参数，用于控制在何种范围内将损失函数视为二次型。当残差小于等于<span class="math inline">\(\delta\)</span>时，损失函数是一个平方函数，而当残差大于<span class="math inline">\(\delta\)</span>时，损失函数是一个线性函数。这样的设计使得在优化过程中对于较大的残差会施加较大的惩罚，从而减少了异常值对优化结果的影响。</p><h3 id="什么是较大的惩罚">什么是较大的惩罚</h3><p>让我进一步解释一下“受到较大的惩罚”是什么意思。</p><p>在优化问题中，我们通常会定义一个损失函数，用于衡量模型的拟合程度。这个损失函数越小，表示模型对数据的拟合越好。当我们使用不同的损失函数时，对于相同的残差，损失函数可能会对其赋予不同的重要性或权重。</p><p>举个简单的例子，假设我们使用平方损失函数：</p><p><span class="math display">\[L(r) = r^2\]</span> 在这种情况下，不论残差<span class="math inline">\(r\)</span>的大小如何，损失函数都会将其平方作为损失。因此，对于较大的残差，损失函数会将其平方的值作为较大的损失，而对于较小的残差，损失函数会将其平方的值作为较小的损失。</p><p>而当我们使用Huber损失函数时，对于较小的残差，损失函数是一个二次函数，因此对其赋予较小的权重；而对于较大的残差，损失函数是一个线性函数，因此对其赋予较大的权重。换句话说，Huber损失函数对于较大的残差会施加较大的惩罚，而对于较小的残差则施加较小的惩罚。</p><p>所以，当我们说“受到较大的惩罚”时，意味着对于那些导致较大残差的数据点，它们在优化过程中会被赋予较大的权重，以使得模型更加关注这些异常值，并尽可能减少它们对模型参数的影响。</p><hr><h3 id="herb比较好的例子"><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>比较好的例子​！！</h3><p>理解这个问题的关键在于理解异常值对于损失函数的影响。在传统的最小二乘法中，异常值的存在可能会导致较大的残差，从而对整个损失函数产生较大的影响。这意味着优化过程会受到异常值的干扰，可能会导致无法收敛到最优解，或者收敛到一个不够准确的解。</p><p>而使用鲁棒核函数时，对于较大的残差，它们会受到较小的权重，即较小的惩罚。这意味着异常值的存在不会对损失函数产生过大的影响，因为它们对于整体损失函数的贡献较小。相比之下，对于传统的最小二乘法来说，异常值的残差较大，导致损失函数的值被显著地增加。</p><p>通过减少异常值的影响，优化过程更有可能收敛到更好的解。<strong>这是因为优化过程可以更专注于拟合那些正常的、代表性的数据点，而不会被少数异常值所主导。</strong>这种机制使得优化过程更加稳健，能够更可靠地找到对数据拟合更好的解。</p><p>总的来说，通过对异常值施加较小的权重，可以减小它们对损失函数的影响，从而使得优化过程更有可能收敛到更好的解。</p><h3 id="具体数值的例子">具体数值的例子</h3><p>当我们使用最小二乘法时，我们通常会最小化残差的平方和，即： <span class="math display">\[\sum_{k=1}^n \|h_k(x_{i_k}) - z_k\|^2\]</span> 在这个公式中，<span class="math inline">\(h_k(x_{i_k})\)</span> 是模型对观测数据 <span class="math inline">\(z_k\)</span> 的预测值，<span class="math inline">\(x_{i_k}\)</span>是系统状态。这个公式中的每个残差都会被平方，并等权重地加总起来。</p><p>假设我们有一组观测数据和模型如下：</p><ul><li>观测数据：<span class="math inline">\(z_1 = 10\)</span>, <span class="math inline">\(z_2 = 12\)</span>, <span class="math inline">\(z_3= 8\)</span></li><li>模型预测值：<span class="math inline">\(h(x) = x\)</span></li></ul><p>如果我们使用最小二乘法，那么我们的优化目标就是最小化残差的平方和：</p><p><span class="math display">\[\text{目标：} \min_{x} \left( (x - 10)^2 + (x - 12)^2 + (x - 8)^2\right)\]</span> 假设我们初始时取 <span class="math inline">\(x =0\)</span>。计算残差的平方和为： <span class="math display">\[(0 - 10)^2 + (0 - 12)^2 + (0 - 8)^2 = 100 + 144 + 64 = 308\]</span> 然后我们使用优化算法来尝试减小这个值。</p><p>但如果我们知道在数据中有一些异常值，比如一个 <span class="math inline">\(z_2 =100\)</span>，这个数远远超出了其他数据的范围。在这种情况下，传统的最小二乘法会对这个异常值产生较大的影响。</p><p>现在我们尝试使用Huber损失函数，它对较大的残差施加较小的权重。Huber损失函数的形式如下：</p><p><span class="math display">\[L(r) =\begin{cases}\frac{1}{2} r^2, &amp; \text{if } |r| \leq \delta \\\delta (|r| - \frac{1}{2}\delta), &amp; \text{if } |r| &gt; \delta\end{cases}\]</span> 假设我们选择 <span class="math inline">\(\delta =2\)</span>。那么在计算损失函数时，对于较小的残差，我们会使用残差的平方，而对于较大的残差，我们会使用一个线性函数。所以，对于较大的残差，Huber损失函数的惩罚相对较小。</p><p>我们再次尝试用 <span class="math inline">\(x = 0\)</span>开始优化。计算Huber损失函数的值：</p><p><span class="math display">\[\text{目标：} \min_{x} \left( \frac{1}{2}(x - 10)^2 + \frac{1}{2}(x -12)^2 + \frac{1}{2}(x - 8)^2 \right)\]</span> 计算后的损失函数值为： <span class="math display">\[\frac{1}{2}(0 - 10)^2 + \frac{1}{2}(0 - 12)^2 + \frac{1}{2}(0 - 8)^2 =25 + 36 + 16 = 77\]</span>可以看出，相比于传统的最小二乘法，Huber损失函数对异常值的影响要小得多。因此，优化算法更有可能收敛到一个更接近于真实值的解。</p><h2 id="因子图为什么处理导航相关问题">因子图为什么处理导航相关问题</h2><ol type="1"><li><p><strong>局部测量与全局状态的关系</strong>：在GNSS/PDR系统中，我们需要整合来自GNSS的卫星信号数据和PDR系统（如加速度计、陀螺仪等）提供的内部传感器数据。<strong>这些数据与用户的全局位置和运动状态有直接关系</strong>。因子图允许我们将这些关系表达为局部函数，这些函数仅与某些变量相关联。</p></li><li><p><strong>联乘积形式的模型表示</strong>：在因子图中，全局函数（如位置和姿态的估计）可以被表示为多个局部函数的乘积。每个局部函数对应于一个特定的测量或状态变量的影响。例如，一个局部函数可能代表来自GNSS的位置测量，另一个局部函数可能代表来自步行检测算法的位移估计。这些局部函数的联乘积可以有效地融合来自不同源的数据，以优化全局状态的估计。</p></li></ol><h2 id="在因子图中各个因子对于执行如图搜索优化和推断等操作是非常有效的">在因子图中，各个因子对于执行如图搜索、优化和推断等操作是非常有效的？</h2><blockquote><p>在因子图中，各个因子直接关联到一组变量，并定义这些变量间的局部关系，这对于执行如图搜索、优化和推断等操作是非常有效的？</p></blockquote><p>这段话描述了因子图的核心特性：因子图是一种图形模型，用于表示变量之间的依赖关系。<strong>在因子图中，各个因子直接与一组变量相连，并且定义了这些变量之间的具体关系</strong>。这种结构对于图搜索、优化和推断等操作非常有效。以下是几个关键点来帮助理解这个概念：</p><h3 id="因子图的结构"><strong>因子图的结构</strong></h3><ol type="1"><li><strong>变量节点</strong>：表示问题中的各种变量（例如，在SLAM中的机器人位置或地图特征点）。</li><li><strong>因子节点</strong>：表示变量之间的具体关系或依赖，通常体现为概率函数或约束。这些因子定义了变量如何相互作用，例如，一个因子可能表示在给定机器人的某个位置时，预期的传感器测量与实际观察之间的关系。</li></ol><h3 id="执行图搜索优化和推断的效果"><strong>执行图搜索、优化和推断的效果</strong></h3><ol type="1"><li><p><strong>图搜索</strong>：因子图的结构使得可以有效地进行图搜索操作，例如寻找最可能的变量配置。<strong>因子图中的连接告诉搜索算法哪些变量是直接相互关联的，从而可以系统地探索这些变量的组合，寻找满足所有因子约束的最优解。</strong></p></li><li><p><strong>优化</strong>：在因子图中，优化通常涉及调整变量的值以最大化（或最小化）整体系统的某个性能指标（如概率总和或误差平方和）。因为<strong>因子直接定义了变量间的关系，优化算法可以直接利用这些局部关系，集中处理影响最大的部分，从而高效地改进解决方案。</strong></p></li><li><p><strong>推断</strong>：在概率模型中，推断通常意味着基于给定的数据和模型结构推测某些变量的状态。<strong>因子图提供了一种清晰的方式来利用局部信息（因子定义的局部概率关系）对全局状态（整个变量集的状态）进行推断。</strong>例如，给定某些变量的测量值，可以通过因子图推断其他未知变量的最可能值。</p></li></ol><h3 id="效率的原因"><strong>效率的原因</strong></h3><p>因子图将复杂的全局问题分解为多个简单的局部问题，每个局部问题都集中在一小组变量上。<strong>这种分解使得可以并行处理这些局部问题，或者专注于最关键的部分，从而大大提高了计算的效率</strong>。此外，因为因子定义了变量之间的确切关系，算法可以避免处理无关变量间的不必要计算，进一步优化性能。</p><p>因此，因子图是处理具有复杂依赖关系的优化和推断问题的一个非常强大和灵活的工具。</p><h2 id="因子图通过将测量值作为已知的参数而不是变量来简化问题表示">因子图通过将测量值作为已知的参数而不是变量来简化问题表示？</h2><p>因子图通过将测量值作为已知的参数而不是变量来简化问题表示，使得模型更直接地关联到优化问题本身，这对于高效解决SLAM等复杂问题至关重要。这段话怎么理解？通过将测量值作为已知的参数而不是变量来简化问题表示？</p><p>这段话指出因子图在处理如SLAM这样的问题时的一个关键特性：将测量数据视为已知参数，而不是作为需要求解的变量。这种处理方式在建模和求解复杂系统时有几个重要的好处：</p><p><strong>简化问题表示</strong></p><ol type="1"><li><p><strong>明确角色分配</strong>：在SLAM等问题中，我们的主要目标是推断或优化未知的状态变量（如机器人的位置、地图的特征点等），而测量数据（如来自传感器的读数）是用来帮助确定这些未知变量的。<strong>将测量值视为已知参数，意味着这些数据在模型中的角色是辅助性的，它们用于构建关于未知变量的条件概率表达，而不是自身需要被解决的问题</strong>。</p></li><li><p><strong>减少求解复杂度</strong>：如果将测量值也视为变量，那么问题的复杂度会显著增加，因为这样不仅需要推断未知的状态变量，还要同时解决这些测量值的准确性和可靠性问题。将测量值作为参数，可以直接使用这些数据来形成对未知变量的概率描述，从而简化了模型和计算。</p></li></ol><p><strong>直接关联到优化问题本身</strong></p><ol type="1"><li><p><strong>更加聚焦核心任务</strong>：在SLAM等应用中，核心任务是基于测量数据推断或更新未知的状态变量。<strong>将测量数据视为参数，可以使模型更加集中于如何利用这些数据来改善对未知变量的估计，而非分散注意力于处理测量数据本身的不确定性。</strong></p></li><li><p><strong>提高算法效率</strong>：当模型聚焦于核心变量时，优化算法可以更有效地调整和优化这些变量的值以达到最佳估计。这通常会导致更快的计算速度和更好的优化性能，因为算法可以直接利用固定的、已知的测量数据来逐步改进状态估计。</p></li></ol><p>总之，将测量值作为已知参数处理，有助于因子图更加高效和直接地应对复杂的优化问题，如SLAM，这样做能够减轻计算负担，同时提高问题求解的准确性和效率。这种方法使得模型设计和算法实现都更加直接和实用，特别是在实时或资源受限的应用场景中。</p><h2 id="因子图优化如何更新节点状态"><strong>因子图优化如何更新节点状态</strong></h2><p>让我们逐一探讨这两个问题：</p><p><strong>1. 根据导数信息计算状态更新量的例子</strong></p><p>考虑一个简单的SLAM问题，其中机器人需要确定它的位置x和地图上一个地标的位置l。假设有一个观测z与机器人的位置和地标之间的距离相关。</p><p><strong>步骤</strong></p><ul><li><p><strong>误差函数</strong>：设<span class="math inline">\(h(x,l)\)</span>是从机器人位置$ x $ 到地标 $l <span class="math inline">\(的预测测量，误差函数\)</span> e<span class="math inline">\(可表示为\)</span>e = z - h(x, l)$。</p></li><li><p><strong>雅可比矩阵</strong>：计算误差<span class="math inline">\(e\)</span>关于状态 $x <span class="math inline">\(和地标位置\)</span> l<span class="math inline">\(的雅可比矩阵\)</span>J_x <span class="math inline">\(和\)</span>J_l$。</p></li><li><p><strong>更新公式</strong>：使用高斯牛顿法，更新公式可以写作：</p></li></ul><p><span class="math display">\[\begin{pmatrix} \Delta x \\ \Delta l \end{pmatrix} = -(J^T J + \lambdaI)^{-1} J^T e\]</span></p><p>其中 ( J ) 是组合了<span class="math inline">\(J_x\)</span> 和$ J_l$的雅可比矩阵，$$是为了提高数值稳定性而添加的阻尼因子（Levenberg-Marquardt算法中使用）,I是单位矩阵。</p><ul><li><strong>状态更新</strong>：计算得到的$ x $ 和$l$用来更新当前状态和地标位置。</li></ul><p><strong>2. 增量式图优化方法的实际操作</strong></p><p>在实时系统如自动驾驶车辆中，<strong>增量图优化</strong>主要关注最近的观测和状态，以减少每次更新所需的计算资源。</p><p><strong>步骤</strong></p><ul><li><strong>局部图更新</strong>：每当接收到新的观测数据时，只更新与这些新数据直接相关的节点和边，这些通常是最近的机器人状态和相关地标。</li><li><strong>窗口优化</strong>：一种常见的策略是<strong>固定滑动窗口方法，即仅在固定大小的最近状态窗口内进行优化</strong>。较旧的状态和地标，一旦它们超出窗口，<strong>可以被边缘化（从优化问题中移除但考虑其对现有状态的统计影响）或锁定。</strong></li><li><strong>增量求解器</strong>：使用专门设计的<strong>增量求解器</strong>，如iSAM 或 g2o，这些工具能够有效地更新信息矩阵和求解增量更新问题。</li><li><strong>实时反馈</strong>：通过快速更新仅涉及局部改动的解决方案，系统能够快速地对新数据做出响应。</li></ul><p>这种增量更新方法能够显著降低因每个新观测而进行全局优化的计算成本，使系统更适合实时应用场景，如自动驾驶或动态环境中的机器人导航。</p><h2 id="因子图的迭代优化算法">因子图的迭代优化算法</h2><p>图优化的迭代优化通常涉及到通过逐步优化来调整和改进图中的节点估计（即状态变量），以最小化整个图中所有误差函数（因子）的总和。这个过程通常使用类似于高斯-牛顿或者LM算法的优化方法。</p><p><strong>图优化迭代过程</strong></p><ol type="1"><li><strong>初始化</strong>：<ul><li>节点的初始估计通常基于传感器的原始数据或某些先验知识。</li></ul></li><li><strong>构建误差函数</strong>：<ul><li>对于图中的每一个因子，构建一个误差函数，该函数衡量当前节点状态估计与观测数据之间的差异。</li></ul></li><li><strong>线性化误差函数</strong>：<ul><li>在当前估计点附近对误差函数进行线性化，通常是通过计算误差函数相对于每个节点状态的雅可比矩阵。</li></ul></li><li><strong>构建正规方程</strong>：<ul><li>将所有线性化的误差函数组合成一个大的系统方程。这通常表现为一个大的稀疏线性系统，可以写成<span class="math display">\[ H\delta = b \]</span> 的形式，其中 ( H )是信息矩阵（或海森矩阵），而 ( b ) 是基于误差的向量。</li></ul></li><li><strong>求解线性系统</strong>：<ul><li>使用直接求解器（如Cholesky分解）或迭代求解器（如共轭梯度法）来解决上述线性系统，以找到状态更新<span class="math inline">\(\delta\)</span>。</li></ul></li><li><strong>更新状态估计</strong>：<ul><li>将解得的<span class="math inline">\(\delta\)</span>应用到当前的状态估计中，更新所有节点的状态。</li></ul></li><li><strong>迭代和收敛检查</strong>：<ul><li>检查解的改进程度，如果未达到预设的收敛标准（如状态改变量的大小低于某个阈值或达到最大迭代次数），则重复步骤2-6。</li></ul></li><li><strong>最终优化结果</strong>：<ul><li>当迭代收敛时，当前的状态估计被认为是优化的解，即图中所有节点的最优估计。</li></ul></li></ol><p><strong>使用Levenberg-Marquardt方法的特别说明</strong></p><p>Levenberg-Marquardt算法是高斯-牛顿算法的一个变种，通过引入一个调整参数（阻尼因子）来平衡算法的迭代速度与稳定性。这个阻尼因子可以动态调整，以在必要时约束更新步长，从而提高收敛性和算法的鲁棒性。</p><h2 id="关于因子图的误差函数">关于因子图的误差函数</h2><h3 id="一个具体的例子">一个具体的例子</h3><p>在因子图中使用的每个因子都可以被看作是一个误差函数，它描述了给定状态变量下预期观测值与实际观测值之间的差异。雅可比矩阵是这些误差函数对于状态变量的一阶导数，用于在非线性优化过程中进行线性化。</p><h4 id="模型和误差函数">模型和误差函数</h4><p>以GNSS和PDR为例，我们可以具体定义状态变量和误差函数。</p><p>假设状态变量 <span class="math inline">\(\mathbf{x}_k\)</span> 在第<span class="math inline">\(k\)</span>时刻是一个包括位置和朝向的位姿，可以表示为一个二维平面上的姿态（位置<span class="math inline">\((x, y)\)</span> 和朝向 <span class="math inline">\(\theta\)</span>）： <span class="math display">\[\mathbf{x}_k = \begin{bmatrix} x_k \\ y_k \\ \theta_k \end{bmatrix}\]</span> GNSS观测模型</p><p>假设GNSS提供了位姿的绝对观测： <span class="math display">\[\mathbf{z}^{\text{GNSS}}_k = \begin{bmatrix} x^{\text{meas}}_k \\y^{\text{meas}}_k \\ \theta^{\text{meas}}_k \end{bmatrix}\]</span> 误差函数（GNSS因子）可以定义为： <span class="math display">\[\mathbf{e}^{\text{GNSS}}_k = \mathbf{z}^{\text{GNSS}}_k - \mathbf{x}_k\]</span></p><h4 id="pdr观测模型">PDR观测模型</h4><p>PDR通常提供相对于上一状态的位移和方向改变，假设步行产生的位移 <span class="math inline">\(\Delta d\)</span> 和方向变化 <span class="math inline">\(\Delta \theta\)</span>： <span class="math display">\[\mathbf{z}^{\text{PDR}}_k = \begin{bmatrix} \Delta d_k \\ \Delta\theta_k \end{bmatrix}\]</span> 相应的误差函数（PDR因子）可能是： <span class="math display">\[\mathbf{e}^{\text{PDR}}_k = \mathbf{x}_k - \left( \mathbf{x}_{k-1} +\begin{bmatrix} \Delta d_k \cos(\theta_{k-1}) \\ \Delta d_k\sin(\theta_{k-1}) \\ \Delta \theta_k \end{bmatrix} \right)\]</span></p><h4 id="雅可比矩阵计算">雅可比矩阵计算</h4><p>雅可比矩阵是误差函数相对于状态变量的偏导数。以PDR误差函数为例，其雅可比矩阵相对于状态<span class="math inline">\(\mathbf{x}_k\)</span> 的导数为：</p><p><span class="math display">\[J_{\mathbf{x}_k}^{\text{PDR}} = \frac{\partial\mathbf{e}^{\text{PDR}}_k}{\partial \mathbf{x}_k} = \begin{bmatrix}1 &amp; 0 &amp; -\Delta d_k \sin(\theta_{k-1}) \\0 &amp; 1 &amp; \Delta d_k \cos(\theta_{k-1}) \\0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>这里，偏导数是通过微分 <span class="math inline">\(\mathbf{x}_k\)</span> 和 <span class="math inline">\(\mathbf{x}_{k-1}\)</span> 相关的表达式得到的。</p><h4 id="gtsam中的实现">GTSAM中的实现</h4><p>在GTSAM这样的库中，用户只需定义状态变量、误差函数和噪声模型。库内部负责计算雅可比矩阵并进行优化。在每次迭代中，基于当前的估计值，库会自动对误差函数进行线性化，计算雅可比矩阵，并更新状态估计。</p><p>在GTSAM中，可以通过自定义因子类来将状态转移函数 ( f )纳入因子图中，并通过优化来估计状态变量。以下是一个示例，演示了如何在PDR/GNSS联合定位中使用状态转移函数作为因子的一部分。</p><p>假设我们有一个PDR传感器和一个GNSS传感器，我们希望使用PDR的状态转移函数来更新我们的位置估计。这里我们将假设PDR传感器的状态转移函数为( f(x_t, u_t) )，其中 ( x_t ) 是时刻 ( t ) 的位置状态， ( u_t ) 是时刻 (t ) 的PDR测量值。</p><h5 id="其中一种">其中一种</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/base/numericalDerivative.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/geometry/Pose2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/inference/Symbol.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/ExpressionFactorGraph.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/Expression.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/LevenbergMarquardtOptimizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> gtsam;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义PDR状态转移函数</span></span><br><span class="line"><span class="function">Pose2 <span class="title">pdrStateTransition</span><span class="params">(<span class="type">const</span> Pose2&amp; xt, <span class="type">const</span> Pose2&amp; ut)</span> </span>{</span><br><span class="line">    <span class="comment">// 这里简单假设PDR每一步都是直线运动</span></span><br><span class="line">    <span class="keyword">return</span> xt.<span class="built_in">compose</span>(ut);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建优化器</span></span><br><span class="line">    LevenbergMarquardtOptimizer optimizer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建符号变量</span></span><br><span class="line">    <span class="function">Symbol <span class="title">x1</span><span class="params">(<span class="string">'x'</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 时刻1的位置状态</span></span><br><span class="line">    <span class="function">Symbol <span class="title">u1</span><span class="params">(<span class="string">'u'</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 时刻1的PDR测量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始估计值</span></span><br><span class="line">    Values initial;</span><br><span class="line">    initial.<span class="built_in">insert</span>(x1, <span class="built_in">Pose2</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 初始位置状态</span></span><br><span class="line">    initial.<span class="built_in">insert</span>(u1, <span class="built_in">Pose2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 初始PDR测量值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建因子图</span></span><br><span class="line">    ExpressionFactorGraph graph;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加PDR状态转移因子</span></span><br><span class="line">    <span class="comment">// 创建表达式表示PDR状态转移函数</span></span><br><span class="line">    Expression&lt;Pose2&gt; f_expr = <span class="built_in">pdrStateTransition</span>(<span class="built_in">Expression</span>&lt;Pose2&gt;(x1), <span class="built_in">Expression</span>&lt;Pose2&gt;(u1));</span><br><span class="line">    <span class="comment">// 添加因子</span></span><br><span class="line">    graph.<span class="built_in">addExpressionFactor</span>(f_expr, <span class="built_in">Pose2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), noiseModel::Isotropic::<span class="built_in">Sigma</span>(<span class="number">3</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行优化</span></span><br><span class="line">    Values result = optimizer.<span class="built_in">optimize</span>(graph, initial);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终估计结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Final Result:\n"</span>;</span><br><span class="line">    result.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在这个示例中，我们通过 <code>ExpressionFactorGraph</code>来创建因子图，并使用 <code>Expression</code>表示状态转移函数。然后，我们将这个表达式因子添加到因子图中，并执行优化以估计最终的状态。</p><p>这个示例中的 <code>pdrStateTransition</code>函数是一个简单的状态转移函数示例，实际应用中可能需要根据具体的PDR传感器和系统模型来定义更复杂的状态转移函数。</p><h5 id="另一种">另一种</h5><p>在GTSAM中，如果要将状态转移函数 ( f )作为实现因子的一部分，你需要定义自定义的因子类。这个类应当能够处理状态的更新并计算误差向量，同时能够自动计算雅可比矩阵。下面是一个例子，展示如何为一个简单的PDR/GNSS系统创建一个自定义的因子类。</p><p>以下是GTSAM中一个自定义因子的简单实现，用于处理PDR和GNSS数据：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/NonlinearFactor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/geometry/Pose2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> gtsam;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设系统的状态由位置 (x, y) 和方向 (theta) 组成，使用 Pose2 表示</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDRGNSSFactor</span> : <span class="keyword">public</span> NoiseModelFactor1&lt;Pose2&gt; {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 测量值</span></span><br><span class="line">  Point2 measuredGNSS;  <span class="comment">// GNSS测量的位置</span></span><br><span class="line">  <span class="type">double</span> measuredSteps; <span class="comment">// PDR测量的步数</span></span><br><span class="line">  <span class="type">double</span> stepLength;    <span class="comment">// 步长</span></span><br><span class="line">  <span class="type">double</span> measuredHeading; <span class="comment">// 步行方向</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造函数</span></span><br><span class="line"><span class="comment">   * key - 对应变量的键</span></span><br><span class="line"><span class="comment">   * measuredGNSS - GNSS测量值</span></span><br><span class="line"><span class="comment">   * measuredSteps - PDR测量的步数</span></span><br><span class="line"><span class="comment">   * stepLength - 单步步长</span></span><br><span class="line"><span class="comment">   * measuredHeading - 测量的步行方向</span></span><br><span class="line"><span class="comment">   * noiseModel - 噪声模型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">PDRGNSSFactor</span>(Key key, <span class="type">const</span> Point2&amp; gnssMeasurement, <span class="type">double</span> steps, <span class="type">double</span> length, <span class="type">double</span> heading, <span class="type">const</span> SharedNoiseModel&amp; noiseModel)</span><br><span class="line">    : <span class="built_in">NoiseModelFactor1</span>&lt;Pose2&gt;(noiseModel, key), <span class="built_in">measuredGNSS</span>(gnssMeasurement), <span class="built_in">measuredSteps</span>(steps), <span class="built_in">stepLength</span>(length), <span class="built_in">measuredHeading</span>(heading) {}</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算误差向量的函数</span></span><br><span class="line">  <span class="function">Vector <span class="title">evaluateError</span><span class="params">(<span class="type">const</span> Pose2&amp; pose, boost::optional&lt;Matrix&amp;&gt; H = boost::none)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">    <span class="comment">// 使用当前姿势来预测下一位置</span></span><br><span class="line">    <span class="type">double</span> dx = stepLength * measuredSteps * <span class="built_in">cos</span>(measuredHeading);</span><br><span class="line">    <span class="type">double</span> dy = stepLength * measuredSteps * <span class="built_in">sin</span>(measuredHeading);</span><br><span class="line">    <span class="function">Point2 <span class="title">predictedPosition</span><span class="params">(pose.x() + dx, pose.y() + dy)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要雅可比矩阵</span></span><br><span class="line">    <span class="keyword">if</span> (H) {</span><br><span class="line">      *H = (<span class="built_in">Matrix</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">cos</span>(measuredHeading), -<span class="built_in">sin</span>(measuredHeading), <span class="number">0</span>,</span><br><span class="line">                            <span class="built_in">sin</span>(measuredHeading),  <span class="built_in">cos</span>(measuredHeading), <span class="number">0</span>).<span class="built_in">finished</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回GNSS测量值和预测位置之间的差异</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Vector</span>(<span class="number">2</span>) &lt;&lt; measuredGNSS.<span class="built_in">x</span>() - predictedPosition.<span class="built_in">x</span>(), measuredGNSS.<span class="built_in">y</span>() - predictedPosition.<span class="built_in">y</span>()).<span class="built_in">finished</span>();</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>使用此因子</strong></p><p>在你的SLAM系统或状态估计框架中，你可以像添加任何其他因子一样添加这个自定义因子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NonlinearFactorGraph graph;</span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">PDRGNSSFactor</span>(<span class="number">1</span>, <span class="built_in">Point2</span>(<span class="number">34.052</span>, <span class="number">-118.243</span>), <span class="number">20</span>, <span class="number">0.5</span>, <span class="number">0.785</span>, noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>))));</span><br></pre></td></tr></tbody></table></figure><p>这里，我们假设了步长为0.5米，测量的步行方向为0.785弧度（大约45度）。</p><ul><li>确保你的噪声模型和其他系统参数与你的具体应用场景匹配。</li><li>如果你的状态模型或动态更复杂，你可能需要扩展 <code>Pose2</code>到更高维度的表示，或者使用 <code>Pose3</code>如果是三维空间的应用。</li></ul><p>这个示例为如何将PDR和GNSS数据融合到单一的因子中提供了一个框架，展示了如何结合两种不同类型的测量更新机器人或移动设备的位置估计。</p><h2 id="为什么是因子图不是卡尔曼">为什么是因子图不是卡尔曼</h2><p>（1）<strong>处理非线性问题</strong>：EKF在处理行人轨迹的不确定性和GNSS信号的非线性特性时存在性能限制。由于行人轨迹的不确定性本质上属于状态非线性过程，EKF通过线性化系统模型来处理非线性问题，但这种方法是局部的，仅在当前估计点附近有效。FGO则是通过构建一个包含所有测量和状态变量的全局图模型，然后应用非线性最优化技术在整个状态空间中寻找最优解来解决整个问题，而不是局限于在每个时间步的局部线性化。</p><blockquote><p>由于非线性问题的复杂性，这种全局优化通常是迭代进行的。每一次迭代都会重新计算整个状态的最优估计，更新的估计会反过来影响下一次迭代的起始条件。这个过程一直重复，直到达到一个收敛条件，比如改进非常小或达到预设的迭代次数。</p></blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>但是这个非线性的函数是需要自己手动添加的。那么问题来了，非线性函数都是自己手动给设置好的，怎么就直接参入因子图里面去了。就是编程里面？</p><blockquote><p>后续需要编程学习！需要定义误差因子</p></blockquote><ol start="2" type="1"><li>处理连续轨迹跟踪：EKF的一阶马尔可夫假设限制了其对历史数据的再评估能力，影响行人轨迹连续跟踪性能。FGO则在新数据到来时重新评估整个状态历史，进行全局优化，提供更准确的状态估计，尤其适用于需要频繁更新和修正轨迹估计的室外行人导航。</li></ol><blockquote><p>在因子图优化中，通常会使用全局优化算法（例如梯度下降、高斯牛顿、或勒文贝格-马夸尔特方法等）来找到最小化所有因子误差的整体解。<strong>这种优化会考虑到新的数据点以及它们与已有数据点之间的关系，</strong>从而可能会影响到整个状态历史的估计</p></blockquote><ol start="3" type="1"><li>异步数据处理：EKF在实时处理不同传感器数据更新频率不一致时面临挑战。FGO允许传感器数据以即插即用的方式整合，通过贝叶斯推理对因子进行综合分析，有效解决异步数据问题。</li></ol><blockquote><p>具体见后文因子图的即插即用</p></blockquote><p>(4)解算效率：EKF在处理大规模或复杂系统时，由于需要操作稠密的协方差矩阵而效率较低。相比之下，FGO通过仅在因子间建立显式连接，自然地体现了系统的稀疏性。这种特性使得FGO适合处理那些局部相互作用的大型系统，从而提高了效率。</p><p>综上所述，FGO为解决行人导航中的非线性问题、提高位置估计准确性、异步数据的处理和解算效率上提供了一种新的解决方案。</p><h2 id="因子图的增量更新">因子图的增量更新</h2><p>在因子图优化中，确实可以采用一种增量更新的方法，但这并不意味着每来一个新数据就单独优化一次。因子图优化通常包括两种主要的更新策略：批量优化和增量优化，这取决于应用的需求和系统设计。</p><h3 id="批量优化">批量优化</h3><p>在批量优化策略中，因子图会收集一定量的数据后，进行一次全局优化。这种方法可以确保考虑到所有可用的信息来优化整个图的配置。批量处理通常在数据集完整或更新频率不高的情况下使用，例如在某些离线处理或数据分析任务中。</p><h3 id="增量优化">增量优化</h3><p>增量优化策略则更加动态，它允许系统在接收到新数据时即时更新和优化图的一部分。这并不意味着每接收到一个新的数据点就执行一次完整的全局优化，<strong>而是指更新影响到的部分节点和边，从而局部调整图的结构。</strong>这样的方法适用于需要实时或近实时处理的应用，如移动机器人的导航或在线地图构建。</p><h3 id="如何处理新增数据">如何处理新增数据</h3><p>当新数据到达时，在因子图中，通常采用以下步骤处理：</p><ol type="1"><li><strong>新增因子</strong>：将新的观测数据转化为因子，并将其连接到图中对应的变量节点上。</li><li><strong>局部优化</strong>：对受新因子影响的节点进行局部优化，更新这些节点的状态估计。这种方法称为增量或局部优化。</li><li><strong>全局优化</strong>：在某些情况下，为了保证整体性能，可能定期进行一次全局优化，以整合所有信息并纠正潜在的误差积累。</li></ol><p>这种灵活性和即插即用的特性使因子图非常适合于动态环境下的应用，如动态传感器网络、实时导航系统等，它们需要不断地接受新信息并快速反应。因子图的这些特性也使得它能够在不重新启动系统的情况下适应新的配置或数据源的变化。</p><h2 id="因子图的即插即用">因子图的即插即用</h2><p>因子图对于处理传感器更新频率不一致问题提供了一种灵活且有效的方式，特别是在复杂的多传感器融合系统中。这主要得益于因子图在处理多源信息与维持全局状态估计方面的灵活性。</p><p>在因子图中，每个传感器的输入可以被视为一个因子，它只与图中的某些变量（例如机器人的某个位置）相关联。当新的传感器数据到来时，可以简单地将相应的新因子添加到图中，而无需重新配置整个系统。这使得因子图非常适合于处理具有不同更新频率的传感器数据。</p><p>假设一个机器人装备了一个高频率的IMU（惯性测量单元）和一个低频率的GPS。IMU能够提供高频率但低精度的位置和方向更新，而GPS提供低频率但高精度的位置测量。</p><ol type="1"><li><strong>构建因子图</strong>：机器人的每个状态（位置和姿态）都是图中的一个节点。IMU和GPS的每次读数分别产生一个新的因子，这些因子与特定的状态节点相连接。</li><li><strong>IMU因子</strong>：IMU的数据频繁更新，为图中相邻的状态节点间提供动态的约束（如速度和方向）。</li><li><strong>GPS因子</strong>：GPS数据不频繁，但每当数据到来时，会在因子图中创建一个新的因子，这个因子直接将GPS测量的位置与最近的状态节点相关联。</li><li><strong>因子更新</strong>：<strong>无论何时收到新的传感器数据，都只需将对应的新因子添加到图中并重新优化，而不必修改或重处理整个图。</strong></li></ol><h3 id="与卡尔曼滤波的比较"><strong>与卡尔曼滤波的比较</strong></h3><p>卡尔曼滤波器（包括其扩展和无迹变体）通常需要处理所有传感器数据的固定结构和预设的处理流程<strong>。每个传感器都需要在每个时间步被处理，即使某些传感器的数据并未更新。</strong></p><ul><li><strong>即插即用</strong>：卡尔曼滤波处理新传感器集成<strong>通常需要重新设计滤波过程和状态协方差的计算，而因子图可以更容易地通过添加新的因子来整合新传感器，无需重新设计或重新初始化整个系统。</strong></li><li><strong>处理非同步数据</strong>：卡尔曼滤波器<strong>对于非同步传感器数据处理通常需要额外的插值或同步机制，而因子图可以更自然地通过在适当的时间点插入因子来处理这种数据。</strong></li></ul><p>卡尔曼滤波器（KF）是一种适用于线性系统（或近似线性）的递推滤波方法，它依赖于数据输入的同步和连续性。在实际应用中，如自动驾驶车辆、机器人导航或多传感器融合系统中，传感器可能无法以同一频率或同步的方式产生数据。这会给基于卡尔曼滤波的系统设计带来挑战。</p><p><strong>卡尔曼滤波器和非同步数据处理</strong></p><p>当使用卡尔曼滤波器处理来自不同传感器的数据时，若这些传感器的更新频率不一致或数据非同步接收，可能需要进行额外处理以保证数据的时序一致性。这主要是因为卡尔曼滤波器在每个时间步更新状态估计时都假定接收到的数据是当前时刻的准确反映。</p><p><strong>举例说明</strong></p><p>假设有一个移动机器人使用两种传感器：一个激光雷达（LIDAR）和一个轮速计。激光雷达每100毫秒更新一次位置信息，而轮速计每30毫秒更新一次速度信息。如果直接将这些数据输入到一个卡尔曼滤波器，可能会出现问题，因为两种数据的时间戳不匹配。</p><p>为了同步这些传感器数据，一个常见的方法是使用插值：</p><ul><li><strong>插值</strong>：例如，可以使用线性插值或更复杂的插值方法（如样条插值）来估计激光雷达测量间隙中的位置数据，或者在轮速计测量间隙中估计速度，以便在非测量时刻提供数据估计。</li><li><strong>数据缓冲</strong>：另一种方法是对快速更新的传感器（轮速计）数据进行缓冲，直到慢速传感器（激光雷达）的下一次数据到来，然后一起处理这些数据。</li></ul><p>卡尔曼滤波器（KF）处理的核心在于<strong>它按照严格的时序顺序处理观测数据来更新状态估计</strong>。这个处理过程基于两个关键假设：<strong>系统的动态是已知的，并且观测数据是同步到特定的时间点的。</strong>当观测数据来自频率不同或非同步的多个传感器时，这些假设可能不再成立，直接接受数据而不进行任何处理可能会导致以下问题：</p><p><strong>1. 误差累积</strong></p><p>卡尔曼滤波器在每个时间步更新其状态估计时，假设最新的观测数据反映了当前的系统状态。<strong>如果直接使用非同步的观测数据，滤波器可能无法准确地关联观测数据与其对应的状态，从而导致误差累积</strong>。例如，如果一个传感器的数据延迟或提前了，而滤波器误以为这些数据是最新的，那么更新的状态估计可能会基于错误的信息。</p><p><strong>2. 时间戳不匹配</strong></p><p>在处理来自不同传感器的数据时，<strong>每个传感器的输出通常带有时间戳。如果这些时间戳不一致，直接接受数据意味着滤波器可能会在错误的时间点应用观测数据，导致状态更新不准确</strong>。这对于那些高度依赖精确时间信息的应用（如导航和跟踪系统）尤为重要。</p><p><strong>3. 数据丢失或重叠</strong></p><p>非同步数据可能导致数据在时间轴上出现重叠或缺口。例如<strong>，一个传感器可能在另一个传感器的两次读数之间多次更新，或者在长时间内没有更新。这种情况下，直接处理可能导致某些观测数据被忽略或重复计算，影响滤波器的性能</strong>。</p><h3 id="卡尔曼滤波的结构和限制">卡尔曼滤波的结构和限制</h3><ol type="1"><li><p><strong>模型依赖性</strong>：卡尔曼滤波依赖于一个预先定义好的线性模型（或在扩展卡尔曼滤波和无迹卡尔曼滤波中的非线性模型近似）。这个模型包括状态转移矩阵和观测矩阵，它们必须在滤波器初始化时就确定下来。如果系统的动态特性改变（例如，添加了新的传感器或系统的运动模型改变），可能需要重新定义这些模型矩阵。</p></li><li><p><strong>系统维度</strong>：卡尔曼滤波在设计时需要确定状态向量的维度。如果需要加入新的状态变量（比如从新传感器获得的额外数据），通常需要重新设计整个状态向量和相关的处理矩阵，这可能涉及到重新设计状态转移和观测矩阵，以及相应的噪声协方差矩阵。</p></li><li><p><strong>实时性和适应性</strong>：卡尔曼滤波器是为了连续、实时的数据流设计的，其强大的实时更新能力在许多应用中非常有用。然而，对于动态变化的系统配置或异步数据源的适应性则不如因子图灵活。</p></li></ol><p>虽然卡尔曼滤波在处理线性系统、实时跟踪等方面有其固有优势，但在系统动态变化较大、数据源频繁变动或需要处理高度非线性系统时，因子图提供了更高的灵活性和扩展性。因子图的结构使其能够更容易地适应系统配置的变化，而不需要进行大规模的系统重设计。这使得因子图在多传感器融合、复杂环境导航等领域尤为适用。</p><h4 id="解决方法插值和数据缓冲"><strong>解决方法：插值和数据缓冲</strong></h4><p>为了解决这些问题，卡尔曼滤波器通常采用以下策略：</p><ul><li><p><strong>插值</strong>：通过插值方法（如线性插值、样条插值等）创建虚拟的观测数据，填补时间上的缺口，使得每个时间步都有相应的数据输入。这有助于保持滤波器的连续性和准确性。</p></li><li><p><strong>数据缓冲</strong>：将来自不同传感器的数据存储在缓冲区中，直到收集到所有相关传感器的数据为止。然后，根据这些数据的时间戳一起处理它们。这样可以保证数据在时间上的一致性，减少由于时间错配引起的误差。</p></li></ul><p>这两种方法使得卡尔曼滤波器能够更加稳定和准确地处理来自多源的非同步数据，从而提高系统的整体性能。</p><h3 id="因子图的优势"><strong>因子图的优势</strong></h3><p>相比之下，因子图提供了一个更灵活的框架来处理非同步数据。因子图是一种图形模型，它以图的形式表示变量之间的条件依赖关系。在因子图中，每个传感器的读数可以作为一个因子被添加到图中，这些因子与它们影响的状态变量相关联。如果传感器数据是非同步的，可以：</p><ul><li><strong>动态添加因子</strong>：根据每个传感器的时间戳动态地向图中添加新的因子。这意味着每个传感器更新只影响相关的状态变量，不需要人为地同步所有数据。</li><li><strong>时间标记</strong>：每个因子可以携带时间信息，因此状态更新可以在正确的时间点进行，与数据实际测量的时间相匹配。</li></ul><p>因此，因子图模型通过在合适的时间点添加因子来自然地处理非同步的传感器数据，从而避免了在卡尔曼滤波器中必须进行的数据插值或同步。这样不仅简化了处理过程，而且可能提高了系统的整体性能和精度。</p><p>因子图的结构允许在不中断现有系统的情况下动态地添加新的节点和边。这在处理如下情况时特别有用：</p><ul><li><strong>新增数据源</strong>：可以将新传感器数据直接作为新因子加入图中，与相关的状态节点连接，无需改变现有的其他因子或节点。</li><li><strong>系统扩展</strong>：在因子图中，系统的扩展通常只涉及向图中添加更多的节点和边，而不需要重新配置整个系统的基本结构。</li></ul><h3 id="因子图处理和识别不同的传感器">因子图处理和识别不同的传感器</h3><p>要在代码层面正确地处理和区分不同类型的传感器数据（如IMU和GNSS），你通常需要依赖于数据本身的元数据，这些元数据包括数据类型、时间戳等信息。让我们从这两个方面（实际实现和理论理解）来探讨你的问题：</p><h4 id="代码层面如何识别和处理不同的传感器数据">代码层面：如何识别和处理不同的传感器数据</h4><p>在现实世界的应用中，每个传感器的输出通常会被标记有其类型，可能还包括精确的时间戳。这允许你在接收数据时进行适当的处理。以下是一个简化的例子，展示如何在接收数据时识别和处理IMU与GNSS数据：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IMUData</span> {</span><br><span class="line">    <span class="type">double</span> acceleration[<span class="number">3</span>];  <span class="comment">// 加速度数据</span></span><br><span class="line">    <span class="type">double</span> gyro[<span class="number">3</span>];          <span class="comment">// 陀螺仪数据</span></span><br><span class="line">    <span class="type">double</span> timestamp;        <span class="comment">// 时间戳</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GNSSData</span> {</span><br><span class="line">    <span class="type">double</span> latitude;</span><br><span class="line">    <span class="type">double</span> longitude;</span><br><span class="line">    <span class="type">double</span> altitude;</span><br><span class="line">    <span class="type">double</span> timestamp;        <span class="comment">// 时间戳</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::variant&lt;IMUData, GNSSData&gt; SensorData; <span class="comment">// 使用C++17标准的std::variant来处理不同类型的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理IMU数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processIMUData</span><span class="params">(<span class="type">const</span> IMUData&amp; data)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Processing IMU Data at timestamp: "</span> &lt;&lt; data.timestamp &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 添加IMU因子到因子图等</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理GNSS数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processGNSSData</span><span class="params">(<span class="type">const</span> GNSSData&amp; data)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Processing GNSS Data at timestamp: "</span> &lt;&lt; data.timestamp &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 添加GNSS因子到因子图等</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理传感器数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> SensorData&amp; sensorData)</span> </span>{</span><br><span class="line">    std::<span class="built_in">visit</span>([&amp;](<span class="keyword">auto</span>&amp;&amp; data) {</span><br><span class="line">        <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(data)&gt;;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, IMUData&gt;) {</span><br><span class="line">            <span class="built_in">processIMUData</span>(data);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, GNSSData&gt;) {</span><br><span class="line">            <span class="built_in">processGNSSData</span>(data);</span><br><span class="line">        }</span><br><span class="line">    }, sensorData);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    IMUData imuData = {{<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>}, {<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>}, <span class="number">0.1</span>};</span><br><span class="line">    GNSSData gnssData = {<span class="number">34.05</span>, <span class="number">-118.25</span>, <span class="number">100</span>, <span class="number">0.2</span>};</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processData</span>(imuData);</span><br><span class="line">    <span class="built_in">processData</span>(gnssData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="理论层面为什么因子图能实现即插即用">理论层面：为什么因子图能实现即插即用</h4><p>因子图的设计非常适合于处理复杂的多源信息融合问题，主要有以下几个理由：</p><ol type="1"><li><p><strong>模块化</strong>：因子图通过因子来定义变量间的关系。每个传感器的数据可以被视为一个因子，这些因子可以独立地被添加到图中。因此，不同类型和不同时间的传感器数据可以作为独立的因子插入，而不会影响图中的其他部分。</p></li><li><p><strong>灵活性</strong>：由于因子图中各个因子的独立性，新的数据可以在任何时点加入图中，而不需要按照特定的顺序。这对于处理具有不同采样率和可能不同步到达的传感器数据尤其有用。</p></li><li><p><strong>扩展性</strong>：因子图可以容易地扩展以包含新的变量和因子，使得它非常适合于动态环境和在线更新的场景。</p></li></ol><p>因子图允许在不重新整个系统的情况下，根据新接收到的数据进行局部更新，这使得它非常适合于需要实时或近实时性能的应用，如动态的机器人导航和车辆定位系统。</p><h2 id="为什么要引进g_ii-i_dtimes-d">为什么要引进<span class="math inline">\(G_i^i=-I_{d\times d}\)</span></h2><blockquote><p>关于这个莫名的公式可以看看isam的公式，这个就是对那个公式的补充点</p></blockquote><p>在因子图和图优化中进行线性化处理时，引入矩阵<span class="math inline">\(G_i^i = -I_{d \timesd}\)</span>是为了便于表达和操作线性化的状态变化量。这里，$ I_{d d} <span class="math inline">\(表示 \( d \)-维的单位矩阵。矩阵 \( G_i^i \)的作用是在数学表达式中简化状态变量\)</span>x_i$的运算，从而使得该线性系统易于使用线性代数技术求解。</p><p>在线性化的SLAM或图优化问题中，我们通常处理的是两类项：</p><ol type="1"><li><strong>过程模型项</strong>：它们涉及从一个状态<span class="math inline">\(x_{i-1}\)</span> 到下一个状态$x_i$的过渡，如机器人的运动模型。</li><li><strong>测量模型项</strong>：涉及从状态变量到测量变量的映射，如从机器人的位置到传感器观测的映射。</li></ol><p><strong>引入 $G_i^i = -I_{d d} $</strong></p><p>在方程 (6) 中，我们考虑了状态变量 <span class="math inline">\(x_i\)</span>和<span class="math inline">\(x_{i-1}\)</span>之间的关系。线性化后的模型需要处理这些状态变量的增量<span class="math inline">\(\delta x_i\)</span>和<span class="math inline">\(\deltax_{i-1}\)</span>。线性化过程后的表达式为：</p><p><span class="math display">\[f_i(x_{i-1}, u_i) - x_i \approx \{ f_i(x_{i-1}^0, u_i) + F_i^{i-1}\delta x_{i-1} \} - \{ x_i^0 + \delta x_i \}\]</span> 要将这个方程转换成标准的线性形式，我们需要确保$ x_i $ 和<span class="math inline">\(\deltax_{i-1}\)</span>在同一方程中有适当的正负号。在这里，引入<span class="math inline">\(G_i^i = -I_{d \times d}\)</span>允许我们将$x_i $项简单地表示为加法形式的负增量，即：</p><p><span class="math display">\[F_i^{i-1} \delta x_{i-1} - \delta x_i = F_i^{i-1} \delta x_{i-1} + G_i^i\delta x_i\]</span> 这样，线性方程更容易处理，因为它将状态变化量<span class="math inline">\(\deltax_i\)</span>直接以线性代数的标准形式表示，允许使用矩阵运算直接进行计算。</p><p><strong>线性最小二乘问题</strong></p><p>通过引入<span class="math inline">\(G_i^i = -I_{d \timesd}\)</span>整个问题可表示为一个标准的线性最小二乘问题：</p><p><span class="math display">\[\delta^* = \underset{\delta}{\operatorname*{argmin}} \left\{\sum_{i=1}^M \| F_i^{i-1} \delta x_{i-1} + G_i^i \delta x_i + a_i\|_{\Lambda_i}^2 + \sum_{k=1}^K \| H_k^{i_k} \delta x_{i_k} + J_k^{j_k}\delta l_{j_k} - c_k \|_{\Sigma_k}^2 \right\}\]</span>这个形式使得应用线性代数和优化方法成为可能，从而可以有效求解大规模SLAM问题。</p><h2 id="信息矩阵i">信息矩阵<span class="math inline">\(I\)</span></h2><p>在机器人定位和地图构建的问题中，通常涉及到估计机器人在环境中的位置轨迹<span class="math inline">\(X\)</span>以及环境本身的结构地图 <span class="math inline">\(L\)</span>。在这种情况下，信息矩阵 <span class="math inline">\(\mathcal{I}\)</span>，也被称为费舍尔信息矩阵，是用来表示这些未知量的不确定性和相互依赖关系的关键工具。</p><p>信息矩阵 <span class="math inline">\(\mathcal{I}\)</span>是由雅可比矩阵 <span class="math inline">\(A\)</span>（或系统的设计矩阵）通过 <span class="math inline">\(A^T A\)</span>计算得到的。这个矩阵可以从以下几个方面描述机器人轨迹和地图内部的信息.</p><ol type="1"><li><strong>量化不确定性:</strong><ul><li>对角线元素：<strong>信息矩阵的对角线元素量化了每个参数（位置或地图特征）的信息量或确信度</strong>。对角线元素的值越大，表示对应参数的不确定性越小，我们对该参数的估计越精确。</li><li>非对角线元素：<strong>非对角线元素描述了参数之间的依赖关系或相关性。</strong>例如，<strong>如果位置<span class="math inline">\(x_i\)</span> 和位置 <span class="math inline">\(x_j\)</span>（或地图特征）在矩阵中的对应元素非零，这表明这两个位置（或特征）的估计值相互依赖</strong>。</li></ul></li><li><strong>编码相关性</strong>:<ul><li>分块 <span class="math inline">\(\mathcal{I}_{XL}\)</span> 和 <span class="math inline">\(\mathcal{I}_{XL}^T\)</span>特别重要，因为它们编码了轨迹 <span class="math inline">\(X\)</span>和地图 <span class="math inline">\(L\)</span>之间的相关性。<strong>这意味着机器人在特定位置的估计如何依赖于地图的特定特征，</strong>反之亦然。这种相关性对于同时定位和地图构建（SLAM）至关重要，因为它帮助系统同时解决导航和地图创建的问题。</li></ul></li><li><strong>优化和解算:</strong><ul><li>在实际应用中，基于信息矩阵的结构，可以采用更有效的数值方法来解决估计问题，<strong>如使用稀疏矩阵技术处理大规模SLAM问题。信息矩阵的稀疏性表明很多参数之间的依赖性较低，这可以大大减少计算量。</strong></li></ul></li></ol><p>信息矩阵 <span class="math inline">\(\mathcal{I}\)</span>不仅提供了对机器人轨迹和地图每一部分的内部信息的详尽描述，而且还通过其结构揭示了不同部分之间的相互作用和依赖性，从而在理论和实践中都是解决SLAM问题的核心部分。</p><p>矩阵 <span class="math inline">\(\mathcal{I}\)</span> 是通过矩阵<span class="math inline">\(A\)</span> 的转置乘以 <span class="math inline">\(A\)</span> 计算得到的，这里 <span class="math inline">\(A\)</span> 被分为两部分：对应于机器人轨迹 <span class="math inline">\(X\)</span> 的 <span class="math inline">\(A_X\)</span> 和对应于地图 <span class="math inline">\(L\)</span> 的 <span class="math inline">\(A_L\)</span>。</p><p>矩阵 <span class="math inline">\(\mathcal{I}\)</span>的结构表明它分为四个部分：</p><ol type="1"><li><span class="math inline">\(A_X^TA_X\)</span>：这是左上角的块，代表轨迹 <span class="math inline">\(X\)</span> 内部的信息。</li><li><span class="math inline">\(A_L^TA_L\)</span>：这是右下角的块，代表地图 <span class="math inline">\(L\)</span> 内部的信息。</li><li><span class="math inline">\(\mathcal{I}_{XL}\)</span> 和 <span class="math inline">\(\mathcal{I}_{XL}^T\)</span>：这两个块分别位于非对角线的位置，<span class="math inline">\(\mathcal{I}_{XL} \triangleq A_X^T A_L\)</span>和其转置表示轨迹 <span class="math inline">\(X\)</span> 和地图 <span class="math inline">\(L\)</span> 之间的相关性。</li></ol><p><span class="math display">\[\mathcal{I}_{XL} \triangleq A_X^T A_L\]</span></p><p>表示的是 <span class="math inline">\(A_X\)</span> 和 <span class="math inline">\(A_L\)</span> 之间的交叉信息，它编码了机器人状态<span class="math inline">\(X\)</span> 和地图 <span class="math inline">\(L\)</span> 之间的相关性。对角线块 <span class="math inline">\(A_X^T A_X\)</span> 和 <span class="math inline">\(A_L^T A_L\)</span>表明它们是“带对角线”的，这通常意味着这些块主要关注各自的内部结构和相互作用，而不是外部的。</p><p>关于信息矩阵和残差</p><p>标准化残差考虑到了模型和观测的不确定性，这种不确定性可以通过残差的协方差矩阵来量化，而这个协方差矩阵的估计依赖于参数的协方差矩阵，即信息矩阵的逆。因此，信息矩阵I通过其逆的形式，直接影响到标准化残差的计算，特别是在决定各残差分量的权重时。</p><h2 id="关于ax-b-中a和b的物理意义">关于AX-b 中A和b的物理意义</h2><p>在SLAM问题中，机器人的动态与环境交互通过一系列的状态转移和观测更新来描述。<strong>矩阵<span class="math inline">\(A\)</span>在这个问题中的作用，是将这些动态和交互的关系转化为数学形式，特别是以线性化的方式来近似非线性系统的行为。</strong></p><p><strong>矩阵 <span class="math inline">\(A\)</span>的意义：</strong></p><ol type="1"><li>物理意义：矩阵 <span class="math inline">\(A\)</span>表示系<strong>统状态变量之间的关系，以及状态变量与观测之间的线性关系。</strong>具体来说：<ul><li>运动模型部分：矩阵<span class="math inline">\(F_i^{i-1}\)</span> 和<span class="math inline">\(G_i^i\)</span> 表示从状态 <span class="math inline">\(x_{i-1}\)</span>到状态 <span class="math inline">\(x_i\)</span>的线性化运动模型。这些块表示了机器人如何从一个位置或方向移动到下一个位置，通常基于机器人的控制指令如转向和前进。描绘了状态之间的转移关系。</li><li>观测模型部分：矩阵 <span class="math inline">\(H_k^{i_k}\)</span>)和<span class="math inline">\(J_k^{j_k}\)</span> 表示状态 <span class="math inline">\(x_{i_k}\)</span>)和地标 <span class="math inline">\(l_{j_k}\)</span>)如何影响第 <span class="math inline">\(k\)</span>次观测。这反映了如何从当前状态和地标位置预测观测值例如，从摄像头或激光雷达。通过<span class="math inline">\(H_k^{i_k}\)</span> 和 <span class="math inline">\(J_k^{j_k}\)</span>描述的块，这些块表明如何从当前的状态和地标位置预测可能的观测结果 <span class="math inline">\(z_k\)</span>。</li></ul></li></ol><p><strong>向量 <span class="math inline">\(b\)</span></strong>：向量<span class="math inline">\(b\)</span>通常<strong>包含观测数据与由模型预测的状态转移或观测的差异</strong>。在SLAM中，<span class="math inline">\(b\)</span> 可能由实际观测值 <span class="math inline">\(z_k\)</span>减去根据当前状态估计和地标估计得到的预测观测值构成。</p><p>计算意义：在最优化问题中，我们通常求解最小化 <span class="math inline">\((|A\delta -b|_2^2)\)</span>，这是一个最小二乘问题，意味着我们在寻找最佳的状态变量更新(<span class="math inline">\(\delta\)</span>)，使得线性化模型的预测尽可能接近实际观测和运动指令的结果。</p><p><strong>为什么 <span class="math inline">\(A\)</span>重要：</strong></p><ul><li>(<span class="math inline">\(A\)</span>)矩阵<strong>捕捉了机器人动态和环境的整体结构，</strong>这是理解和解决SLAM问题的核心。正确构建和更新这个矩阵对于准确地估计机器人的状态和地图至关重要。</li><li>矩阵的稀疏性表明大多数状态变量不直接相互影响，这在数值计算上是有利的。稀疏矩阵技术可以显著提高求解SLAM问题的效率。</li></ul><p>因此，矩阵A通过其块状结构和各个元素，捕捉了机器人如何移动（动态）和如何观察周围环境（观测）的数学描述。这不仅包括了机器人状态的转移关系，还包括了状态与环境地标之间的相互作用。通过优化问题最小化$|A-b|_2^2$，我们实际上是在调整对机器人状态和地图的估计，使得这些线性化的预测尽可能贴近实际观测，从而实现同时定位与地图构建的目的。</p><p>在SLAM问题中，矩阵 <span class="math inline">\(A\)</span> 和向量<span class="math inline">\(b\)</span>的物理意义及其在优化问题中的作用是核心部分，反映了状态估计的数学模型与实际操作间的联系:</p><p><strong>最小化正规方程 <span class="math inline">\(A^T A x = A^Tb\)</span></strong></p><p>在SLAM问题的线性化模型中，我们通常希望找到一个状态变量的更新量 <span class="math inline">\(\delta\)</span>，使得模型预测尽可能贴近实际的观测。具体来说，我们尝试最小化以下目标函数：</p><p><span class="math display">\[\| A \delta - b \|_2^2\]</span></p><ul><li><span class="math inline">\(|\cdot|_2^2\)</span>表示二范数的平方，用于度量误差的大小。</li><li><span class="math inline">\(A \delta\)</span>表示对当前状态估计的改正（或更新）。</li><li><span class="math inline">\(b\)</span>是观测数据与模型预测之间的差异。</li></ul><p>解决这个最小化问题通常涉及到求解正规方程：</p><p><span class="math display">\[A^T A \delta = A^T b\]</span></p><ul><li><span class="math inline">\(A^T A\)</span>是一个方阵，通常更易于处理，尤其是当 <span class="math inline">\(A\)</span>是稀疏或结构化的时，这种方法效率更高。</li><li><span class="math inline">\(A^T b\)</span>是一个向量，表示在当前误差度量下，最佳更新方向的投影。</li></ul><p>通过最小化这个误差，我们在数学上是在寻找一个向量 <span class="math inline">\(\delta\)</span>，使得 <span class="math inline">\(A \delta\)</span> 尽可能接近 <span class="math inline">\(b\)</span>，即尝试对预测的状态和观测进行校正，以逼近真实的观测值。</p><h2 id="滤波器与平滑器">滤波器与平滑器</h2><p>在SLAM（Simultaneous Localization andMapping，即同时定位与建图）问题中，信息矩阵 (I)是一个关键的概念，用于表示机器人的状态（如位置和方向）以及环境中地标的不确定性。信息矩阵是协方差矩阵的逆，其中每个元素反映了状态变量之间的条件依赖性。在SLAM中，主要有两种处理信息的方法：滤波和平滑。</p><h3 id="滤波">滤波</h3><p><strong>滤波</strong>是一种在线处理方式，即它只处理当前和过去的信息，通常用于实时系统中。在滤波过程中，随着新数据的持续加入，为了维持计算的可管理性，旧的数据或状态往往需要被边缘化（移除），这导致信息矩阵趋向于变得密集。</p><ul><li>在滤波过程中，为了保持计算的实时性和可管理性，通常只会保留当前状态的信息，而把旧的状态信息“边缘化”（即从当前考虑的状态集中移除）。<strong>这种边缘化过程会引入额外的非零元素到信息矩阵中，因为边缘化旧状态意味着需要将这些状态的信息“分摊”到剩余的状态上</strong>。结果是信息矩阵变得密集，即使原来很多状态之间是条件独立的。</li><li>为了处理这种密集化，研究者通常会采用各种技术（如稀疏化技术）来移除信息矩阵中的某些链接，以减少计算负担。</li></ul><blockquote><p>解释为什么在SLAM中进行滤波操作时，边缘化过去的状态会导致信息矩阵变得密集。</p></blockquote><h4 id="示例情景"><strong>示例情景</strong></h4><p>假设一个机器人在一个简单的环境中沿直线移动，每移动一段距离记录一次位置，形成状态序列<span class="math inline">\(X_1, X_2, X_3, \ldots,X_t\)</span>。每个状态都与其前后状态有直接的连接（例如通过里程计测量），并可能与环境中的某些地标有关联。</p><p>在开始，信息矩阵 (I)是稀疏的，因为只有时间上相邻的状态或与某个地标直接相关的状态之间存在连接。例如，如果(X_1)和(X_2)通过里程计相关联，那么在信息矩阵中，<span class="math inline">\(I_{1,1}，I_{1,2}，和I_{2,2}\)</span>是非零的。</p><h4 id="边缘化过程"><strong>边缘化过程</strong></h4><p>当机器人继续前进并且需要在滤波器中处理新的状态时（比如(X_{t+1})），为了保持计算的可管理性，较早的状态（比如(X_1))可能会被边缘化掉。边缘化(X_1)意味着我们需要从当前激活的状态集中移除(X_1)的影响。</p><ul><li>原本(X_1)直接影响(X_2)，在边缘化(X_1)后，我们必须将(X_1)对(X_2)的影响“转移”给与(X_2)相关的其他状态，比如(X_3)。这意味着原先(X_1)与(X_3)可能没有直接关系，但在边缘化(X_1)后，(X_2)与(X_3)之间的关系需要加强，以反映从(X_1)到(X_3)的间接影响。</li></ul><p>当我们在状态估计或者滤波问题中进行边缘化时，我们的目标是将某些状态（例如<span class="math display">\[X_1\]</span>）的影响通过与其相关联的其他状态（如<span class="math display">\[X_2\]</span> 和 <span class="math display">\[X_3\]</span>）重新表达，而不是直接包括这些状态。这个过程在信息矩阵（或费舍尔信息矩阵）中的表示可以通过一个具体的数学过程来阐述。</p><p>假设我们的系统的信息矩阵 <span class="math display">\[\mathcal{I}\]</span> 分布如下，其中包含三个状态<span class="math display">\[X_1\]</span>, <span class="math display">\[X_2\]</span>, 和 <span class="math display">\[X_3\]</span>： <span class="math display">\[\mathcal{I} = \begin{bmatrix}\mathcal{I}_{11} &amp; \mathcal{I}_{12} &amp; \mathcal{I}_{13} \\\mathcal{I}_{21} &amp; \mathcal{I}_{22} &amp; \mathcal{I}_{23} \\\mathcal{I}_{31} &amp; \mathcal{I}_{32} &amp; \mathcal{I}_{33}\end{bmatrix}\]</span> 在这里，<span class="math display">\[\mathcal{I}_{ij}\]</span>表示状态 <span class="math display">\[X_i\]</span> 和状态 <span class="math display">\[X_j\]</span> 之间的信息量。</p><p>当我们决定边缘化状态 <span class="math display">\[X_1\]</span>，我们需要消除 <span class="math display">\[X_1\]</span> 的影响，并将其影响“转移”到与 <span class="math display">\[X_1\]</span> 相关的其他状态，比如 <span class="math display">\[X_2\]</span> 和 <span class="math display">\[X_3\]</span>。边缘化 <span class="math display">\[X_1\]</span> 的信息矩阵可以通过 Schur 补数得到：<span class="math display">\[\mathcal{I}_{\text{marginal}} = \mathcal{I}_{22:33} -\mathcal{I}_{21:31}^T \mathcal{I}_{11}^{-1} \mathcal{I}_{21:31}\]</span> 其中：</p><ul><li><span class="math display">\[\mathcal{I}_{22:33}\]</span> 表示除去与<span class="math display">\[X_1\]</span>相关的行和列后剩余的信息矩阵部分。</li><li><span class="math display">\[\mathcal{I}_{21:31}\]</span> 表示与<span class="math display">\[X_1\]</span>相关的其它状态的交叉信息块。</li></ul><p>假设原信息矩阵的块为： <span class="math display">\[\mathcal{I}_{11} = \begin{bmatrix}2\end{bmatrix}, \quad \mathcal{I}_{21:31} = \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix}, \quad \mathcal{I}_{22:33} = \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix}\]</span></p><p>进行计算： <span class="math display">\[\mathcal{I}_{\text{marginal}} = \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix} - \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix} \begin{bmatrix}2\end{bmatrix}^{-1} \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix} = \begin{bmatrix}0 &amp; 0 \\0 &amp; 0\end{bmatrix}\]</span></p><p>这个简化例子说明了如何通过矩阵运算处理边缘化。实际应用中，这个过程将导致<span class="math display">\[\mathcal{I}_{22:33}\]</span>的非对角线元素变得非零，表明 <span class="math display">\[X_2\]</span>和 <span class="math display">\[X_3\]</span>之间的新建立的依赖关系。这反映了从 <span class="math display">\[X_1\]</span> 到 <span class="math display">\[X_3\]</span> 的间接影响，即使在原始矩阵中 <span class="math display">\[X_2\]</span> 和 <span class="math display">\[X_3\]</span>之间没有直接的依赖关系。随着更多状态的边缘化，信息矩阵将变得更加密集，反映出复杂的依赖关系网络。</p><h4 id="结果"><strong>结果</strong></h4><p>这个转移过程在信息矩阵中表现为原先为零的元素变成非零，因为(X_2)和(X_3)现在有了新的依赖关系。随着越来越多状态的边缘化，这种间接依赖会累积，导致信息矩阵逐渐从稀疏变为密集。</p><h4 id="几何直观"><strong>几何直观</strong></h4><p>可以想象，每个状态不仅与其直接的邻居有联系，还因为边缘化而与更多其他状态产生了联系。随着时间的推移，几乎每个状态都以某种方式间接地与其他所有状态连接，从而增加了信息矩阵中的非零元素数量，使矩阵变得密集。</p><p>这种密集化不仅增加了计算的复杂度，还可能影响滤波器的性能，因此在实际应用中，开发者会寻找各种方法（例如使用稀疏近似或选择性地保留关键状态）来尽可能减少这种影响。</p><h3 id="平滑">平滑</h3><p><strong>平滑</strong>则是一种离线处理方式，它考虑全部的数据（包括过去和未来的数据）。在平滑处理中，由于不需要边缘化任何状态（因为所有状态对计算都是可用的），所以关联的信息矩阵维持稀疏性，这是因为不存在需要通过边缘化引入新依赖的需求。</p><ul><li>平滑处理，相比于滤波，不会边缘化任何过去的状态。相反，它保留了所有历史和当前的状态信息，因此可以在整个时间线上提供更精确的状态估计。</li><li>在<strong>平滑方法中，由于不进行边缘化操作，所以不会引入额外的非零元素导致信息矩阵密集化。这意味着信息矩阵能够保持其原始的稀疏结构，其中非零元素主要集中在时间线上相邻状态之间的依赖关系。</strong>这种稀疏性是因为在大多数SLAM场景中，只有时间上相邻的状态或空间上邻近的地标才具有直接的相互依赖。</li></ul><p>因此，在与平滑信息矩阵 (I)关联的MRF中，信息矩阵保持稀疏，<strong>主要是因为平滑处理不涉及边缘化过去的状态</strong>。这样，每个状态只与其直接相关的少数几个其他状态或地标相关联，而不是与整个历史状态集相关联，从而避免了矩阵的密集化。这种方法不仅保持了计算效率，而且通常能提供比滤波更为精确的状态估计。</p><p>用一个具体的数学例子来解释SLAM问题中平滑方法的信息矩阵是如何维持其稀疏性的。在这个例子中，我们考虑一个小规模的机器人轨迹，其中机器人在四个时间点上测量其位置。我们将看到在不进行边缘化的情况下，信息矩阵如何保持其结构。</p><p>假设有四个状态<span class="math inline">\(X_1, X_2, X_3,X_4\)</span>，它们代表机器人在四个连续时间点的位置。在SLAM中，通常只有连续的状态之间存在直接的测量依赖关系。</p><p>在平滑方法中，信息矩阵I初始化时将反映状态之间的这些直接依赖关系。例如，如果我们假设每个状态只与其前后状态有关系，并且每个这样的依赖对信息矩阵贡献(1) 的信息值，那么信息矩阵可能看起来像这样：</p><p><span class="math display">\[I = \begin{bmatrix}1 &amp; -1 &amp; 0 &amp; 0 \\-1 &amp; 2 &amp; -1 &amp; 0 \\0 &amp; -1 &amp; 2 &amp; -1 \\0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\]</span> 这里，对角线上的元素 (2)表示一个状态依赖于其前后状态的信息总和（除了边界条件，即 (X_1) 和(X_4)）。非对角线的 (-1) 表示状态 (X_i) 与 (X_{i+1}) 和 (X_{i-1})之间的信息依赖。</p><p>在平滑方法中，由于不进行边缘化操作，<strong>我们保留所有历史状态的数据。这意味着在任何给定的时刻，我们都可以访问到所有历史和未来的状态信息，而不是只有当前和未来的状态</strong>。因此，信息矩阵的非零结构不会改变——它始终保持与初始时刻相同的稀疏模式。</p><p>这种方法的优点是，信息矩阵维持了其稀疏性，这大大减少了计算的复杂性和内存需求。例如，当使用稀疏矩阵技术处理大型SLAM问题时，这一特性非常重要。每个状态只与直接相邻的状态有关系，没有因边缘化而引入的额外复杂依赖关系。</p><p>这样的稀疏结构是高效处理大规模SLAM问题的关键，因为它减少了必须处理的数据量，并允许使用优化的数值方法来处理信息矩阵。</p><h3 id="为什么在平滑中仍然会有变量消除"><strong>为什么在平滑中仍然会有变量消除</strong></h3><p>尽管在平滑处理中，信息矩阵维持其稀疏性质，我们仍可能需要执行某种形式的变量消除，这主要是为了效率和算法实现上的考虑。例如，在求解线性系统时（如<span class="math display">\[Ax =b\]</span>），通常会采用一些数学技术来简化问题，比如通过Cholesky分解等。在这个过程中，创建弦图和消元树是为了优化这些数学操作：</p><ol type="1"><li><p><strong>弦图的创建</strong>：在进行Cholesky分解等操作前，弦图能帮助我们识别并利用信息矩阵的稀疏结构，以减少计算过程中的填充（非零元素的添加）。</p></li><li><p><strong>消元树的建立</strong>：即便信息矩阵是稀疏的，构建消元树可以进一步提高解线性系统的效率。消元树能够指导计算顺序，确保依赖关系得到正确处理，并优化内存访问模式。</p></li></ol><p>因此，尽管平滑信息矩阵在理论上不需要通过边缘化来维护其稀疏性，但在实际计算和算法实现中，变量消除和相关的图形表示（如弦图和消元树）仍然是优化性能和保证算法效率的重要工具。</p><h3 id="消元树">消元树</h3><p>消元树是一种用来表示消除过程中变量依赖关系的树状结构，它帮助指导了矩阵分解过程中的计算流程，特别是在反向替代阶段。这里用一个具体的例子来说明这一点：</p><p>假设我们有一个系统的矩阵 <span class="math display">\[A\]</span>，我们想要进行Cholesky分解（假设<span class="math display">\[A\]</span>是对称正定的）。我们首先选择一个变量来消除，这通常是基于某种启发式方法，比如最小填充法或最小度法。</p><p>考虑以下矩阵：</p><p><span class="math display">\[A = \begin{bmatrix}4 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 4 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 4 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 3 \\\end{bmatrix}\]</span></p><p><strong>第一步：消除第一个变量</strong></p><p>我们首先消除第一个变量，这会影响与它直接相连的变量（这里是第二个变量）。消除第一个变量后，更新矩阵（做适当的行和列操作）可能会导致非零元素填充原本为零的位置，即产生“填充”。</p><p><strong>弦图的形成</strong></p><p>在这个过程中，如果我们将每个变量和与它相邻的变量视为图的一个节点和边，消除一个变量相当于在图中移除一个节点及其相关的边，并可能在未被消除的相邻节点间添加新的边（如果它们之前不直接相连）。这个操作最终形成了一个弦图，即每个循环都至少有一个弦（非环的边）的图。</p><p><strong>构建消元树</strong></p><p>在构建弦图的基础上，消元树被定义为消除过程中的依赖关系图。例如：</p><ol type="1"><li>将第一个被消除的变量作为树的根节点。</li><li>每次消除一个变量后，将受到影响的变量作为当前消除变量的子节点添加到树中。</li></ol><p>对于上面的矩阵，消元树可能如下：</p><ul><li>根节点为第一个被消除的变量。</li><li>第二个被影响的变量成为第一个节点的子节点。</li><li>依次类推，直到所有变量都被放置在树中。</li></ul><p><strong>在反向替代阶段的作用</strong></p><p>在进行例如Cholesky分解后，求解线性系统 <span class="math display">\[Ax = b\]</span> 需要先进行前代（使用 <span class="math display">\[L\]</span> 矩阵）和后代（使用 <span class="math display">\[L^T\]</span>矩阵）。在后代过程中，消元树指导了计算的顺序：从树的叶子（最先消除的变量）开始，逐步向根节点（最后消除的变量）进行，确保在计算当前变量值之前，所有依赖于它的变量值已经被计算。</p><p>通过这种方式，消元树不仅帮助优化计算过程，还确保了在计算过程中遵循正确的依赖关系，有效地利用了矩阵的稀疏性质。</p><h2 id="qr分解">QR分解</h2><p>QR 分解是将矩阵 <span class="math display">\[A\]</span>分解成一个正交矩阵 <span class="math display">\[Q\]</span>和一个上三角矩阵 <span class="math display">\[R\]</span> 的方法。如果<span class="math display">\[A\]</span> 是一个 <span class="math display">\[m \times n\]</span> 矩阵且 <span class="math display">\[m \geq n\]</span>，那么分解形式通常写为：</p><p><span class="math display">\[A = QR\]</span></p><p>其中，<span class="math display">\[Q\]</span> 是一个 <span class="math display">\[m \times m\]</span> 正交矩阵（<span class="math display">\[Q^T Q = QQ^T = I\]</span>），<span class="math display">\[R\]</span> 是一个 <span class="math display">\[m\times n\]</span> 的上三角矩阵，其中除了前 <span class="math display">\[n\]</span>行可能有非零元素外，其余部分全为零。在许多实际情况中，我们更关心 <span class="math display">\[R\]</span> 的前 <span class="math display">\[n\times n\]</span> 部分，因为它是一个完全的上三角矩阵。</p><p>为什么 <span class="math display">\[R\]</span> 下面有一个0</p><p>在 <span class="math display">\[Q^T A = \left[\begin{array}{c} R \\ 0\end{array}\right]\]</span> 的表达式中，<span class="math display">\[R\]</span> 是 <span class="math display">\[n\times n\]</span> 的上三角矩阵，而下面的0表示在 <span class="math display">\[Q^T\]</span> 作用后，剩下 <span class="math display">\[m-n\]</span> 行都被消减到了零。这是因为 <span class="math display">\[Q\]</span> 通过正交变换将 <span class="math display">\[A\]</span> 的所有向量投影到一个由 <span class="math display">\[A\]</span> 的列空间张成的正交子空间。</p><p>如何进行QR分解</p><p>QR分解可以通过多种方式进行，包括Householder反射、Gram-Schmidt正交化或Givens旋转等。其中，Householder反射是最常用的方法，因为它具有很好的数值稳定性。</p><p>Householder反射:</p><ol type="1"><li>选取一个列向量，构造一个反射矩阵 <span class="math display">\[H\]</span>，使得除了第一项外，该列的其余项变为零。</li><li>重复应用上述过程，每次将 <span class="math display">\[A\]</span>的一个列向量（逐步从左到右）变为期望的上三角形式。</li><li>通过连续左乘不同的Householder矩阵（<span class="math display">\[H_1,H_2, \ldots, H_n\]</span>），我们最终得到 <span class="math display">\[Q^T A = \left[\begin{array}{c} R \\ 0\end{array}\right]\]</span>。</li></ol><p>QR分解在最小二乘中的应用</p><p>在最小二乘问题中，我们通常要最小化 <span class="math display">\[\|A\delta -b\|_2^2\]</span>。通过QR分解，我们可以转化这个问题为：</p><p><span class="math display">\[\|Q^T(A\delta - b)\|_2^2 = \|R\delta -Q^Tb\|_2^2\]</span></p><p>由于 <span class="math display">\[Q\]</span>是正交的，所以转换不会改变二范数。因此，问题简化为最小化 <span class="math display">\[\|R\delta - d\|_2^2\]</span>（其中 <span class="math display">\[d\]</span> 是 <span class="math display">\[Q^Tb\]</span> 的前 <span class="math display">\[n\]</span> 个元素）加上 <span class="math display">\[\|e\|_2^2\]</span>（其中 <span class="math display">\[e\]</span> 是 <span class="math display">\[Q^Tb\]</span> 的剩余 <span class="math display">\[m-n\]</span> 个元素，代表方程的残差）。</p><p>由于 <span class="math display">\[R\]</span>是上三角的，这个问题可以通过反向替换直接求解 <span class="math display">\[R\delta = d\]</span>，从而找到最小二乘解 <span class="math display">\[\delta^*\]</span>。</p><h2 id="为什么用cholesky-分解求解正规方程">为什么用Cholesky分解求解正规方程</h2><p><strong>为什么使用 Cholesky 分解？</strong></p><ol type="1"><li><p><strong>效率和稳定性</strong>：</p><p>​<strong>效率</strong>：Cholesky分解相比于其他方法（如LU分解或QR分解）通常更为高效。它的计算复杂度大约是<span class="math display">\[\frac{1}{3} n^3\]</span> 对于 <span class="math display">\[n \times n\]</span>矩阵，而LU分解和QR分解的计算复杂度分别大约是 <span class="math display">\[\frac{2}{3} n^3\]</span> 和 <span class="math display">\[2n^3\]</span>。这使得Cholesky分解成为求解大型正定线性系统的首选方法。</p><p>​<strong>稳定性</strong>：对于对称正定矩阵，Cholesky分解非常稳定。由于对称性和正定性保证了分解的成功执行，它避免了在数值分解过程中的潜在不稳定性。</p></li><li><p><strong>数值属性</strong>：</p><p>​在数值线性代数中，Cholesky分解对于对称正定矩阵来说是一种数值上稳定的方法，特别是当矩阵<span class="math display">\[A^T A\]</span>的条件数相对较低时。这是因为它直接利用了矩阵的对称性和正定性。</p></li><li><p><strong>简化求解过程</strong>：</p><p>​ 通过Cholesky分解，矩阵 <span class="math display">\[A^T A\]</span>被分解为一个下三角矩阵 <span class="math display">\[L\]</span>和其转置的上三角矩阵 <span class="math display">\[L^T\]</span>的乘积，即 <span class="math display">\[A^T A = LL^T\]</span>。这种分解简化了线性系统的求解，因为只需先解下三角系统 <span class="math display">\[L \mathbf{y} = A^T \mathbf{b}\]</span>获得临时向量 <span class="math display">\[\mathbf{y}\]</span>，然后解上三角系统 <span class="math display">\[L^T \mathbf{x} = \mathbf{y}\]</span> 获取最终解<span class="math display">\[\mathbf{x}\]</span>。</p><p>​这种分步求解的过程比直接求解原方程更易于处理，并且可以有效地利用现代计算机体系结构。</p></li></ol><p><strong>总结</strong></p><p>由于上述优点，Cholesky分解成为解决正定线性系统（特别是在涉及正规方程时）的理想选择，提供了一种高效、稳定的方法来求解最小二乘问题中的线性系统。这在实际应用中，如图优化、信号处理、统计数据分析等领域，具有广泛的应用。</p><h2 id="一些相关链接-不定时更新">一些相关链接 不定时更新</h2><h3 id="可以关注的blog-多源融合">可以关注的blog 多源融合</h3><p><a href="https://www.zhihu.com/people/Welson-WEN/posts">Welson WEN -知乎 (zhihu.com)</a></p><h3 id="理论学习">理论学习</h3><h4 id="滤波优化算法">滤波优化算法</h4><p><a href="https://zhuanlan.zhihu.com/p/85865058">卡尔曼滤波：究竟滤了谁？</a></p><p><a href="https://www.zhihu.com/question/23971601/answer/770830003">关于卡尔曼滤波如何通俗并尽可能详细地解释卡尔曼滤波？ - 司南牧(李韬)的回答 -知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/76659512">SLAM找工作1.6因子图优化（蜘蛛） - 知乎 (zhihu.com)</a></p><p><a href="https://chargerkong.github.io/2021/05/26/%E5%9B%BE%E4%BC%98%E5%8C%96%EF%BC%88Graph-based%EF%BC%89/">个人github的blog估计是大学生 写得还不错</a></p><p><a href="https://zhuanlan.zhihu.com/p/404893786">GraphGNSSLib:基于因子图技术的GNSS定位和GNSS RTK定位算法</a></p><p><a href="https://www.guyuehome.com/18321">SLAM14讲学习笔记（七）后端（BA与图优化，PoseGraph优化的理论与公式详解、因子图优化）</a></p><p><a href="https://longaspire.github.io/blog/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BB%8B%E7%BB%8D/#1-%E5%9B%A0%E5%AD%90%E5%9B%BE%E5%AE%9A%E4%B9%89">因子图介绍YOLO</a></p><p><a href="https://ieeexplore.ieee.org/abstract/document/910572">因子图和求和乘积算法|IEEE期刊和杂志 |IEEE Xplore（IEEE的Xplore）</a></p><p><a href="https://blog.csdn.net/shyjhyp11/article/details/126938728">SLAM算法-因子图建模</a></p><p><a href="https://blog.csdn.net/tfb760/article/details/127118096">学习随笔：机器人感知-因子图在SLAM中的应用</a></p><p><a href="https://zhuanlan.zhihu.com/p/616060837">SLAM中后端优化的技术细节</a></p><p><a href="https://zhuanlan.zhihu.com/p/128720019">干货：因子图优化的资源合集算法发展脉络</a></p><p><a href="https://blog.51cto.com/u_16213565/7964103">计算机视觉教材</a></p><p><a href="https://zhuanlan.zhihu.com/p/30139208">概率图模型之贝叶斯网络</a></p><p><a href="https://blog.csdn.net/ljtx200888/article/details/114164685">csdn：SLAM后端：因子图优化</a></p><p><a href="https://zhuanlan.zhihu.com/p/455851874">知乎：三.因子图优化学习---董靖博士在泡泡实验室的公开课学习</a></p><p><a href="https://zhuanlan.zhihu.com/p/451555685">知乎：一.因子图优化学习---董靖博士在深蓝学院的公开课学习（1）</a></p><p><a href="https://www.bilibili.com/video/BV16p4y1U7gW/?spm_id_from=333.999.0.0&amp;vd_source=3cd19ffad1cc348f3d6969346e07e84c">贝叶斯派的概率图模型讲解概述</a></p><h3 id="代码编程">代码编程</h3><h4 id="gtsam库">GTSAM库</h4><p><a href="https://xiaotaoguo.com/">自动驾驶 C++相关</a></p><p>[<a href="https://xiaotaoguo.com/p/gtsam-usage-2/">[代码实践] GTSAM学习记录（二）]</a></p><p><a href="https://www.helywin.com/posts/20220321115224/#:~:text=%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%E7%9A%84%E5%9B%A0%E5%AD%90%E5%9B%BE%E5%A6%82%E5%9B%BE3%E6%89%80%E7%A4%BA%E3%80%82%20%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F%24x_1%24%EF%BC%8C%24x_2%24%E5%92%8C%24x_3%24%E4%BB%A3%E8%A1%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%9A%8F%E6%97%B6%E9%97%B4%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E5%9C%A8%E5%9B%BE%E4%B8%AD%E7%94%B1%E5%BC%80%E5%9C%86%E7%9A%84%E5%8F%98%E9%87%8F%E8%8A%82%E7%82%B9%E5%91%88%E7%8E%B0%E3%80%82%20%E5%9C%A8%E8%AF%A5%E4%BE%8B%E5%AD%90%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A7%BF%E6%80%81%24x_1%24%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%E4%B8%80%E5%85%83%E5%9B%A0%E5%AD%90%24f_0%20%28x_1%29%24%EF%BC%8C%E7%BC%96%E7%A0%81%E6%88%91%E4%BB%AC%E5%85%B3%E4%BA%8E%24x_1%24%E7%9A%84%E5%85%88%E9%AA%8C%E7%9F%A5%E8%AF%86%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%BA%8C%E5%85%83%E5%9B%A0%E5%AD%90%E5%B0%86%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%A7%BF%E6%80%81%E8%81%94%E7%B3%BB%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%24f_1%20%28x_1%2C%20x_2%20%3B%20o_1%29%24%E5%92%8C%24f_2,x_3%20%3B%20o_2%29%24%EF%BC%8C%E5%85%B6%E4%B8%AD%24o_1%24%E5%92%8C%24o_2%24%E4%BB%A3%E8%A1%A8%E9%87%8C%E7%A8%8B%E6%B5%8B%E9%87%8F%E5%80%BC%E3%80%82%20%E4%B8%8B%E9%9D%A2%E7%9A%84C%2B%2B%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8C%85%E5%90%AB%E5%9C%A8GTSAM%E4%B8%AD%E4%BD%9C%E4%B8%BA%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%BA%86%E5%9B%BE3%E4%B8%AD%E7%9A%84%E5%9B%A0%E5%AD%90%E5%9B%BE%EF%BC%9A%20%E4%B8%8A%E9%9D%A2%EF%BC%8C%E7%AC%AC2%E8%A1%8C%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84%E5%9B%A0%E5%AD%90%E5%9B%BE%E3%80%82%20%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E7%AC%AC5-8%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%9B%A0%E5%AD%90%24f_0%20%28x_1%29%24%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%9C%A8slam%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%2A%2A%20%E3%80%82">因子图和GTSAM--实践介绍—个人blog含代码讲解</a></p><p><a href="https://zhuanlan.zhihu.com/p/543465483">Factor Graphs andGTSAM</a></p><p><a href="https://zhuanlan.zhihu.com/c_1025765837919113216">因子图优化slam找工作</a></p><h4 id="代码能力">代码能力</h4><p><a href="https://xiaotaoguo.com/">自动驾驶 C++相关</a></p><p><a href="https://zhuanlan.zhihu.com/c_1025765837919113216">因子图优化slam找工作</a></p><p>https://www.zhihu.com/people/mach999/posts</p>]]></content>
      
      
      <categories>
          
          <category> 导航学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 因子图 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
