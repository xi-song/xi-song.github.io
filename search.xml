<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【stm32 bug那些事儿】</title>
      <link href="/2025/03/17/stm32_debug/"/>
      <url>/2025/03/17/stm32_debug/</url>
      
        <content type="html"><![CDATA[<hr><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>我打算边学边记录一下关于自己遇到的bug，后面这个文档也会不断更新</p><p>主要就是跟着网上的教程进行复现，然后找bug</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>代码不能运行，首先检查初始化！所以建议每次写完初始化的代码，都直接在main里面直接去调用。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>检查配置是否正确 虽然跟着教程做，但是会有时 A写成B B写成C这种错误 还是要好好看一看对一对 ,不要太眼高手低</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>用面包板的朋友，可能硬件会有点松动，可以晃一晃摇一摇，看看是不是硬件接触不良</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>一般而言，其实80%的问题都是自己的代码配置的问题，先怀疑一下自己的代码，然后在怀疑硬件本身的问题吧~</p><h2 id="pwm互补输出">PWM互补输出</h2><p>【bug：配置+硬件】</p><p>功能是通过TIM1的输出比较功能，输出两路互补的PWM信号，对应铁头山羊老师的<a href="https://www.bilibili.com/video/BV11X4y1j7si?spm_id_from=333.788.videopod.episodes&amp;vd_source=3cd19ffad1cc348f3d6969346e07e84c&amp;p=43">呼吸灯实验</a>刚开始一直找都找不到bug ，后面求助ai，仔细找才发现bug</p><p>整体而言实现的步骤是：</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>配置IO端口：通过数据手册看一下互补输出的端口是哪个，需不需要重映射，各个参数配置好</p><p><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503220948343.png" alt="image-20250320155200268" style="zoom:80%;"></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>配置时基单元</p><p><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503201128305.png" alt="image-20250320112808517" style="zoom:80%;"></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>配置输出比较</p><p><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503201132208.png" alt="image-20250320113231371" style="zoom:80%;"></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 主函数 ：通过控制ccr来配置占空比，实现灯的过程。</p><p>比较容易忽视的有几个点 ：<strong>配置ARR寄存器和CCR寄存器的预加载</strong>，所谓预加载的话，就是说每次更新相应的数值的时候，需要在下一次更新结束后才能生效，而不是马上生效，这样就能避免出现跑飞的情况。当然具体的话，可以看看山羊老师他前面讲的这个预加载，复习一下。</p><p><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503192122177.png" alt="image-20250319212236792" style="zoom:80%;">有bug 的代码如下，看看是否能找到bug</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">PWM_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line"><span class="type">float</span> t=GetTick()*<span class="number">1.0e-3</span>f;<span class="comment">//获取当前时间 本来为毫秒值 转为秒</span></span><br><span class="line"><span class="type">float</span> duty=<span class="number">0.5</span>*(<span class="built_in">sin</span>(<span class="number">2</span>*<span class="number">3.14</span>*t)+<span class="number">1</span>);<span class="comment">//占空比</span></span><br><span class="line"><span class="type">uint32_t</span> ccr1=duty*<span class="number">1000</span>;<span class="comment">//占空比 关于1000是持续了1000ms</span></span><br><span class="line">TIM_SetCompare1(TIM1,ccr1);<span class="comment">//TIM_SetCompare1指的是通道1 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"><span class="comment">//1.引脚配置</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">GPIO_InitTypeDef gpio_init_struct;</span><br><span class="line">gpio_init_struct.GPIO_Mode=GPIO_Mode_AF_PP;</span><br><span class="line">gpio_init_struct.GPIO_Pin=GPIO_Pin_8;</span><br><span class="line">gpio_init_struct.GPIO_Speed=GPIO_Speed_2MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;gpio_init_struct);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef gpio_init_struct1;</span><br><span class="line">gpio_init_struct1.GPIO_Mode=GPIO_Mode_AF_PP;</span><br><span class="line">gpio_init_struct1.GPIO_Pin=GPIO_Pin_13;</span><br><span class="line">gpio_init_struct1.GPIO_Speed=GPIO_Speed_2MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;gpio_init_struct1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.配置时基单元</span></span><br><span class="line"><span class="comment">//2.1</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef  TIM_TimeBaseInitStruct;</span><br><span class="line">TIM_TimeBaseInitStruct.TIM_Prescaler=<span class="number">71</span>;</span><br><span class="line">TIM_TimeBaseInitStruct.TIM_Period=<span class="number">999</span>;</span><br><span class="line">TIM_TimeBaseInitStruct.TIM_CounterMode=TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStruct.TIM_RepetitionCounter=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseInitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2.配置预加载 防止寄存器跑飞</span></span><br><span class="line">TIM_ARRPreloadConfig(TIM1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3.闭合时基单元开关</span></span><br><span class="line">TIM_Cmd(TIM1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">///3.初始化输出比较</span></span><br><span class="line"><span class="comment">//3.1输出比较参数初始化</span></span><br><span class="line">TIM_OCInitTypeDef TIM_OCInitStruct;</span><br><span class="line">TIM_OCInitStruct.TIM_OCMode=TIM_OCMode_PWM1;</span><br><span class="line">TIM_OCInitStruct.TIM_OCNPolarity=TIM_OCNPolarity_High;</span><br><span class="line">TIM_OCInitStruct.TIM_OCPolarity=TIM_OCPolarity_High;</span><br><span class="line">TIM_OCInitStruct.TIM_OutputNState=TIM_OutputState_Enable;<span class="comment">//使能互补输出</span></span><br><span class="line">TIM_OCInitStruct.TIM_OutputState=TIM_OutputState_Enable;<span class="comment">//使能正常输出</span></span><br><span class="line">TIM_OCInitStruct.TIM_Pulse=<span class="number">0</span>;<span class="comment">//CCR的初始值</span></span><br><span class="line"></span><br><span class="line">TIM_OC1Init(TIM1,&amp;TIM_OCInitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2 闭合MOE开关</span></span><br><span class="line">TIM_CtrlPWMOutputs(TIM1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.3 </span></span><br><span class="line">TIM_CCPreloadControl(TIM1,ENABLE);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><p>这次的bug主要在配置这一块</p><p><img src="D:\typora\pic\image-20250320155842068.png" alt="image-20250320155842068" style="zoom:80%;"></p><p>是的，我把他俩写成一样的了。真的无奈啊，问ai问了一大堆，结果是这个问题。</p><p>当然解决之后，我以为没问题了，但是！还是不行。于是我碰了碰LED灯，结果发现还有接触不良的问题。！！终于解决了</p><p>最终实现的效果如下！</p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503220948011.gif" alt="pwm"><figcaption aria-hidden="true">pwm</figcaption></figure><h2 id="exti中断">EXTI中断</h2><p>【bug：配置】</p><p>这次 我以为会比较快，但是还是有bug</p><hr><p>一开始是初始化没有</p><p>然后是<strong>中断回调函数写错</strong>，因为配置的是EXTI_Line0和EXTI_Line1两个都差不多，但是最后复制过来复制过去 最终回调函数都给复制过去了找了很久</p><p>还有就是配置NVIC的时候不能用 |一起配置，<strong>要分开配置</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置NVIC模块</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel=EXTI4_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=<span class="number">0</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority=<span class="number">0</span>;<span class="comment">//子优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line"></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel=EXTI1_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=<span class="number">0</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority=<span class="number">0</span>;<span class="comment">//子优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br></pre></td></tr></tbody></table></figure><p>整体配置的图</p><p><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503190946812.png" alt="image-20250319094104401" style="zoom:67%;"></p><p><strong>效果：</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503192127587.gif" alt="exti"><figcaption aria-hidden="true">exti</figcaption></figure><p>最终核心代码如下</p><p>exti和nvic配置</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">My_EXTI_Init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"><span class="comment">//开启AFIO 选择端口</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line"><span class="comment">//选择EXTI line 1 4</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource1|GPIO_PinSource4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置线的参数</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStruct;</span><br><span class="line"></span><br><span class="line">EXTI_InitStruct.EXTI_Line=EXTI_Line1;</span><br><span class="line">EXTI_InitStruct.EXTI_LineCmd=ENABLE;</span><br><span class="line">EXTI_InitStruct.EXTI_Mode=EXTI_Mode_Interrupt;</span><br><span class="line">EXTI_InitStruct.EXTI_Trigger=EXTI_Trigger_Rising;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStruct);</span><br><span class="line"></span><br><span class="line">EXTI_InitStruct.EXTI_Line=EXTI_Line4;</span><br><span class="line">EXTI_InitStruct.EXTI_LineCmd=ENABLE;</span><br><span class="line">EXTI_InitStruct.EXTI_Mode=EXTI_Mode_Interrupt;</span><br><span class="line">EXTI_InitStruct.EXTI_Trigger=EXTI_Trigger_Rising;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStruct);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置NVIC模块</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel=EXTI4_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=<span class="number">0</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority=<span class="number">0</span>;<span class="comment">//子优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel=EXTI1_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=<span class="number">0</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority=<span class="number">0</span>;<span class="comment">//子优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>中断回调函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"><span class="keyword">if</span>(EXTI_GetFlagStatus(EXTI_Line1)==SET){</span><br><span class="line">EXTI_ClearFlag(EXTI_Line1);</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_SET);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"><span class="keyword">if</span>(EXTI_GetFlagStatus(EXTI_Line4)==SET){</span><br><span class="line">EXTI_ClearFlag(EXTI_Line4);</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_RESET);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="spi通信代码">SPI通信代码</h2><p>见上一篇笔记找的bug</p><h2 id="中断串口中断">中断+串口中断</h2><p>【bug：逻辑】</p><p>对应铁头山羊中断那一章节。</p><p>这个应该是很简单的，配置一下中断串口什么的，但是我居然出不来，过了一上午才知道，原来是中断函数那边出了问题</p><p>功能是通过串口输入的数字，来改变板子上灯的闪动的频率。</p><p>就是这个 void USART1_IRQHandler(void)！ 来，看一下什么问题</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"><span class="comment">//一定注意 中断的话 需要在在里面接收数据 不然是不会变化的</span></span><br><span class="line"><span class="type">uint8_t</span> byte=USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>((USART_GetITStatus(USART1,USART_IT_RXNE))==SET){</span><br><span class="line"><span class="keyword">if</span>(byte==<span class="string">'0'</span>) time=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span>(byte==<span class="string">'1'</span>)  time=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">if</span>(byte==<span class="string">'2'</span>)  time=<span class="number">50</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>更改版本是这样的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"><span class="comment">//一定注意 中断的话 需要在在里面接收数据 不然是不会变化的</span></span><br><span class="line"><span class="type">uint8_t</span> byte;</span><br><span class="line"><span class="keyword">if</span>((USART_GetITStatus(USART1,USART_IT_RXNE))==SET){</span><br><span class="line">byte=USART_ReceiveData(USART1);</span><br><span class="line"><span class="keyword">if</span>(byte==<span class="string">'0'</span>) time=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span>(byte==<span class="string">'1'</span>)  time=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">if</span>(byte==<span class="string">'2'</span>)  time=<span class="number">50</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>也就是说，这个USART_ReceiveData(USART1);需要实时更新不然，还是不行，接受不了数据，就无法进行判别。</p><p>所以下次一定记得！！</p><p>配上void Usart_Init(void)配置的过程</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Usart_Init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line"><span class="comment">//初始化IO引脚 PA9 TX 复用推挽输出   PA10 RX 上拉输入</span></span><br><span class="line">GPIO_InitTypeDef gpio_init_struct;</span><br><span class="line">gpio_init_struct.GPIO_Mode=GPIO_Mode_AF_PP;</span><br><span class="line">gpio_init_struct.GPIO_Pin=GPIO_Pin_9;</span><br><span class="line">gpio_init_struct.GPIO_Speed=GPIO_Speed_2MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;gpio_init_struct);</span><br><span class="line"></span><br><span class="line">gpio_init_struct.GPIO_Mode=GPIO_Mode_IPU;</span><br><span class="line">gpio_init_struct.GPIO_Pin=GPIO_Pin_10;</span><br><span class="line">GPIO_Init(GPIOA,&amp;gpio_init_struct);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化串口</span></span><br><span class="line">USART_InitTypeDef USART_InitStruct;</span><br><span class="line">USART_InitStruct.USART_BaudRate=<span class="number">115200</span>;</span><br><span class="line">USART_InitStruct.USART_HardwareFlowControl=USART_HardwareFlowControl_None;</span><br><span class="line">USART_InitStruct.USART_Mode=USART_Mode_Rx|USART_Mode_Tx;</span><br><span class="line">USART_InitStruct.USART_Parity=USART_Parity_No;</span><br><span class="line">USART_InitStruct.USART_StopBits=USART_StopBits_1;</span><br><span class="line">USART_InitStruct.USART_WordLength=USART_WordLength_8b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启中断  </span></span><br><span class="line">USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置NVIC模块</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=<span class="number">0</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority=<span class="number">0</span>;<span class="comment">//子优先级</span></span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32学习】SPI通信</title>
      <link href="/2025/03/16/STM32-SPI%E9%80%9A%E4%BF%A1/"/>
      <url>/2025/03/16/STM32-SPI%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="引子">引子</h2><p>最近跟着b站铁头山羊在学stm32单片机，目前学到SPI通信，主要就是想记录一下整个复现代码的过程，然后后面可以积累一些经验。这个up讲的很通俗，推荐大家去看看。</p><p><a href="https://www.bilibili.com/video/BV11X4y1j7si?spm_id_from=333.788.videopod.episodes&amp;vd_source=3cd19ffad1cc348f3d6969346e07e84c&amp;p=28">铁头山羊stm32学习</a></p><p>首先刚开始我跟着他敲是完全没有完成的，明白一点说就是代码复现不了，啥都没有。然后只能回看回看，再回看。</p><p>直到晚上，我才发现了所有的bug。。。。</p><p>其实80%的问题都是自己的代码配置的问题，先怀疑一下自己的代码，然后在怀疑硬件本身的问题吧~</p><h2 id="关于bug-的解决">关于bug 的解决</h2><hr><p>我这边bug主要在哪个地方呢？</p><p>在没有解决这些bug之前，我的代码时卡死在读RXNE标志位，是否变成了非空，一直在那循环。我就觉得不对劲，后来发现：</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>第一个就是引脚配置，PB5 PB3虽然他俩都是AF_PP输出的模式，我真的就直接复制了，居然没有改引脚名！</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>第二个，没有初始化SPI的时钟，多么离谱。只是因为up在讲解的时候没有特地讲，但是他的代码实际上是配置了的，所以我就忽略了，太离谱了。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>第三个，在写spi通信的过程的buffer，明明应该是buffer[0]=0x03,buffer[1]=0x00,这种形式，我居然写成了索引全是buffer[0]。</p><p>以上bug发现完了我以为结束了，其实没有。</p><p>然后 代码情况是，不管我发什么，接收回来的都是0。</p><hr><p>经过挣扎，我再去看了一遍代码，仔仔细细。结果发现：</p><p>原来是我用的端口PA15，他是默认JTAG的端口，要给他失能，虽然当时up提了，但是我还是水灵灵地给他最后disable，虽然前面一个参数带了disable。</p><hr><p>最后终于可以了！！！</p><h2 id="回顾一下spi通信的过程">回顾一下spi通信的过程！</h2><p>首先总结一下，无论是什么通信，都一般有几部分</p><p>1.时钟开启</p><p>2.端口初始化（这个功能要用到哪些端口</p><p>3.功能配置（比如spi功能的配置 你需要了解一下这些功能的参数表示什么有什么用</p><p>4.根据上述配置好的，进行逻辑功能的编写</p><h3 id="主要代码">主要代码</h3><p>主要功能：向flash里面写一个数据，然后再从这个flash里面把数据读出来，整个过程通过串口进行显示</p><p>主要的代码放在下面了，亲测有效</p><h4 id="main.c">main.c</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> a=<span class="number">4</span>;</span><br><span class="line">Usart_Init();</span><br><span class="line">MY_SPI_Init();</span><br><span class="line">My_USART_Printf(USART1,<span class="string">"%d\r\n"</span>,a);</span><br><span class="line">Myy_W25Q16_SaveByte(<span class="number">0x09</span>);</span><br><span class="line">a=Myy_W25Q16_LoadByte();</span><br><span class="line">My_USART_Printf(USART1,<span class="string">"%d\r\n"</span>,a);</span><br></pre></td></tr></tbody></table></figure><h4 id="void-my_spi_initvoid">void MY_SPI_Init(void)</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MY_SPI_Init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"><span class="comment">//1.初始化引脚</span></span><br><span class="line"><span class="comment">//重映射</span></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef gpio_structure;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SPI1,ENABLE);</span><br><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//PB3 SCK AF_PP  2MHz </span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">gpio_structure.GPIO_Mode=GPIO_Mode_AF_PP;</span><br><span class="line">gpio_structure.GPIO_Pin=GPIO_Pin_3;</span><br><span class="line">gpio_structure.GPIO_Speed=GPIO_Speed_2MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;gpio_structure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//PB4 MISO IPU  2MHz </span></span><br><span class="line">gpio_structure.GPIO_Mode=GPIO_Mode_IPU;</span><br><span class="line">gpio_structure.GPIO_Pin=GPIO_Pin_4;</span><br><span class="line">GPIO_Init(GPIOB,&amp;gpio_structure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//PB5 MOSI PP  2MHz </span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">gpio_structure.GPIO_Mode=GPIO_Mode_AF_PP;</span><br><span class="line">gpio_structure.GPIO_Pin=GPIO_Pin_5;</span><br><span class="line">gpio_structure.GPIO_Speed=GPIO_Speed_2MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;gpio_structure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//PA15 NSS PP  2MHz </span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">gpio_structure.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">gpio_structure.GPIO_Pin=GPIO_Pin_15;</span><br><span class="line">gpio_structure.GPIO_Speed=GPIO_Speed_2MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;gpio_structure);</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. SPI本身进行初始化</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SPI_InitTypeDef spi_initStruct;</span><br><span class="line">spi_initStruct.SPI_Mode=SPI_Mode_Master;<span class="comment">//主机模式</span></span><br><span class="line">spi_initStruct.SPI_DataSize=SPI_DataSize_8b;</span><br><span class="line"><span class="comment">//mode 0 根据W25Q16芯片手册</span></span><br><span class="line">spi_initStruct.SPI_CPOL=SPI_CPOL_Low;<span class="comment">//时钟极性,空闲状态下时钟的极性</span></span><br><span class="line">spi_initStruct.SPI_CPHA=SPI_CPHA_1Edge;<span class="comment">//时钟相位 接收方何时进行采集</span></span><br><span class="line">spi_initStruct.SPI_FirstBit=SPI_FirstBit_MSB;<span class="comment">//数据传输</span></span><br><span class="line">spi_initStruct.SPI_Direction=SPI_Direction_2Lines_FullDuplex;<span class="comment">//通信方向 两线全双工</span></span><br><span class="line">spi_initStruct.SPI_BaudRatePrescaler=SPI_BaudRatePrescaler_256;</span><br><span class="line">spi_initStruct.SPI_NSS=SPI_NSS_Soft;</span><br><span class="line">SPI_Init(SPI1,&amp;spi_initStruct);</span><br><span class="line"></span><br><span class="line">SPI_NSSInternalSoftwareConfig(SPI1,SPI_NSSInternalSoft_Set);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-myy_spi_mastertransmitreceivespi_typedef-spix-uint8_t-pdatatxuint8_t-pdatarxuint16_t-size">voidMyy_SPI_MasterTransmitReceive(SPI_TypeDef <em>SPIx, uint8_t</em>pDataTx,uint8_t *pDataRx,uint16_t Size)</h4><p>这一块就是spi数据数据发送和接收的过程，要注意的是spi通信这边设置的是全双工的通信，所以每次发送一个数据就会对应接收到一个数据。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Myy_SPI_MasterTransmitReceive</span><span class="params">(SPI_TypeDef *SPIx, <span class="type">uint8_t</span> *pDataTx,<span class="type">uint8_t</span> *pDataRx,<span class="type">uint16_t</span> Size)</span>{</span><br><span class="line"><span class="comment">//1.闭合总开关</span></span><br><span class="line">SPI_Cmd(SPIx,ENABLE);</span><br><span class="line"><span class="comment">//2.写入第一个字节</span></span><br><span class="line">SPI_I2S_SendData(SPIx,pDataTx[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uint16_t</span> i=<span class="number">0</span>;i&lt;Size<span class="number">-1</span>;i++){</span><br><span class="line"><span class="comment">//发送一个字节</span></span><br><span class="line"><span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPIx,SPI_I2S_FLAG_TXE)==RESET);</span><br><span class="line">SPI_I2S_SendData(SPIx,pDataTx[i+<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//接收一个字节</span></span><br><span class="line"><span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPIx,SPI_I2S_FLAG_RXNE)==RESET);</span><br><span class="line">pDataRx[i]=SPI_I2S_ReceiveData(SPIx);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//4.读出最后的一个字节</span></span><br><span class="line"><span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPIx,SPI_I2S_FLAG_RXNE)==RESET);</span><br><span class="line">pDataRx[Size<span class="number">-1</span>]=SPI_I2S_ReceiveData(SPIx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.断开总开关</span></span><br><span class="line">SPI_Cmd(SPIx,DISABLE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="void-myy_w25q16_savebyteuint8_t-byte">voidMyy_W25Q16_SaveByte(uint8_t Byte)</h4><p><strong>这一块比较重要</strong> 函数是向W25Q16去写数据</p><p>主要是和spi通信的过程</p><p>通俗总结一下就是<strong>发一个指令</strong>（这个指令要在对应从设备的手册去找，让主机给它发送指令，建立通信关系）+<strong>这个指令对应的地址</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Myy_W25Q16_SaveByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>{</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.写使能  向主机发0x06 查询手册</span></span><br><span class="line">buffer[<span class="number">0</span>]=<span class="number">0x06</span>;</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_RESET);<span class="comment">//选中 NSS=0</span></span><br><span class="line">Myy_SPI_MasterTransmitReceive(SPI1,buffer,buffer,<span class="number">1</span>);<span class="comment">//通过SPI通信</span></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_SET);<span class="comment">//取消选中 NSS=1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.扇区擦除</span></span><br><span class="line"><span class="comment">//主机发0x20+24位地址</span></span><br><span class="line">buffer[<span class="number">0</span>]=<span class="number">0x20</span>;</span><br><span class="line">buffer[<span class="number">1</span>]=<span class="number">0x00</span>;</span><br><span class="line">buffer[<span class="number">2</span>]=<span class="number">0x00</span>;</span><br><span class="line">buffer[<span class="number">3</span>]=<span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_RESET);<span class="comment">//选中 NSS=0</span></span><br><span class="line">Myy_SPI_MasterTransmitReceive(SPI1,buffer,buffer,<span class="number">4</span>);<span class="comment">//通过SPI通信</span></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_SET);<span class="comment">//取消选中 NSS=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.等待空闲 查询busy标志位</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_RESET);<span class="comment">//选中 NSS=0</span></span><br><span class="line">buffer[<span class="number">0</span>]=<span class="number">0x05</span>;</span><br><span class="line">Myy_SPI_MasterTransmitReceive(SPI1,buffer,buffer,<span class="number">1</span>);<span class="comment">//写0x05</span></span><br><span class="line">buffer[<span class="number">0</span>]=<span class="number">0xff</span>;</span><br><span class="line">Myy_SPI_MasterTransmitReceive(SPI1,buffer,buffer,<span class="number">1</span>);<span class="comment">//读状态寄存器1的当前值 buffer0</span></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_SET);<span class="comment">//取消选中 NSS=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//busy标志位是第一位 从1变成0 就退出</span></span><br><span class="line"><span class="keyword">if</span>((buffer[<span class="number">0</span>]&amp;<span class="number">0x01</span>)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//4.写使能</span></span><br><span class="line">buffer[<span class="number">0</span>]=<span class="number">0x06</span>;</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_RESET);<span class="comment">//选中 NSS=0</span></span><br><span class="line">Myy_SPI_MasterTransmitReceive(SPI1,buffer,buffer,<span class="number">1</span>);<span class="comment">//通过SPI通信</span></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_SET);<span class="comment">//取消选中 NSS=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.页编程</span></span><br><span class="line">buffer[<span class="number">0</span>]=<span class="number">0x02</span>;</span><br><span class="line">buffer[<span class="number">1</span>]=<span class="number">0x00</span>;</span><br><span class="line">buffer[<span class="number">2</span>]=<span class="number">0x00</span>;</span><br><span class="line">buffer[<span class="number">3</span>]=<span class="number">0x00</span>;</span><br><span class="line">buffer[<span class="number">4</span>]=Byte;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_RESET);<span class="comment">//选中 NSS=0</span></span><br><span class="line">Myy_SPI_MasterTransmitReceive(SPI1,buffer,buffer,<span class="number">5</span>);<span class="comment">//发送5个字节</span></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_SET);<span class="comment">//取消选中 NSS=1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.等待空闲</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_RESET);<span class="comment">//选中 NSS=0</span></span><br><span class="line">buffer[<span class="number">0</span>]=<span class="number">0x05</span>;</span><br><span class="line">Myy_SPI_MasterTransmitReceive(SPI1,buffer,buffer,<span class="number">1</span>);<span class="comment">//写0x05</span></span><br><span class="line">buffer[<span class="number">0</span>]=<span class="number">0xff</span>;</span><br><span class="line">Myy_SPI_MasterTransmitReceive(SPI1,buffer,buffer,<span class="number">1</span>);<span class="comment">//读状态寄存器1的当前值 buffer0</span></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_SET);<span class="comment">//取消选中 NSS=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//busy标志位是第一位</span></span><br><span class="line"><span class="keyword">if</span>((buffer[<span class="number">0</span>]&amp;<span class="number">0x01</span>)==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="uint8_t-myy_w25q16_loadbytevoid">uint8_tMyy_W25Q16_LoadByte(void)</h4><p>把对应的地址上的数据读出来</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">Myy_W25Q16_LoadByte</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//发送0x03+24位地址，然后读取数据</span></span><br><span class="line">buffer[<span class="number">0</span>]=<span class="number">0x03</span>;</span><br><span class="line">buffer[<span class="number">1</span>]=<span class="number">0x00</span>;</span><br><span class="line">buffer[<span class="number">2</span>]=<span class="number">0x00</span>;</span><br><span class="line">buffer[<span class="number">3</span>]=<span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_RESET);<span class="comment">//选中 NSS=0</span></span><br><span class="line">Myy_SPI_MasterTransmitReceive(SPI1,buffer,buffer,<span class="number">4</span>);<span class="comment">//写数据</span></span><br><span class="line"></span><br><span class="line">buffer[<span class="number">0</span>]=<span class="number">0xff</span>;</span><br><span class="line">Myy_SPI_MasterTransmitReceive(SPI1,buffer,buffer,<span class="number">1</span>);<span class="comment">//读数据</span></span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_15,Bit_SET);<span class="comment">//取消选中 NSS=1</span></span><br><span class="line">c</span><br><span class="line"><span class="keyword">return</span> buffer[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">}<span class="comment">//把保存的字节读出来</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><p>网络比较慢的家人图片可能加载不出来，可以上个“魔法”试试</p><h2 id="spi基本原理">SPI基本原理</h2><h3 id="电路结构">电路结构</h3><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162024951.png" alt="image-20250308135405908"><figcaption aria-hidden="true">image-20250308135405908</figcaption></figure><p>一主多从</p><p>MOSI</p><p>MISO</p><p>SCK</p><p>NSS（低电压被选中）</p><h3 id="通信流程">通信流程</h3><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162024157.png" alt="image-20250308135543726"><figcaption aria-hidden="true">image-20250308135543726</figcaption></figure><p>SPI发送数据和接收数据时同时</p><h5 id="时钟信号的极性">时钟信号的极性</h5><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025440.png" alt="image-20250308135728649"><figcaption aria-hidden="true">image-20250308135728649</figcaption></figure><p><strong>在空闲状态下，SCK上是低电压，就是低级性；如果SCK是高电压，就是高极性</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025086.png" alt="image-20250308135912783"><figcaption aria-hidden="true">image-20250308135912783</figcaption></figure><h5 id="相位">相位</h5><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025843.png" alt="image-20250308140055333"><figcaption aria-hidden="true">image-20250308140055333</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025313.png" alt="image-20250308160944828"><figcaption aria-hidden="true">image-20250308160944828</figcaption></figure><h5 id="种时钟模式">4种时钟模式</h5><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025453.png" alt="image-20250308161017753"><figcaption aria-hidden="true">image-20250308161017753</figcaption></figure><h5 id="比特位传输顺序">比特位传输顺序</h5><p>LSB MSB</p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025105.png" alt="image-20250308161046611"><figcaption aria-hidden="true">image-20250308161046611</figcaption></figure><h5 id="数据宽度">数据宽度</h5><p><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503081611380.png" alt="image-20250308161122041" style="zoom:80%;"></p><h3 id="spi-端口配置">SPI 端口配置</h3><p>IO引脚的输入输出模式</p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025048.png" alt="image-20250310215611245"><figcaption aria-hidden="true">image-20250310215611245</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025495.png" alt="image-20250310215647448"><figcaption aria-hidden="true">image-20250310215647448</figcaption></figure><p>MISO</p><p>MOSI</p><p>SCK</p><p>NSS</p><h3 id="spi模式配置">SPI模式配置</h3><p>主要的电路</p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025794.png" alt="image-20250315210055911"><figcaption aria-hidden="true">image-20250315210055911</figcaption></figure><h4 id="spi通信方向">SPI通信方向</h4><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025934.png" alt="image-20250315210800145"><figcaption aria-hidden="true">image-20250315210800145</figcaption></figure><h4 id="关于spi的参数">关于spi的参数</h4><p>要看具体的flash模块的说明书 instruction部分</p><p>如：</p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025782.png" alt="image-20250315212238282"><figcaption aria-hidden="true">image-20250315212238282</figcaption></figure><h4 id="spi模块-nss信号线">spi模块 NSS信号线</h4><p><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503152124191.png" alt="image-20250315212422627" style="zoom:80%;"></p><p>作为从机：接入高电压</p><p>硬件NSS外部配置 直接拉到3.3</p><p>也可以软件NSS 写1</p><p>SPI_NSSInternalSoftwareConfig(SPI1,SPI_NSSInternalSoft_Set);</p><h3 id="spi数据收发">SPI数据收发</h3><h4 id="数据收发的特点">数据收发的特点</h4><p>双向的同时的，每发送一个bit必然接受一个bit</p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025871.png" alt="image-20250315212757809"><figcaption aria-hidden="true">image-20250315212757809</figcaption></figure><h4 id="数据收发原理">数据收发原理</h4><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025092.png" alt="image-20250315213301416"><figcaption aria-hidden="true">image-20250315213301416</figcaption></figure><p>具体的编程</p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025927.png" alt="image-20250315213625345"><figcaption aria-hidden="true">image-20250315213625345</figcaption></figure><h3 id="w25q64实验">W25Q64实验</h3><p>注意，我这边实际应用到的是W25Q16模块</p><h4 id="w25q64内部结构">W25Q64内部结构</h4><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025052.png" alt="image-20250316092830017"><figcaption aria-hidden="true">image-20250316092830017</figcaption></figure><h4 id="使用模块写数据">使用模块写数据</h4><p><strong>扇区擦除 页编程</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025003.png" alt="image-20250316092900333"><figcaption aria-hidden="true">image-20250316092900333</figcaption></figure><h5 id="写使能">写使能</h5><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025816.png" alt="image-20250316113355377"><figcaption aria-hidden="true">image-20250316113355377</figcaption></figure><h5 id="扇区擦除">扇区擦除</h5><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025387.png" alt="image-20250316113552252"><figcaption aria-hidden="true">image-20250316113552252</figcaption></figure><h5 id="等待空闲">等待空闲</h5><p>等待扇区擦除指令完成</p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025187.png" alt="image-20250316113757183"><figcaption aria-hidden="true">image-20250316113757183</figcaption></figure><h5 id="页编程">页编程</h5><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025381.png" alt="image-20250316113930442"><figcaption aria-hidden="true">image-20250316113930442</figcaption></figure><h4 id="使用模块读数据">使用模块读数据</h4><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202503162025013.png" alt="image-20250316114156038"><figcaption aria-hidden="true">image-20250316114156038</figcaption></figure><h3 id="小应用">小应用</h3><h4 id="按键串口">按键+串口</h4><p>先铺垫一下按键和串口 也发到了csdn上</p><p>主要功能是：按键按一下，串口输出的数字+1，双击则清零，长按则持续加1</p><p><a href="https://blog.csdn.net/qq_53131867/article/details/146148064?spm=1001.2014.3001.5501">按键+串口</a></p><p><strong>main函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">LED_Key_Init();</span><br><span class="line">Usart_Init();</span><br><span class="line">Button_Init();</span><br><span class="line"><span class="type">int</span> click=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">click=Get_Cilcks();</span><br><span class="line">Key_Usart_2(click);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>int Get_Cilcks(void)函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Get_Cilcks</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line"><span class="type">uint16_t</span> cur=SET,pre=SET;</span><br><span class="line">cur=Key_Status;</span><br><span class="line"><span class="type">int</span> click=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> now = GetTick();</span><br><span class="line"><span class="type">int</span> time=<span class="number">300</span>;</span><br><span class="line"><span class="keyword">while</span>(GetTick()-now&lt;time){</span><br><span class="line">cur=Key_Status;</span><br><span class="line"><span class="keyword">if</span>(cur!=pre){</span><br><span class="line"><span class="keyword">if</span>(Key_Status==RESET){</span><br><span class="line">Delay(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">if</span>(Key_Status==RESET){</span><br><span class="line">now=GetTick();</span><br><span class="line">click++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(click&gt;<span class="number">3</span>){</span><br><span class="line">cnt++;</span><br><span class="line">My_USART_Printf(USART1,<span class="string">"%d\r\n"</span>,cnt);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">pre=cur;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> click;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>void Key_Usart_2(int click)函数</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Usart_2</span><span class="params">(<span class="type">int</span> click)</span>{</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> currentTime = GetTick(); <span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="type">int</span> cur=Key_Status;</span><br><span class="line"><span class="keyword">switch</span>(click){</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">cnt++;</span><br><span class="line">My_USART_Printf(USART1,<span class="string">"%d\r\n"</span>,cnt);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">My_USART_Printf(USART1,<span class="string">"%d\r\n"</span>,cnt);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="按键ledw25q16">按键+LED+W25Q16</h4><p>记录上一次LED的亮灭情况 然后读写flash 掉电不丢失</p><h5 id="main.c-1">main.c</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LED_Key_Init();</span><br><span class="line">MY_SPI_Init();</span><br><span class="line"><span class="type">int</span> pre_status=Bit_SET,cur_status=Bit_SET;</span><br><span class="line"><span class="type">uint8_t</span> a=Myy_W25Q16_LoadByte();</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0x12</span>) GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_SET);<span class="comment">//灯亮</span></span><br><span class="line"><span class="keyword">else</span> GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_RESET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">pre_status=cur_status;</span><br><span class="line">cur_status=GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1);<span class="comment">//读取按键的状态</span></span><br><span class="line"><span class="keyword">if</span>(pre_status!=cur_status){</span><br><span class="line"><span class="keyword">if</span>(cur_status==Bit_SET){<span class="comment">//当前按键处于未被按下的状态 灯变化</span></span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadOutputDataBit(GPIOC,GPIO_Pin_13)==Bit_RESET){</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_SET);<span class="comment">//灯亮</span></span><br><span class="line">Myy_W25Q16_SaveByte(<span class="number">0x12</span>);</span><br><span class="line">}<span class="comment">//读取LED灯所在引脚的输出状态</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_RESET);</span><br><span class="line">Myy_W25Q16_SaveByte(<span class="number">0x02</span>);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">Delay(<span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPI </tag>
            
            <tag> STM32F1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于OB-GINS在VScode调试配置设置</title>
      <link href="/2024/10/22/debug/"/>
      <url>/2024/10/22/debug/</url>
      
        <content type="html"><![CDATA[<h1 id="关于ob-gins在vscode调试配置设置">关于OB-GINS在VScode调试配置设置</h1><p>系统是Ubuntu18.04 然后其他都是按照牛老师团队整个代码的要求配置的</p><p>因为看这个代码比较困难，所以想着边调试边看代码这样会不会好一点，于是就有了这篇blog！！</p><p>这个blog记录一下本人首次在vscode调试配置成果叭 呜呜呜呜呜</p><p>然后也看了一堆教程，还有blog 终于终于啊！！</p><p>分享一下</p><h2 id="资料和问题">资料和问题</h2><p><a href="https://blog.csdn.net/qq_48383456/article/details/135651139">利用cmake配置VScode的C++运行与调试环境</a></p><p><a href="https://blog.csdn.net/qq_51303289/article/details/128687710">VSCode使用CMake进行断点调试（超详细）</a></p><p><a href="https://www.bilibili.com/video/BV1fy4y1b7TC/?p=23&amp;spm_id_from=333.880.my_history.page.click&amp;vd_source=8bb3a4bcaa31eb085c58ae21b5e131fe">b站cmake配置视频</a></p><p>然后是在linux下，进行配置时候，出现的一些bug</p><p>比如在控制台下可以进行编译配置成功，但是在vscode里面就会有红线，而且会提示找不到的情况，这个时候，参考了一个blog 但是这个blog我目前找不到了 呜呜呜，结论如下了</p><p>也就是在配置文件，setting.json里面加入这一句话，即可：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"C_Cpp.default.configurationProvider"</span>: <span class="string">"ms-vscode.cmake-tools"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="配置文件">配置文件</h2><p>关于在.vsocde里面的配置文件，可以参考上面的视频，然后配置文件无脑参考我的就可：</p><h3 id="sailboat-launch.json"><span class="github-emoji" style="display:inline;vertical-align:middle"><span>⛵</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26f5.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> launch.json</h3><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"0.2.0"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"configurations"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        </span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"ob_gins-gdb"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"cppdbg"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"request"</span><span class="punctuation">:</span> <span class="string">"launch"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"program"</span><span class="punctuation">:</span> <span class="string">"${workspaceFolder}/bin/ob_gins"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"args"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">"${workspaceFolder}/dataset/ob_gins.yaml"</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"stopAtEntry"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"cwd"</span><span class="punctuation">:</span> <span class="string">"${workspaceFolder}"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"environment"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"externalConsole"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"MIMode"</span><span class="punctuation">:</span> <span class="string">"gdb"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"setupCommands"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">{</span></span><br><span class="line">                    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"为 gdb 启用整齐打印"</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">"text"</span><span class="punctuation">:</span> <span class="string">"-enable-pretty-printing"</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">"ignoreFailures"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">{</span></span><br><span class="line">                    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">"将反汇编风格设置为 Intel"</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">"text"</span><span class="punctuation">:</span> <span class="string">"-gdb-set disassembly-flavor intel"</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">"ignoreFailures"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">}</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"preLaunchTask"</span><span class="punctuation">:</span> <span class="string">"Build"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// "miDebuggerArgs": "-q -ex quit; wait() { fg &gt;/dev/null; }; /bin/gdb -q --interpreter=mi"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="palm_tree-task.json"><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f334.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> task.json</h3><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span>   </span><br><span class="line">    <span class="attr">"options"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">                <span class="attr">"cwd"</span><span class="punctuation">:</span> <span class="string">"${workspaceFolder}/build"</span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"2.0.0"</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">"tasks"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"shell"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"label"</span><span class="punctuation">:</span> <span class="string">"cmake"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"command"</span><span class="punctuation">:</span> <span class="string">"cmake"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"args"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">"../"</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">"-DCMAKE_BUILD_TYPE=Debug"</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">"-DCMAKE_C_COMPILER=gcc-8"</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">"-DCMAKE_CXX_COMPILER=g++-8"</span></span><br><span class="line"></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">           </span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"label"</span><span class="punctuation">:</span> <span class="string">"make"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"group"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">                <span class="attr">"kind"</span><span class="punctuation">:</span> <span class="string">"build"</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">"isDefault"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"command"</span><span class="punctuation">:</span> <span class="string">"make"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"args"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">"-j"</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">"2"</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">           </span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"label"</span><span class="punctuation">:</span> <span class="string">"Build"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"dependsOrder"</span><span class="punctuation">:</span> <span class="string">"sequence"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"dependsOn"</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">                <span class="string">"cmake"</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">"make"</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  </span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="总结">总结</h3><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>主要是第一个 setting文件最后加上</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"C_Cpp.default.configurationProvider"</span>: <span class="string">"ms-vscode.cmake-tools"</span></span><br></pre></td></tr></tbody></table></figure><p>这样就不会找不到头文件 也不会标红</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>两个配置文件的填写配置</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>然后出现断点变灰，或者不可用的可能性是cmakelist文件里面没有采用debug模式，这个时候需要进行手动设置，或者把调用的参数改一下，比如我配置的task文件里面，就把整个模式改成了debug的模式。​</p><p>okok，完结完结~~</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> VSCODE调试配置 </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++零碎知识点记录</title>
      <link href="/2024/10/06/C_C++%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/10/06/C_C++%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="cc知识点零碎记录">C/C++知识点零碎记录</h1><blockquote><p>记录本人日常比较难理解的知识点 不定时更新</p></blockquote><h2 id="每天读一遍">每天读一遍</h2><ol type="1"><li><p>vector就是特殊的数组，它的每个子单元都是特定的类型——==<strong>每个子单元左右是紧密连接的无空隙</strong>==</p></li><li><p>对一族类处理的情况，一般来说都不会往vector里面放对象本身，因为它们往往具有大小上的不同且vector只能保存同一类型；假设要把对象全部放进vector里，此时一般也只能放基类。这就会导致派生类超出基类的内容全部被截断——所以一般会往vector里面放类型一致的，大小一致的指针类型。而该类对象要么是在函数内声明创建的（也就是存储在栈上）要么就是通过new或malloc等创建的在堆上创建的对象。</p></li><li><p>为了便于批量处理，会把一族变量的指针放在同一个vector里面。因为派生类往往所具有基类不具有的内容，所以往往使用的是基类指针，即在vector里面保存的是基类指针。此时，我们可以通过基类指针调用本族类的通用方法，这件事情没有什么异议。而我们还需要通过基类指针调用同名但在基类和派生类中实现不同的方法，此时我们就需要用虚拟函数，也就是——</p><blockquote><p>基本应用场景：一个类的族（一个基类和其他派生类，所有的类都包含在这个族里），在C++里可以用一个vector存放不同类的指针，但是存进去的适合需要同一种类型的指针（强制转换），在此其间都会普遍采用存放基类的指针，因为每一个类都包含这一部分，将它们放在vector的主要原因是，它们有同一个基类，可以进行同样的处理。也就是，可以调用基类就存在的函数，比如说一个动物类，vector存的是动物园的所有动物的指针，现在模拟饲养员对每种动物的喂食、环境清理。像环境清理可以采用同一个基类函数，但是喂养的话，不同的动物需要不同的食物。所以需要定义分别定义不同的喂养函数。为了便于批量处理，即统一管理，C++新增了虚拟函数。这种函数的特性是，其基类写了这个函数给了这个函数定义，其派生类也可以给这个函数自己的定义，基类和派生类有各自自己的实现。</p><p>在C++里有一个共同的前提，即派生类可以截断成基类，也就是前面所说的，把各动物指针放在vector里，在解引用这种指针后，将获得一般性vector的内容。此时，若调用一般性的函数，也就会直接调用基类自己调用的函数。而如果调用虚拟函数，它就会调用这个指针它的实际类型重新定义的虚拟函数，前者对应打扫卫生，后者对应喂食。</p></blockquote></li><li><p>由于vector里存的指针所指向的对象存储在栈上时，会有必须给每个对象赋一个变量名的麻烦情况，因此往往才有在堆上创建对象的方式。所以，在程序结束时，需要将在这些堆上的内存释放掉。</p></li><li><p>一般来说，在创建这些对象时，会比较小心一些。任意使用，直到函数结束。也就是我们不会太关注堆上对象的释放问题，进而造成内存泄漏。因此可以采用封装的思想，将内存的申请和释放封装到新的类里——该思想在链表中已经反复强调过。因此，可以将vector里的元素从指针丰富为一个类，该类包含一个指针即具有原来的功能，还具有一个构造函数和一个析构函数，构造函数负责在堆上申请内存，析构函数负责释放内存。这种类称为<strong>句柄类</strong>。</p></li></ol><h2 id="new和delete">new和delete</h2><p>处理都是堆上的内存</p><p>在进行new的时候发生的步骤：</p><ol type="1"><li>根据new的目标的类型确定申请多大的内存</li><li>申请内存</li><li>在这块内存上调用目标类型的构造函数</li><li>构造函数在这块内存上按自定义或合成的定义分配这块内存</li><li>返回该内存的指针</li></ol><h2 id="虚拟函数">虚拟函数</h2><p>基本应用场景：一个类的族（一个基类和其他派生类，所有的类都包含在这个族里），在C++里可以用一个vector存放不同类的指针，但是存进去的适合需要同一种类型的指针（强制转换），在此其间都会普遍采用存放基类的指针，因为每一个类都包含这一部分，将它们放在vector的主要原因是，它们有同一个基类，可以进行同样的处理。也就是，可以调用基类就存在的函数，比如说一个动物类，vector存的是动物园的所有动物的指针，现在模拟饲养员对每种动物的喂食、环境清理。像环境清理可以采用同一个基类函数，但是喂养的话，不同的动物需要不同的食物。所以需要定义分别定义不同的喂养函数。为了便于批量处理，即统一管理，C++新增了虚拟函数。这种函数的特性是，其基类写了这个函数给了这个函数定义，其派生类也可以给这个函数自己的定义，基类和派生类有各自自己的实现。</p><p>在C++里有一个共同的前提，即派生类可以截断成基类，也就是前面所说的，把各动物指针放在vector里，在解引用这种指针后，将获得一般性vector的内容。此时，若调用一般性的函数，也就会直接调用基类自己调用的函数。而如果调用虚拟函数，它就会调用这个指针它的实际类型重新定义的虚拟函数，前者对应打扫卫生，后者对应喂食。</p><h2 id="变量">变量</h2><p>变量可以分为局部变量和全局变量</p><p>作用域：一般指大括号之内的区域；</p><p>局部变量：作用域只在它所处的最小的括号里面；</p><p>有一种例外情况叫静态变量static；使用变量时，编译器会从最内层的作用域内找，只要在内层作用域找到了就不再外层作用域找，因此当同时存在全局变量和局部变量a时，会优先使用局部变量a。这种情况在函数中也出现。</p><p>生存期：变量存在内存的时间，和作用域一致，除非受到static影响。一般变量的生存期就是在本作用域的开头到末尾之间。注意，变量只在声明之后才可见，也就是说如果同时声明了全局变量和局部变量a，在局部变量a声明之前可以正常使用全局变量a，声明之后则只能使用局部变量a，除非显示调用域作用符。</p><p>例子:</p><p>如果在函数内返回了一个局部变量这个变量可以是在函数内声明的也可以是函数的传参，但要求其不是引用传参。如果本函数的返回类型是引用，则若把该变量当作返回值返回，则调用函数处将获得一个错误的变量。</p><p>引用变量的关键是，它是一个变量。</p><h2 id="左值引用">左值引用</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span>&amp;b=a;</span><br><span class="line"><span class="comment">//a和b一般都是左值类型，没有什么int&amp;类型，只要是左值类型都可以理解为int&amp;类型</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>声明一个引用变量，需要用初始化的形式给其绑定一个变量。新声明的引用变量名就是原变量的别名。使用两个变量名都可以指向同一个地址，当作一个普通变量用即可，只是它们的地址是指向同一块区域。</p><p>变量：任何一个有地址的变量，即<strong>非临时变量都可以视为一个左值，在C++的视角下，也就相当于是一个左值引用变量。</strong></p><p>引用变量的关键是，它是一个变量，使用该变量可以获得他的值也可以获得他的地址进行进一步利用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">sum</span><span class="params">(<span class="type">int</span> d)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> d; </span><br><span class="line">}<span class="comment">//不能这样返回！！</span></span><br><span class="line"><span class="comment">//d是一个局部变量，具有生存期，函数调用完成后其地址会被销毁 也就是就算a是一个全局变量，但是传参传进来之后就变成了局部变量</span></span><br><span class="line">变量只在声明之后才可见，也就是说如果同时声明了全局变量和局部变量a，在局部变量a声明之前可以正常使用全局变量a，声明之后则只能使用局部变量a，除非显示调用域作用符。</span><br><span class="line">    </span><br><span class="line"><span class="comment">//而int&amp; 是一个左值变量，需要有地址，需要有地址。函数调用完后，d的地址被销毁，那么也无法获取返回值</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//而我们之前经常用的return a+b，返回的是临时变量，是一个值，而不是地址。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>{</span><br><span class="line">    <span class="type">int</span> b=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">sum</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面进行一个对比：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp; <span class="title">sum</span><span class="params">(<span class="type">void</span>)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//编译器会从最内层的作用域内找，只要在内层作用域找到了就不再外层作用域找</span></span><br><span class="line"><span class="comment">//此时 a是一个全局变量，调用函数后不会被销毁，因此返回的是一个变量</span></span><br></pre></td></tr></tbody></table></figure><h2 id="类">类</h2><p>类就是自定义类型，相较于内置类型而言，没有任何运算符。为了使类类型在使用时和内置类型一样顺畅。所以需要重载运算符，而重载运算符的方式就是写相应的函数。</p><h2 id="cdate-temp-this">CDate temp = *this;</h2><p>这句话可以相当于把CDate 看成int</p><p>即 int tmp=*this</p><p>是一个初始化的过程。</p><p>CDate 是一个类类型 ，temp是CDate的一个实例对象。</p><p>this <strong>是一个指向当前对象的指针，我们可以通过</strong> this<strong>来访问当前对象的所有成员</strong></p><h2 id="i">*i++</h2><ol type="1"><li><p>解引用</p><p>‘‘* i ’ 要求i是指针类型，*i利用的是i的值，和i是左值右值无关，但是*i的结果常是右值，常常再返回引用类型的函数时作为返回值。</p><p>解引用的值可以作为左值也可以作为右值</p><p>作为左值的时候，用存储的地址</p><p>作为右值的时候，用存储地址上的值</p></li><li><p>指针</p></li></ol><p>指针一个变量，变量有自己的值和地址，在函数传参时候，正常来说只能传值，但是在c++里新增了引用变量，所以在逻辑上，可以同时传值和对应的地址；</p><p>对于指针而言最重要的是它的值，即存放的地址。通过这个值可以改变另外一个内容。</p><ol start="3" type="1"><li>i++ 和++i</li></ol><p>i++返回 的是加之前的值 是拷贝后的值 只能用作右值使用</p><p>++i 返回的是加之后的值</p><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="keyword">out</span>++= *begin++;</span><br><span class="line">相当于</span><br><span class="line">    <span class="keyword">out</span>=begin;</span><br><span class="line">++<span class="keyword">out</span>;++begin;</span><br></pre></td></tr></tbody></table></figure><h2 id="指针的数组-数组的指针">指针的数组 数组的指针</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line"><span class="comment">//&amp;p 这个表达的意思是指向数组的指针</span></span><br><span class="line"><span class="type">int</span> p1[<span class="number">2</span>][<span class="number">3</span>]={};</span><br><span class="line"><span class="type">int</span> *q[<span class="number">3</span>]=p1;</span><br><span class="line"><span class="comment">//q 也是指向数组的指针  </span></span><br><span class="line">注意&amp;p 和*q 的区别</span><br></pre></td></tr></tbody></table></figure><h2 id="表达式返回值">表达式返回值</h2><p>就是<strong>类istream提供了一个转换来将cin转换成一个可以在条件中使用的值</strong>。我们还不知道这个值的类型，但是我们知道这个值可以被转换成布尔值，<strong>这个转换所产生的值取决于istream对象的内部状态，该状态会记住最近一次读数据的尝试是否成功</strong>。因此，用cin来作为条件等价于检测</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="number">1</span>；//此表达式具有返回值<span class="number">2</span></span><br><span class="line"><span class="number">1</span>;//此表达式具有返回值<span class="number">1</span></span><br><span class="line"></span><br><span class="line">int a ;</span><br><span class="line">a;//此表达式具有返回值 左值类型 a</span><br><span class="line">a=<span class="number">1</span>+<span class="number">1</span>;//返回类型是左值类型a</span><br><span class="line"></span><br><span class="line">int sum(int a ,int b){<span class="keyword">return</span> a+b;}</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">1</span>);//返回类型int </span><br><span class="line"></span><br><span class="line">cout;//返回类型 ostream&amp;,左值类型</span><br><span class="line">cout &lt;&lt;  <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">/*执行的顺序 (cout &lt;&lt;  <span class="number">1</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="number">1.</span>第一句返回类型为ostream&amp;，第<span class="number">2</span>句返回类型为ostream&amp;</span><br><span class="line"><span class="number">2.</span>第二句话执行时实际上执行了 cout&lt;&lt;<span class="number">2</span></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cin&gt;&gt;x)</span><br><span class="line">/*</span><br><span class="line">实现过程为：</span><br><span class="line"><span class="number">1.</span>cin&gt;&gt;x 返回类型为istream&amp;</span><br><span class="line"><span class="number">2.</span>实际执行为 <span class="keyword">if</span>(cin)</span><br><span class="line"><span class="number">3.</span>这里将cin强制转换成了bool类型 是自定义的 利用了运算符重载</span><br><span class="line"><span class="number">4.</span>cin转换成了bool 他的返回值只跟cin内部定义的bool类型转换有关，返回值只与输入区是否还有内容有关 如果有内容则返回<span class="built_in">true</span> 没有 返回<span class="built_in">false</span>；和 scanf不一样</span><br><span class="line">*/</span><br></pre></td></tr></tbody></table></figure><h3 id="代码实例">代码实例</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description:  返回this</span></span><br><span class="line"><span class="comment"> * @Author: ~光~~</span></span><br><span class="line"><span class="comment"> * @Date: 2024-08-09 16:17:31</span></span><br><span class="line"><span class="comment"> * @LastEditTime: 2024-08-13 11:40:04</span></span><br><span class="line"><span class="comment"> * @LastEditors:  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Aclass</span>{</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="function">Aclass &amp;<span class="title">in</span><span class="params">(<span class="type">int</span> b)</span></span>{</span><br><span class="line">        num = b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">Aclass &amp;<span class="title">add</span><span class="params">(<span class="type">const</span> Aclass b)</span></span>{</span><br><span class="line">        num += b.num;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(num != <span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Aclass &amp;<span class="keyword">operator</span>&lt;&lt;(Aclass &amp;a,<span class="type">int</span> b){</span><br><span class="line">    a.num = b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\na获取%d\n"</span>,b);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out,Aclass &amp;a){</span><br><span class="line">    out &lt;&lt; a.num;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>{</span><br><span class="line">    Aclass a,b;</span><br><span class="line">    a &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;&lt;<span class="number">0</span>){<span class="built_in">printf</span>(<span class="string">"这个人很无语"</span>);}</span><br><span class="line">    b.num = <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">add</span>(b)&lt;&lt;endl;</span><br><span class="line">    (cout &lt;&lt; <span class="number">1</span>) &lt;&lt; <span class="string">"123"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span>;cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getchar</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> hjj讲解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武汉大学OB-Gins 环境配置的记录</title>
      <link href="/2024/09/06/%E6%AD%A6%E6%B1%89%E5%A4%A7%E5%AD%A6OB-Gins%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/09/06/%E6%AD%A6%E6%B1%89%E5%A4%A7%E5%AD%A6OB-Gins%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="武汉大学ob-gins-环境配置的记录">武汉大学OB-Gins环境配置的记录</h1><blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>本blog记录OB-GINS在虚拟机下的环境配置过程，整个过程主要是大概的步骤，和参考其它博主的详细的分详细步骤。整个过程，敲重点的是注意配置过程的版本号，以及虚拟机的设置（最好虚拟机运行前主机给他分配多一点性能，不然装ceres库的时候会卡死）</p></blockquote><h2 id="虚拟机和ubuntu">1.虚拟机和Ubuntu</h2><p>首先你需要一台虚拟机，市面上很多不同的软件可以达到这个要求，我下载的是VMware。然后系统是Ubuntu18.04 or Ubuntu 20.04 。</p><p>新手的话这个配置的过程具体可以参考这个链接。</p><blockquote><p><a href="https://blog.csdn.net/m0_70885101/article/details/137871474">链接</a></p></blockquote><p>如果是新手配置，配置完一下需要倒腾一下包括字体，分辨率，然后还可以在内部下载一些浏览器，VSCODE等等。当然别弄太多，毕竟这只是一个用于跑代码的环境。</p><p>因为我是之前配的ubuntu16.0版本的，所以需要倒腾一下，把16.0的，升级成18.04的，具体的教程可以参考这个（之前新手已配完的可以不看）：</p><p><a href="https://blog.csdn.net/qq_18256855/article/details/124169962">链接</a></p><h2 id="gcc和g下载">2.GCC和g++下载</h2><p>配置完之后配置gcc 和g++</p><p>注意 <strong>配置的版本</strong>是大于8.0以上的</p><h2 id="cmake下载">3.Cmake下载</h2><p>然后下载Cmake <strong>最好是3.2以上的</strong> 具体教程可以搜一下</p><h2 id="ceres库配置">4.Ceres库配置</h2><p>接着下载Ceres</p><p>这个过程及其痛苦。因为容易卡，所以需要你给虚拟机配置大一点的内存，处理核数也给它整个4个。</p><p>具体参考连接参考这个：</p><p><a href="http://ceres-solver.org/installation.html">安装 — CeresSolver (ceres-solver.org)</a></p><h2 id="其他">5.其他</h2><p>接下来就是下载yaml-cpp</p><p>在命令行敲：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libyaml-cpp-dev</span><br></pre></td></tr></tbody></table></figure><h2 id="运行程序">6.运行程序</h2><p>至于运行程序</p><p>就是按照武大给的readme的说明进行命令输入然后运行</p><p>后期有机会讲讲这个代码是怎么个实现的~</p><p>浅浅记录一下~</p>]]></content>
      
      
      <categories>
          
          <category> 因子图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 因子图开源代码 </tag>
            
            <tag> Ubuntu环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 指针、多维数组零碎知识点</title>
      <link href="/2024/08/06/C-%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/08/06/C-%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 关于C指针和数组 相关的东西今天被chj狠狠整顿了，现在回忆整理一下相关的知识点，既作分享，也加强记忆。本blog需要有基本的指针和数组相关的知识储备</p><p>下面是学习的点。配合代码食用更佳~</p></blockquote><h1 id="提要">提要</h1><ol type="1"><li>二维数组 存储形式和一维数组一样</li><li>a[2] [3]是左值是因为a[2] [3]等价于 * (a+2* 3*sizeof(int)+3*sizeof(int))</li><li>(int)b【也就是强制转换后】是右值，数组名a等效于右值</li><li>关于 int<em>c =((int </em>)&amp;a);</li><li>int <em>c= (char </em>)a;</li><li>关于 float 类型 用%d读的时候 出现的0.0000问题</li></ol><h1 id="二维数组">1.二维数组</h1><p>首先二维数组 我们知道是a[m][n]这样的形式，其实就是数组的数组，可以理解为类似于矩阵的形式。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>那二维数组的存储方式和一维数组一样具体怎么理解？也就是二维数组和一维数组一样，是连续的存储空间。下面用一个代码展示一下。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]={{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>},{<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>}};</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0]：%p\n"</span>,a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0][1]：%p\n"</span>,&amp;a[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0][2]：%p\n"</span>,&amp;a[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0][3]：%p\n"</span>,&amp;a[<span class="number">0</span>][<span class="number">3</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[1]：%p\n"</span>,&amp;a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[1][0]：%p\n"</span>,&amp;a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[1][1]：%p\n"</span>,&amp;a[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>思考一下，给出答案</p><p>也许有人会问a[0] [3]不是越界了嘛？我的理解：但是其实越界这个概念的提出只是因为防止在连续的存储空间内没有这个变量，或者更改了其他的变量。而在这里，也就是连续的存储空间里，a[0][2]下个值 在我们看来是a[1] [0],但其实写成a[0][3]也没有关系，表示的就是a[0] [2]下个连续的地址。所以这边a[1] [0]和a[0][3]是同一个东西。</p></blockquote><p>答案如下~ 二维数组的存储形式 以sizeof(int) 个单位依次递增，其存储形式表现的和一维数组是一样的形式。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>]：<span class="number">0061F</span>EFC</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>]：<span class="number">0061F</span>F00</span><br><span class="line">a[<span class="number">0</span>][<span class="number">2</span>]：<span class="number">0061F</span>F04</span><br><span class="line">a[<span class="number">0</span>][<span class="number">3</span>]：<span class="number">0061F</span>F08</span><br><span class="line">a[<span class="number">1</span>]：<span class="number">0061F</span>F08</span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]：<span class="number">0061F</span>F08</span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]：<span class="number">0061F</span>F0C</span><br></pre></td></tr></tbody></table></figure><h2 id="关于二维数组和指针的指针">关于二维数组和指针的指针</h2><p>我们知道，一维数组也就是a[]，其数组名a是该数组的首地址，而指针变量是存储地址的变量类型，所以这个数组名a也可当作指针变量使用，那么二维数组是否也有类似的形式？</p><h3 id="herb对于一维数组而言"><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>对于一维数组而言</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d[<span class="number">3</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line"><span class="type">int</span> *p2=d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*(p2+1):%d\n"</span>,*(p2+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*(p2+2):%d\n"</span>,*(p2+<span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*(d+1):%d\n"</span>,*(p2+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*(d+2):%d\n"</span>,*(p2+<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address:(p2+1):%d\n"</span>,(p2+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address:(p2+2):%d\n"</span>,(p2+<span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address:(d+1):%d\n"</span>,(d+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address:(d+2):%d\n"</span>,(d+<span class="number">2</span>));</span><br></pre></td></tr></tbody></table></figure><hr><p>此时答案应该显而易见。由于p是指向a的指针，也就是p存储的值是a的地址，a也可当作指针变量使用，所以他俩的地址一样，解引用后得到的值也一样。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*(p2+<span class="number">1</span>):<span class="number">2</span></span><br><span class="line">*(p2+<span class="number">2</span>):<span class="number">3</span></span><br><span class="line">*(d+<span class="number">1</span>):<span class="number">2</span></span><br><span class="line">*(d+<span class="number">2</span>):<span class="number">3</span></span><br><span class="line">address:(p2+<span class="number">1</span>):<span class="number">6422264</span></span><br><span class="line">address:(p2+<span class="number">2</span>):<span class="number">6422268</span></span><br><span class="line">address:(d+<span class="number">1</span>):<span class="number">6422264</span></span><br><span class="line">address:(d+<span class="number">2</span>):<span class="number">6422268</span></span><br></pre></td></tr></tbody></table></figure><h3 id="ear_of_rice对于二维数组"><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌾</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>对于二维数组</h3><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>依葫芦画瓢，那么怎么表示指向一个二维数组的指针变量，同时也可以用这个指针变量达到和类似二维数组表现形式一样的效果呢？</p><p>设有二维数组int a[3] [4];那么是不是也声明一个指针的指针，类似于int**p=a？</p><p>非也非也。</p><p>上文提到，二维数组存储形式和一维数组一样，二维数组的存储形式以sizeof(int)个单位 依次递增，其存储形式表现的和一维数组是一样的形式。而int **p是指针的指针，具体而言，p是一个指针，假设它存储的是地址A，而这个A是另一个指针变量的地址，于是用**表示指针的指针。二维数组是和一维数组一样的存储形式，即顺序存储形式，也就不能用这种**p直接进行表示。</p><blockquote><p>具体也可以试试看。 ** p如果指向a的地址，那么 p第一次解引用是a[0] [0],第二次解引用呢？没有地址可以给他解引用了，所以这样肯定是不行的。</p></blockquote><p>**指向二维数组的指针可以表示为 int (*p)[4] = a;**</p><p>也就是指向数组的指针，具体而言，这个p是一个指针变量，它指向int[4]类型的数组；p+1表示的是从基地址a[0] [0]开始向下偏移1个单元，这一个单元包含4个int变量，也就是4个sizeof(int)；二维数组a[3][4]可以看作是含有3个单元，其中这的每个单元含有4个int类型的变量。所以总共有3*4 个sizeof(int)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]={{<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>},{<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>},{<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>}};</span><br><span class="line">   <span class="type">int</span> (*p1)[<span class="number">4</span>]=a;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p1:%p\n"</span>,p1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"a:%p\n"</span>,a);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"a[0][0]:%p\n"</span>,&amp;a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"p1+1:%p\n"</span>,p1+<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"a+1:%p\n"</span>,a+<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"a[0][4]:%p\n"</span>,&amp;a[<span class="number">0</span>][<span class="number">4</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"p1+2:%p\n"</span>,p1+<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"a+2:%p\n"</span>,a+<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"a[1][4]:%p\n"</span>,&amp;a[<span class="number">1</span>][<span class="number">4</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"*(p1+1):%p\n"</span>,*(p1+<span class="number">1</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"*(a+1):%p\n"</span>,*(a+<span class="number">1</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"a[1][0]:%p\n"</span>,a[<span class="number">1</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"*(*(p1+1)+1):%d\n"</span>,*(*(p1+<span class="number">1</span>)+<span class="number">1</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"a[1][1]:%d\n"</span>,a[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><p>答案如下~记得自己多敲几遍。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">p1:<span class="number">0061F</span>EE8</span><br><span class="line">a:<span class="number">0061F</span>EE8</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]:<span class="number">0061F</span>EE8</span><br><span class="line">------------------</span><br><span class="line">p1+<span class="number">1</span>:<span class="number">0061F</span>EF8</span><br><span class="line">a+<span class="number">1</span>:<span class="number">0061F</span>EF8</span><br><span class="line">a[<span class="number">0</span>][<span class="number">4</span>]:<span class="number">0061F</span>EF8</span><br><span class="line">------------------</span><br><span class="line">p1+<span class="number">2</span>:<span class="number">0061F</span>F08</span><br><span class="line">a+<span class="number">2</span>:<span class="number">0061F</span>F08</span><br><span class="line">a[<span class="number">1</span>][<span class="number">4</span>]:<span class="number">0061F</span>F08</span><br><span class="line">------------------</span><br><span class="line">*(p1+<span class="number">1</span>):<span class="number">0061F</span>EF8</span><br><span class="line">*(a+<span class="number">1</span>):<span class="number">0061F</span>EF8</span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]:<span class="number">0061F</span>EF8</span><br><span class="line">------------------</span><br><span class="line">*(*(p1+<span class="number">1</span>)+<span class="number">1</span>):<span class="number">5</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>]:<span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><h1 id="intc-int-a">2. int<em>c =((int </em>)&amp;a);</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> *p3=(<span class="type">int</span>*)&amp;a;</span><br><span class="line"><span class="type">int</span> *p4=(<span class="type">char</span>*)a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p3:%d\n"</span>,*p3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address: p3 :%p\n"</span>,p3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address: a :%p\n"</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"==============================\n"</span>);</span><br></pre></td></tr></tbody></table></figure><p>第二行：这句话的意思是把a转换为一个int*的指针，这个指针变量存储的是3，这个变量的地址还是a的地址。最后赋值给c</p><p>第三行：意思是把a强制转为char<em>的变量，注意，不管是什么指针，它都是8个字节的，所以它就把a，也就是3，作为char</em>使用，存储的是3这个值，也就是指向的地址是3，而这个变量a的地址还是原来的地址。最后赋值给d。</p><hr><p>结果</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p3:<span class="number">9</span></span><br><span class="line">address: p3 :<span class="number">0061F</span>ED4</span><br><span class="line">address: a :<span class="number">0061F</span>ED4</span><br></pre></td></tr></tbody></table></figure><h1 id="float-类型-用d读-出现的0.0000问题">3. float 类型 用%d读出现的0.0000问题</h1><p>一切从一个程序说起，还是有点坑的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">    <span class="type">float</span> a=<span class="number">999897.777</span>;</span><br><span class="line">    <span class="type">int</span> b=a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%f,%d,%f\n"</span>,b,a,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>仔细想想最后输出什么；</p><hr><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">999897</span>,<span class="number">999897.750000</span>,<span class="number">-2147483648</span>,<span class="number">0.000000</span></span><br></pre></td></tr></tbody></table></figure><p>这段代码其实比较基础。</p><p>首先，前面几个不难得到。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b=a; </span><br></pre></td></tr></tbody></table></figure><p>进行了一次隐式的转换，也就相当于int b=(int) a ，所以此时b=3；</p><p>前面的第一个b 和a不疑惑。第三个值，a等于一个负值，其实也不难理解，由于浮点数存储的形式和整型是不一样的，所以它读到的整形变量上是一个赋值不奇怪。</p><p>最后一个0.00000就比较难理解了，需要和底层硬件联系起来。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🐳</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f433.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>具体解答可以看看这篇<a href="https://blog.csdn.net/u010639500/article/details/87885721">blog</a></p><p>由于float 和 int 存储形式的差异，导致最终的结果为0；</p><blockquote><p>flaot 存储的形式是 类似 整数+指数这样的类型的，比如312.2怎么存储的？就是把3122放入整数中，然后指数为-1，也就类似于3122*10<sup>(-1)</sup> 这样存储的 。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 多维数组 </tag>
            
            <tag> 存储方式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 存储类型</title>
      <link href="/2024/07/31/C-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/07/31/C-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文字摘自 C Primer 第六版</p></blockquote><h2 id="存储类别">存储类别</h2><p><strong>作用域和链接描述了标识符的可见性</strong>。</p><p><strong>存储期描述了通过这些标识符访问的对象的生存期。</strong></p><p>编程示例中使用的数据都储存在内存中。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>从硬件方面来看，被储存的每个值都占用一定的物理内存，C语言把这样的一块内存称为<strong>对象</strong>（object）。<strong>对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小</strong>（面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言）。</p><p><strong>标识符：</strong>是一个名称，是可以用于指定特定对象的内容。标识符遵循变量的命名规则。标识符指定硬件内存中的对象方式。</p><p>如:int a=3; //a就是一个标识符</p><p>变量名不是指定对象的唯一途径。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pt=&amp;entity;</span><br></pre></td></tr></tbody></table></figure><p>pt是一个标识符，它制定了一个存储地址的对象。但是*pt不是标识符，因为它不是一个名称，然而它趋确实指定了一个对象，这个对象和a指定的对象相同。</p><p>一般而言，那些<strong>指定对象的表达式称为左值</strong>所以a和*pt是表达式也是左值，指定了特定内存位置的值。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rank[<span class="number">10</span>];</span><br></pre></td></tr></tbody></table></figure><p>ranks的声明创建了一个可容纳10个int类型元素的对象，该数组的每个元素也是一个对象。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * pc = <span class="string">"Behold a string literal!"</span>;</span><br></pre></td></tr></tbody></table></figure><p>程序根据该<span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>声明<strong>把相应的字符串字面量储存在内存中，内含这些字符值的数组就是一个对象</strong>。由于<strong>数组中的每个字符都能被单独访问，所以每个字符也是一个对象</strong>。<span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>该声明还<strong>创建了一个标识符为pc的对象，储存着字符串的地址</strong>。由于可以设置pc重新指向其他字符串，所以<strong>标识符pc是一个可修改的左值。</strong><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指向别的字符串。</strong> 由于* pc指定了储存'B'字符的数据对象，所以*pc是一个左值，但不是一个可修改的左值。与此类似，因为字符串字面量本身指定了储存字符串的对象，所以它也是一个左值，但不是可修改的左值</p><p>可以用存储期（storage duration）描述对象</p><p><strong>存储期</strong>是指对象在内存中保留了多长时间。标识符用于访问对象，可以用<strong>作用域（scope）和链接（linkage）描述标识符</strong>，标识符的作用域和链接表明了程序的哪些部分可以使用它。不同的存储类别具有不同的存储期、作用域和链接。</p><p>标识符可以在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也可以仅存在于它所在函数的执行期。对于并发编程，对象可以在特定线程的执行期存在。可以通过函数调用的方式显式分配和释放内存。</p><h3 id="作用域">作用域</h3><p><strong>作用域描述程序中可访问标识符的区域</strong>。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>作用域分为：块作用域 函数作用域 函数原型作用域 文件作用域</p><h4 id="块作用域">块作用域</h4><p><strong>块是用一对花括号括起来的代码区域。</strong>例如，整个函数体是一个块，函数中的任意复合语句也是一个块。定义在块中的变量具有块作用域（blockscope）<strong>，块作用域变量的可见范围是从定义处到包含该定义的块的末尾。</strong>另外，虽然函数的形式参数声明在函数的左花括号之前，但是它们也具有块作用域，属于函数体这个块。所以到目前为止，<strong>我们使用的局部变量（包括函数的形式参数）都具有块作用域。</strong></p><p>声明在内层块中的变量，其作用域仅局限于该声明所在的块。</p><h4 id="函数作用域">函数作用域</h4><p>函数作用域（functionscope）仅用于goto语句的标签。这意味着即使一个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数。如果在两个块中使用相同的标签会很混乱，标签的函数作用域防止了这样的事情发生。</p><h4 id="函数原型作用域">函数原型作用域</h4><p>用于函数原型中的形参名</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mighty</span><span class="params">(<span class="type">int</span> mouse, <span class="type">double</span> large)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>函数原型作用域的范围</strong>是从形参定义处到原型声明结束。这意味着，编译器在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话）通常无关紧要。而且，即使有形参名，也不必与函数定义中的形参名相匹配。只有在变长数组中，形参名才有用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">use_a_VLA</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, ar[n][m])</span>;</span><br></pre></td></tr></tbody></table></figure><p>方括号中必须使用在函数原型中已声明的名称。变量的定义在函数的外面，具有文件作用域（filescope）。具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见。</p><h4 id="文件作用域">文件作用域</h4><p>变量的定义在函数的外面，具有文件作用域（filescope）。具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见。</p><p>一般是全局变量。</p><h4 id="翻译单元">翻译单元</h4><p>通常在源代码（.c扩展名）中包含一个或多个头文件（.h扩展名）。头文件会依次包含其他头文件，所以会包含多个单独的物理文件。但是，<strong>C预处理实际上是用包含的头文件内容替换#include指令。</strong>所以，<strong>编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件。</strong>这个文件被称为<strong>翻译单元</strong>（translationunit）。描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。<strong>每个翻译单元均对应一个源代码文件和它所包含的文件。</strong></p><h3 id="链接">链接</h3><p>C 变量有 3种链接属性：<strong>外部链接、内部链接或无链接</strong>。</p><p>具有块作用域、函数作用域或函数原型作用域的变量都是<strong>无链接变量</strong>。这意味着这些变量属于定义它们的块、函数或原型<strong>私有</strong>。</p><p>具有文件作用域的变量可以是外部链接或内部链接。<strong>外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。</strong></p><p>C标准用<strong>“内部链接的文件作用域”描述仅限于一个翻译单元</strong>（即一个源代码文件和它所包含的头文件）的作用域，用<strong>“外部链接的文件作用域”描述可延伸至其他翻译单元</strong>的作用域。但是，对程序员而言这些术语太长了。</p><p>一些程序员把<strong>“内部链接的文件作用域”简称为“文件作用域”</strong>，把<strong>“外部链接的文件作用域”简称为“全局作用域”或“程序作用域”</strong>。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>如何知道文件作用域变量是内部链接还是外部链接？</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>可以查看外部定义中是否使用了存储类别说明符static</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> giants = <span class="number">5</span>;       <span class="comment">// 文件作用域，外部链接</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dodgers = <span class="number">3</span>;   <span class="comment">// 文件作用域，内部链接</span></span><br></pre></td></tr></tbody></table></figure><p>该文件和同一程序的其他文件都可以使用变量giants。而变量dodgers属文件私有，该文件中的任意函数都可使用它。</p><h3 id="存储期">存储期</h3><p><strong>作用域和链接描述了标识符的可见性</strong>。</p><p><strong>存储期描述了通过这些标识符访问的对象的生存期。</strong></p><p>C对象有<strong>4种存储期</strong>：静态存储期、线程存储期、自动存储期、动态分配存储期。</p><p>如果对象具有<strong>静态存储期</strong>，那么它在<strong>程序的执行期间一直存在</strong>。文件作用域变量具有静态存储期。注意，对于文件作用域变量，<strong>关键字</strong>static表明了其<strong>链接属性</strong>，而非存储期。<strong>以static声明的文件作用域变量具有内部链接</strong>。但是无论是内部链接还是外部链接，<strong>所有的文件作用域变量都具有静态存储期。</strong></p><p>线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字_Thread_local声明一个对象时，每个线程都获得该变量的私有备份。</p><p><strong>块作用域的变量通常都具有自动存储期</strong>。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。</p><blockquote><p>例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调用函数的变量。变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。</p></blockquote><p><strong>变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。</strong></p><p>我们<strong>到目前为止使用的局部变量都是自动类别</strong>。例如，变量number和index在每次调用bore()函数时被创建，在离开函数时被销毁。</p><p>然而，块作用域变量也能具有静态存储期。为了创建这样的变量，要把变量声明在块中，且在声明前面加上关键字static。</p><p><img src="D:\typora\pic\模电\image-20231224205322937.png" alt="image-20231224205322937" style="zoom:67%;"></p><h3 id="自动变量">自动变量</h3><p>属于<strong>自动存储类别的变量</strong>具有<strong>自动存储期、块作用域且无链接。</strong>默认情况下，声明在块或函数头中的任何变量都属于自动存储类别。为了更清楚地表达你的意图（例如，为了表明有意覆盖一个外部变量定义，或者强调不要把该变量改为其他存储类别），可以显式使用关键字auto</p><p>块作用域和无链接意味着<strong>只有在变量定义所在的块中才能通过变量名访问该变量（</strong>当然，参数用于传递变量的值和地址给另一个函数，但是这是间接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存位置上的另一个变量。</p><p>变量具有<strong>自动存储期</strong>意味着，<strong>程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失。原来该变量占用的内存位置现在可做他用。</strong></p><p><strong>块中声明的变量仅限于该块及其包含的块使用。</strong></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>如果内层块中声明的变量与外层块中的变量同名会怎样？</p><p>内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hiding.c -- 块中的变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">30</span>;       <span class="comment">// 原始的 x</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x in outer block: %d at %p\n"</span>, x, &amp;x);</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> x = <span class="number">77</span>;     <span class="comment">// 新的 x，隐藏了原始的 x</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x in inner block: %d at %p\n"</span>, x, &amp;x);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x in outer block: %d at %p\n"</span>, x, &amp;x);</span><br><span class="line">    <span class="keyword">while</span> (x++ &lt; <span class="number">33</span>)    <span class="comment">// 原始的 x</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> x = <span class="number">100</span>;    <span class="comment">// 新的 x，隐藏了原始的 x</span></span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x in while loop: %d at %p\n"</span>, x, &amp;x);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x in outer block: %d at %p\n"</span>, x, &amp;x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>想想程序输出为？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">程序输出：</span><br><span class="line">x in outer block: 30 at 0x7fff5fbff8c8</span><br><span class="line">x in inner block: 77 at 0x7fff5fbff8c4</span><br><span class="line">x in outer block: 30 at 0x7fff5fbff8c8</span><br><span class="line">x in while loop: 101 at 0x7fff5fbff8c0</span><br><span class="line">x in while loop: 101 at 0x7fff5fbff8c0</span><br><span class="line">x in while loop: 101 at 0x7fff5fbff8c0</span><br><span class="line">x in outer block: 34 at 0x7fff5fbff8c8</span><br></pre></td></tr></tbody></table></figure><p>也许该程序最难懂的是while循环。while循环的测试条件中使用的是原始的x：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x++ &lt; <span class="number">33</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="D:\typora\pic\模电\image-20231224211845331.png" alt="image-20231224211845331" style="zoom:67%;"></p><p>在该循环中，程序创建了第3个x变量，该变量只定义在while循环中。所以，当执行到循环体中的x++时，递增为101的是新的x，然后printf()语句显示了该值。<strong>每轮迭代结束，新的x变量就消失。然后循环的测试条件使用并递增原始的x，再次进入循环体，再次创建新的x。</strong>在该例中，<strong>这个x被创建和销毁了3次。</strong>注意，该循环必须在测试条件中递增x，因为如果在循环体中递增x，那么递增的是循环体中创建的x，而非测试条件中使用的原始x。<strong>我们使用的编译器在创建while循环体中的x时，并未复用内层块中x占用的内存，但是有些编译器会这样做。</strong></p><p>第1个for循环头中声明的n，其作用域作用至循环末尾，而且隐藏了原始的n。但是，离开循环后，原始的n又起作用了。第2个for循环头中声明的n作为循环的索引，隐藏了原始的n。然后，在循环体中又声明了一个n，隐藏了索引n。结束一轮迭代后，声明在循环体中的n消失，循环头使用索引n进行测试。当整个循环结束时，原始的n又起作用了。再次提醒读者注意，没必要在程序中使用相同的变量名。如果用了，各变量的情况如上所述。</p><p>自动变量不会初始化，除非显式初始化它。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> repid;</span><br><span class="line">    <span class="type">int</span> tents = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><p>tents变量被初始化为5，但是repid变量的值是之前占用分配给repid的空间中的任意值（如果有的话），别指望这个值是0。可以用非常量表达式（non-constantexpression）初始化自动变量，前提是所用的变量已在前面定义过：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> ruth = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rance = <span class="number">5</span> * ruth; <span class="comment">// 使用之前定义的变量</span></span><br></pre></td></tr></tbody></table></figure><h3 id="寄存器变量">寄存器变量</h3><p>变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在CPU的寄存器中，或者概括地说，储存在最快的可用内存中。与普通变量相比，访问和处理这些变量的速度更快。<strong>由于寄存器变量储存在寄存器而非内存中，所以无法获取寄存器变量的地址。绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。</strong>使用存储类别说明符<strong>register</strong>便可声明寄存器变量：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> quick;</span><br></pre></td></tr></tbody></table></figure><p>我们刚才说“如果幸运的话”，是因为声明变量为register类别与直接命令相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下，寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。</p><p>在函数头中使用关键字register，便可请求形参是寄存器变量：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">macho</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> n)</span>;</span><br></pre></td></tr></tbody></table></figure><p>可声明为register的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存double类型的值。</p><h3 id="块作用域静态变量">块作用域静态变量</h3><p>静态变量（staticvariable）听起来自相矛盾，像是一个不可变的变量。实际上，<strong>静态的意思是该变量在内存中原地不动，并不是说它的值不变。</strong></p><p><strong>具有文件作用域的变量自动具有（也必须是）静态存储期。</strong>前面提到过，可以创建具有静态存储期、块作用域的局部变量。这些变量和自动变量一样，具有相同的作用域，但是<strong>程序离开它们所在的函数后，这些变量不会消失</strong>。也就是说，<strong>这种变量具有块作用域、无链接，但是具有静态存储期。计算机在多次函数调用之间会记录它们的值。</strong></p><p>在块中（提供块作用域和无链接）以存储类别说明符static（提供静态存储期）声明这种变量。</p><p>举个<span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* loc_stat.c -- 使用局部静态变量 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trystat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= <span class="number">3</span>; count++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Here comes iteration %d:\n"</span>, count);</span><br><span class="line">        trystat();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">trystat</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> fade = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> stay = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fade = %d and stay = %d\n"</span>, fade++, stay++);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>猜猜 最后输出什么</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注意，trystat()函数先打印再递增变量的值。该程序的输出如下：</span><br><span class="line">Here comes iteration 1:</span><br><span class="line">fade = 1 and stay = 1</span><br><span class="line">Here comes iteration 2:</span><br><span class="line">fade = 1 and stay = 2</span><br><span class="line">Here comes iteration 3:</span><br><span class="line">fade = 1 and stay = 3</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>静态变量stay保存了它被递增1后的值，但是fade变量每次都是1。这表明了初始化的不同：每次调用trystat()都会初始化facde，但是stay只在编译strstat()时被初始化一次。如果未显式初始化静态变量，它们会被初始化为0。</p><p>下面两个声明很相似：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fade = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> stay = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>第1条声明确实是trystat()函数的一部分，每次调用该函数时都会执行这条声明。这是运行时行为。第2条声明实际上并不是trystat()函数的一部分。如果逐步调试该程序会发现，程序似乎跳过了这条声明。这是因为静态变量和外部变量在程序被载入内存时已执行完毕。把这条声明放在trystat()函数中是为了告诉编译器只有trystat()函数才能看到该变量。这条声明并未在运行时执行。</p><p><strong>不能在函数的形参中使用static：</strong></p><p><strong>“局部静态变量”是描述具有块作用域的静态变量的另一个术语。</strong>阅读一些老的C文献时会发现，这种存储类别被称为<strong>内部静态存储类别</strong>（internalstaticstorage class）。这里的内部指的是函数内部，而非内部链接。</p><h3 id="外部链接静态变量">外部链接静态变量</h3><p><strong>外部链接的静态变量具有文件作用域、外部链接和静态存储期</strong>。该类别有时称为外部存储类别（external storageclass），属于该类别的变量称为外部变量（external variable）。</p><p>把变量的定义性声明（definingdeclaration）放在在所有函数的外面便创建了外部变量。当然，为了指出该函数使用了外部变量，<strong>可以在函数中用关键字extern再次声明</strong>。如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变量。如下所示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Errupt;        <span class="comment">/* 外部定义的变量 */</span></span><br><span class="line"><span class="type">double</span> Up[<span class="number">100</span>];      <span class="comment">/* 外部定义的数组 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> Coal;     <span class="comment">/* 如果Coal被定义在另一个文件， */</span></span><br><span class="line"><span class="comment">/*则必须这样声明*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> Errupt;   <span class="comment">/* 可选的声明*/</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">double</span> Up[];  <span class="comment">/* 可选的声明*/</span></span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">next</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，在main()中声明Up数组时（这是可选的声明）不用指明数组大小，因为第1次声明已经提供了数组大小信息。main()中的两条extern声明完全可以省略，因为外部变量具有文件作用域，所以Errupt和Up从声明处到文件结尾都可见。它们出现在那里，仅为了说明main()函数要使用这两个变量。如果省略掉函数中的extern关键字，相当于创建了一个自动变量。去掉下面声明中的extern：</p><p>extern int Errupt;</p><p>便成为：</p><p>int Errupt;</p><p>这使得编译器在 main()中创建了一个名为 Errupt的自动变量。它是一个独立的局部变量，与原来的外部变量Errupt不同。该局部变量仅main()中可见，但是外部变量Errupt对于该文件的其他函数（如next()）也可见。简而言之，在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域中的同名变量。如果不得已要使用与外部变量同名的局部变量，可以在局部变量的声明中使用auto 存储类别说明符明确表达这种意图。</p><p><strong>外部变量具有静态存储期。因此，无论程序执行到main()、next()还是其他函数，数组Up及其值都一直存在。</strong></p><p><strong>外部变量的作用域是：从声明处到文件结尾。</strong>除此之外，外部变量具有生命期。外部变量在程序运行中一直存在，因为它们不受限于任何函数，不会在某个函数返回后就消失。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>初始化外部变量</p><p>外部变量和自动变量类似，也可以被显式初始化。与自动变量不同的是，<strong>如果未初始化外部变量，它们会被自动初始化为0。</strong>这一原则也适用于外部定义的数组元素。与自动变量的情况不同，只能使用常量表达式初始化文件作用域变量：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;          <span class="comment">// 没问题，10是常量</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">3</span> + <span class="number">20</span>;       <span class="comment">// 没问题，用于初始化的是常量表达式</span></span><br><span class="line"><span class="type">size_t</span> z = <span class="keyword">sizeof</span>(<span class="type">int</span>);   <span class="comment">//没问题，用于初始化的是常量表达式</span></span><br><span class="line"><span class="type">int</span> x2 = <span class="number">2</span> * x;      <span class="comment">// 不行，x是变量</span></span><br></pre></td></tr></tbody></table></figure><p>（只要不是变长数组，sizeof表达式可被视为常量表达式。）</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>使用外部变量</p><p>下面来看一个使用外部变量的示例。假设有两个函数main()和critic()，它们都要访问变量units。可以把units声明在这两个函数的上面.</p><p>把units定义在所有函数定义外面（即外部），units便是一个外部变量，对units定义下面的所有函数均可见。因此，critics()可以直接使用units变量。类似地，main()也可直接访问units。但是，main()中确实有如下声明：</p><p>extern int units;</p><p>本例中，以上声明主要是为了指出该函数要使用这个外部变量。存储类别说明符extern告诉编译器，该函数中任何使用units的地方都引用同一个定义在函数外部的变量。再次强调，main()和critic()使用的都是外部定义的units。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>外部名称</p><p>C99和C11标准都要求编译器识别局部标识符的前63个字符和外部标识符的前31个字符。这修订了以前的标准，即编译器识别局部标识符前31个字符和外部标识符前6个字符。你所用的编译器可能还执行以前的规则。外部变量名比局部变量名的规则严格，是因为外部变量名还要遵循局部环境规则，所受的限制更多。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>定义和声明</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tern = <span class="number">1</span>; <span class="comment">/* tern被定义 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> tern; <span class="comment">/* 使用在别处定义的tern */</span></span><br></pre></td></tr></tbody></table></figure><p>这里，tern被声明了两次。<strong>第1次声明为变量预留了存储空间，该声明构成了变量的定义。</strong><strong>第2次声明只告诉编译器使用之前已创建的tern变量，所以这不是定义。</strong>第1次声明被称为定义式声明（definingdeclaration），第2次声明被称为引用式声明（referencingdeclaration）。关键字extern表明该声明不是定义，因为它指示编译器去别处查询其定义。假设这样写：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> tern;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br></pre></td></tr></tbody></table></figure><p>编译器会假设 tern实际的定义在该程序的别处，也许在别的文件中。该声明并不会引起分配存储空间。因此，不要用关键字extern创建外部定义，只用它来引用现有的外部定义。</p><p><strong>外部变量只能初始化一次，且必须在定义该变量时进行。</strong>假设有下面的代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_one.c</span></span><br><span class="line"><span class="type">char</span> permis = <span class="string">'N'</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// file_two.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> permis = <span class="string">'Y'</span>; <span class="comment">/* 错误 */</span></span><br></pre></td></tr></tbody></table></figure><p>file_two中的声明是错误的，因为file_one.c中的定义式声明已经创建并初始化了permis.</p><h3 id="内部链接静态变量">内部链接静态变量</h3><p>该存储类别的变量具有<strong>静态存储期、文件作用域和内部链接</strong>。在所有函数外部（这点与外部变量相同），用存储类别说明符static定义的变量具有这种存储类别：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> svil = <span class="number">1</span>;  <span class="comment">// 静态变量，内部链接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></tbody></table></figure><p>这种变量过去称为外部静态变量（external staticvariable），但是这个术语有点自相矛盾（这些变量具有内部链接）。但是，没有合适的新简称，所以只能用<strong>内部链接的静态变量</strong>（staticvariable with internallinkage）。普通的外部变量可用于同一程序中任意文件中的函数，<strong>但是内部链接的静态变量只能用于同一个文件中的函数。</strong>可以使用存储类别说明符extern，在函数中重复声明任何具有文件作用域的变量。这样的声明并不会改变其链接属性。考虑下面的代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> traveler = <span class="number">1</span>;      <span class="comment">// 外部链接</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> stayhome = <span class="number">1</span>;  <span class="comment">// 内部链接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> traveler;  <span class="comment">// 使用定义在别处的 traveler</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> stayhome;  <span class="comment">// 使用定义在别处的 stayhome</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><p>对于该程序所在的翻译单元，trveler和stayhome都具有文件作用域，但是只有traveler可用于其他翻译单元（因为它具有外部链接）。这两个声明都使用了extern关键字，指明了main()中使用的这两个变量的定义都在别处，但是这并未改变stayhome的内部链接属性。</p><h3 id="多文件">多文件</h3><p>只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的重要性。接下来简要介绍一下。复杂的C程序通常由多个单独的源代码文件组成。有时，这些文件可能要共享一个外部变量。</p><p>C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。<strong>也就是说，除了一个定义式声明外，其他声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。</strong></p><p>注意，<strong>如果外部变量定义在一个文件中，那么其他文件在使用该变量之前必须先声明它（用extern关键字）</strong>。也就是说，在某文件中对外部变量进行定义式声明只是单方面允许其他文件使用该变量，其他文件在用extern声明之前不能直接使用它。</p><p>过去，不同的编译器遵循不同的规则。例如，许多UNIX系统允许在多个文件中不使用 extern关键字声明变量，前提是只有一个带初始化的声明。编译器会把文件中一个带初始化的声明视为该变量的定义。</p><h3 id="存储类别说明符">存储类别说明符</h3><p>C语言有6个关键字作为存储类别说明符：auto、register、static、extern、_Thread_local和typedef。</p><p>typedef关键字与任何内存存储无关，把它归于此类有一些语法上的原因。尤其是，在绝大多数情况下，不能在声明中使用多个存储类别说明符，所以这意味着不能使用多个存储类别说明符作为typedef的一部分。</p><p>唯一例外的是_Thread_local，它可以和static或extern一起使用。</p><h4 id="auto">auto</h4><p>auto说明符表明变量是自动存储期，只能用于<strong>块作用域的变量声明中</strong>。由于在块中声明的变量本身就具有自动存储期，所以使用auto主要是为了<strong>明确表达要使用与外部变量同名的局部变量的意图。</strong></p><h4 id="register">register</h4><p>register说明符也只用于块作用域的变量，<strong>它把变量归为寄存器存储类别，请求最快速度访问该变量。同时，还保护了该变量的地址不被获取。</strong></p><h4 id="static">static</h4><p>用 static说明符创建的对象具有静态存储期，载入程序时创建对象，当程序结束时对象消失。<span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>如果static用于文件作用域声明，作用域受限于该文件。<span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>如果 static用于块作用域声明，作用域则受限于该块。</p><p>因此，只要程序在运行对象就存在并保留其值，但是只有在执行块内的代码时，才能通过标识符访问。<strong>块作用域的静态变量无链接。文件作用域的静态变量具有内部链接。</strong></p><h4 id="extern">extern</h4><p>extern 说明符表明声明的变量定义在别处。<span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>如果包含 extern的声明具有文件作用域，则引用的变量必须具有外部链接。<span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>如果包含 extern的声明具有块作用域，则引用的变量可能具有外部链接或内部链接，这接取决于该变量的定义式声明。</p><h4 id="小结存储类别">小结：存储类别</h4><p><strong>自动变量</strong>具有<strong>块作用域、无链接、自动存储期</strong>。它们是局部变量，属于其定义所在块（通常指函数）私有<strong>。寄存器变量的属性和自动变量相同，但是编译器会使用更快的内存或寄存器储存它们。不能获取寄存器变量的地址。</strong></p><p>具有<strong>静态存储期的变量</strong>可以<strong>具有外部链接、内部链接或无链接。</strong>在同一个文件所有函数的外部声明的变量是外部变量，具有文件作用域、外部链接和静态存储期。如果在这种声明前面加上关键字static，那么其声明的变量具有文件作用域、内部链接和静态存储期。如果在函数中用static 声明一个变量，则该变量具有块作用域、无链接、静态存储期。</p><p><strong>具有自动存储期的变量</strong>，程序在进入该变量的声明所在块时才为其分配内存，在退出该块时释放之前分配的内存。如果未初始化，自动变量中是垃圾值。程序在编译时为具有静态存储期的变量分配内存，并在程序的运行过程中一直保留这块内存。如果未初始化，这样的变量会被设置为0。</p><p><strong>具有块作用域的变量</strong>是局部的，属于包含该声明的块私有。<strong>具有文件作用域的变量</strong>对文件（或翻译单元）中位于其声明后面的所有函数可见。<strong>具有外部链接的文件作用域变量</strong>，可用于该程序的其他翻译单元。<strong>具有内部链接的文件作用域变量</strong>，只能用于其声明所在的文件内。</p><h3 id="存储类别和函数">存储类别和函数</h3><p>函数也有存储类别，可以是外部函数（默认）或静态函数。C99 新增了第 3种类别——内联函数。</p><p><strong>外部函数可以被其他文件的函数访问，但是静态函数只能用于其定义所在的文件</strong>。假设一个文件中包含了以下函数原型：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">gamma</span><span class="params">(<span class="type">double</span>)</span>;   <span class="comment">/* 该函数默认为外部函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">beta</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> <span class="title function_">delta</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p>在同一个程序中，其他文件中的函数可以调用gamma()和delta()，但是不能调用beta()，因为以static存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题，由于beta()受限于它所在的文件，所以在其他文件中可以使用与之同名的函数。</p><p>通常的做法是：用 extern关键字声明定义在其他文件中的函数。这样做是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，否则一般函数声明都默认为extern。</p><h3 id="存储类别的选择">存储类别的选择</h3><p>对于“使用哪种存储类别”的回答绝大多数是“自动存储类别”，要知道默认类别就是自动存储类别。初学者会认为外部存储类别很不错，为何不把所有的变量都设置成外部变量，这样就不必使用参数和指针在函数间传递信息了。</p><p>然而，这背后隐藏着一个陷阱。如果这样做，A()函数可能违背你的意图，私下修改B()函数使用的变量。多年来，无数程序员的经验表明，随意使用外部存储类别的变量导致的后果远远超过了它所带来的便利。唯一例外的是const数据。因为它们在初始化后就不会被修改，所以不用担心它们被意外篡改：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> DAYS = <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * MSGS[<span class="number">3</span>] = {<span class="string">"Yes"</span>, <span class="string">"No"</span>, Maybe<span class="string">"};</span></span><br></pre></td></tr></tbody></table></figure><p>保护性程序设计的黄金法则是：“按需知道”原则。<strong>尽量在函数内部解决该函数的任务，只共享那些需要共享的变量。</strong>除自动存储类别外，其他存储类别也很有用。不过，在使用某类别之前先要考虑一下是否有必要这样做。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储类比 </tag>
            
            <tag> 作用域 </tag>
            
            <tag> 生存期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习 关于const的整理</title>
      <link href="/2024/07/27/C-const/"/>
      <url>/2024/07/27/C-const/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天回顾C++ 时候 发现遇到关于const的变量类型（底层const 顶层const常量指针 指针常量 常量引用…）又有点懵懵的了，然后又仔细复盘了一下最后整理了一下 也方便记忆</p></blockquote><blockquote><p>ps 虽然前面也写了相关的 但是我觉得这版好一些哈哈哈哈哈</p></blockquote><h2 id="引入">引入</h2><p>首先明确一下C/C++中的基本类型</p><p>在C/C++中，分为常量，变量，字面量三大类。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🍎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>常量，简单而言，就是数据类型前面加了const 的 ；</p><p>比如 const int a=2；</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🍌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>变量，就是正常的数据类型 比如，int a=0; float a=3.2;</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🍊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 字面量，就是用的各种字符串，数字，比如上面我提到的2，0，3.2等。</p><blockquote><p>具体可以自行百度 这不是重点</p></blockquote><p>另，要再讲讲指针变量这个东西。</p><p>指针变量也就只是一个数据类型而已，和intfloat等一样，int类型里面存储的是整型变量，float是浮点型，而指针变量存储的是变量的地址而已，我们可以通过对指针进行一系列操作，来对这个地址上的变量的值进行更改。具体可以看看这篇<a href="https://blog.csdn.net/qq_53131867/article/details/134937138?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172209044216800227480390%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=172209044216800227480390&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-12-134937138-null-null.nonecase&amp;utm_term=c&amp;spm=1018.2226.3001.4450">blog</a></p><hr><h2 id="顶层const和底层const">顶层const和底层const</h2><p>而本文的const变量 就是 “常量”的类型,由这个常量可以引入顶层const和底层const。</p><h3 id="顶层const">顶层const</h3><p>所谓顶层const就是一般的各种数据类型前面加上了const。对于任何数据类型都适用 算术类型类 指针等。如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> b=<span class="number">3.2</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p=&amp;a;<span class="comment">//p是一个const变量，是一个int*类型的；也就是这是一个int类型的常量指针（从右往左读）</span></span><br></pre></td></tr></tbody></table></figure><p>这种类型的const被成为顶层const。可以这样理解，这种类型的数据的值，一旦初始化就不可更改（所以叫顶层嘛）。具体的，一旦定义了a这个整型常量，a就不可更改了；定义了p这个<strong>指针常量</strong>（挺好记忆的，就是这个指针变量的值是一个常量，一经初始化地址不可更改），由于指针变量的值就是地址，所以p的值，也就是p指向的地址就不可更改了；</p><blockquote><p>同时 int cosnt 和const int类似的都是一个东西，所以不用太纠结。它们都是定义一个常量类型。</p></blockquote><h3 id="底层const">底层const</h3><p>所谓顶层const 与指针引用等复合类型部分相关。也就是我们常见的指向常量的指针，和常量引用（可以类比指向常量的指针 ，简称<strong>常量指针</strong>）。</p><p>不管是常量指针还是常量引用，它们都只负责一件事：<strong>仅仅要求不能用于改变所指对象的值</strong>，而没有规定那个对象的值不能通过其他途径改变。</p><p><strong>举个栗子</strong><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>比如，我用了这个指针变量，这个指针变量就不能用于改变所指对象的值，但是指针变量本身的地址是可以改变的，至于这个对象是不是const没关系，只是说不能用这个指针变量改变了。常量引用也是一样的意思。</p><p>具体一点</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=<span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p =&amp;j;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2=&amp;i;</span><br></pre></td></tr></tbody></table></figure><p>上面两个都是合法的，只是说，不能通过指针变量去更改j和i的值了，但是指针指向的地址可以后面再变化。</p><h2 id="总结一下">总结一下</h2><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>顶层const 可以理解为很普通的常量类型，在各个变量之前加一个const</p><p>底层const 与指针 引用等复合类型部分相关。</p><p>由这两组cosnt 催生出了指针常量（顶层const）和常量指针（底层const），前者，由于是顶层const，所以一旦初始化之后就不能够更改指针变量的值，也就是地址。而后者，仅仅要求不能用于改变所指对象的值</p><h3 id="一些练习">一些练习</h3><p>这些练习选于C++ Primer</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> v2= <span class="number">0</span>;<span class="type">int</span> v1 = v2;</span><br><span class="line"><span class="type">int</span> *pl = &amp;v1,&amp;r1 = v1;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;v2， *<span class="type">const</span> p3 = &amp;i,&amp;r2 = v2;</span><br><span class="line"><span class="comment">//判断下面的语句是否合法，声明如上。</span></span><br><span class="line">rl = v2;</span><br><span class="line">pl = p2; </span><br><span class="line">p2 = pl;</span><br><span class="line">pl = p3;</span><br><span class="line">p2 = p3;</span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>下面进行逐步的分析。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>rl是int类型的变量，v2是顶层const，简单理解为int类型的常量。</p><p>rl=v2，合法，就是一个简单的赋值操作。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>p1是int类型的指针，p2是底层const（也就是常量指针），p1=p2，可以这么理解，把p2的值（也就是p2指向的地址）赋值给p1的值（p1指向的地址）。但是我们知道p2是一个底层const，不能用于改变指向的值，也就是说既然选择用了p2这样的数据类型，那么其指向的地址的值默认不能随意被改变，从而起到一个保护的作用。而p1是一个普通的指针变量，可以随意改变指向地址的值。所以把p2赋值给p1是不安全的行为，是不合法的。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>如果要把p1​赋值给p2，最多就是p1指向的地址的值不能用p2进行随意更改了，变得更安全了，所以是合法的。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> p3 即const int *constp3=&amp;i；是顶层const也是底层const，和上面的同理，如果pl=p3那么pl就可以改变p3 所指的值和地址了。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>5⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0035-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> p2 = p3;这是合法的。p2得到了p3指向的地址，不能进行更改，而p3恰好也是一个底层const，其所指向的地址值不允许被更改，所以是合法的。</p><blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>ok ,完结 看到这里点个赞吧 ~~ 如有错误，欢迎批评指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> const </tag>
            
            <tag> 常量指针 </tag>
            
            <tag> 指针常量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业前夕</title>
      <link href="/2024/06/19/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95/"/>
      <url>/2024/06/19/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95/</url>
      
        <content type="html"><![CDATA[<p>记大水怪离别前一夜</p><p>四年前，怀着忐忑，失落，自卑，又无奈，又有稍许期许来到武汉。直到今天，大水怪走之后，才有一种，真的真的要离开的感觉。</p><p>今天和大傻在华师拍照，居然还有种，这种在武汉的生活还能持续好久好久。我还想带个饼给大水怪吃，然后跟她一起吃饼。然后他说，回去了，她要走了。然后心咯噔一下，真的，要分开了。后面新的人，新的事物，新的一切，开始新的旅程。</p><p><strong>“没有怎么办了，大学结束了。”</strong></p><p>真的真的好快，我们要各奔东西了，可能之后再也没有这种缘分了。刚开始的时候不知道珍惜，以为自己拥有很多，但是，后面失去了才知道后悔。真的真的得要珍惜了，好好把握。</p><blockquote><p>我好像还是太过于自以为是了，每次别人对我好，我都当作是实打实的，理所当然的。可是当我要付出的时候，我总是会去推辞别人，然后别人不理我了，然后再去巴巴地讨别人开心。人家回心转意之后，又开始周而复始。就这样一轮一轮的循环。</p></blockquote><p>回顾一下大学四年，我遇见了很多人，但是重心仍然是放在学习为基础上的。每天没日没夜的“假勤奋”，把题库背了，刷老师的好感度，然后绩点就巴巴地上去了。</p><p>我还记得大学遇到的第一个朋友是lwd，然后大二实验室选拔开始，就慢慢疏远了。因为她进了电赛实验室，一方面我觉得自卑，不想跟她在一起，另一方面，她估计也很忙，很快有了新的小伙伴。这个时候我和大水怪的结缘，然后慢慢和她熟识吧。她人也很好，找不到任何的缺点，很多人都喜欢她。她也如愿在实验室拿到优秀的成果。保送到很优秀很优秀的学府。她教会了我很多东西。很感谢她。</p><p>我不知道我们未来会怎么样，只知道当下什么是最要紧的。也许，也许，说不准未来会继续相遇。</p><p>感谢大水怪，感谢时间的相遇吧。</p><p>不管如何，每个人都有自己的际遇和机缘，总是会经历分别的。</p><p>从昨天晚上开始 一直到现在就想到这里还是会忍不住想要哭。其实昨天晚上剪视频，剪视频了好久好久。</p><blockquote><p>就是下面这个</p></blockquote><p><a href="https://www.bilibili.com/video/BV1EEgNeaERn/?share_source=copy_web&amp;vd_source=8d5f94cac4ef1f7256e3572189ec255b">【毕业快乐大水怪家族专属vlog~ 新一段旅途gogogo！】</a></p><p>我感觉是一个比较感性的人吧。一大段回忆过去了真的就感觉跟昨天似的。</p><p>也许有原生家庭的原因，还是讨好型人格吧。只要别人对我好一点，我就很开心。真的要变得强大强大起来吧。</p><p>毕竟后面，还有很长很长的路要走。没有人会陪着你一直走下去的，很多时候你得自己面对，不是吗？只是在一条一条的路上，会遇到很多很多人，很多很多事，在人生的旅途中留下很多深深浅浅的脚印，或是顺境或是逆境，最终 走到人生的尽头。</p><p>不说啦，又荒废了将近一个月了，明天组会不是我汇报，但是还是什么都没干。废废。就这样吧 继续努力了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习 关于const 上</title>
      <link href="/2024/05/31/const/"/>
      <url>/2024/05/31/const/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这篇blog 主要是想具体讲讲新学到的const 当然不止是const而是基于这个const引申出来的指针和引用。还是需要捋一捋的，这还是有点困难的。</p><p>我会把每一节的重点都摘出来，放在前面~</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>首先讲讲const</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>const引用和const指针 <span class="github-emoji" style="display:inline;vertical-align:middle"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 特别容易混淆</p><p>这边blog <a href="https://blog.csdn.net/weixin_43283397/article/details/109387374">常量指针/引用指针/引用常量 详细</a>讲的不错 可以看看~</p><h2 id="const-限定符">const 限定符</h2><blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>敲重点！</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🍎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>因为const对象一旦创建后其值就不能再改变,所以==const对象必须初始化==</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🍐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f350.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>只能在const类型的对象上执行不改变其内容的操作</strong></p></blockquote><p>有时我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。另一方面，也应随时<strong>警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关键字const对变量的类型加以限定:</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufsize = <span class="number">512</span>;<span class="comment">//输入缓冲区大小</span></span><br></pre></td></tr></tbody></table></figure><p>这样就把 bufsize定义成了一个常量。任何试图为bufsize赋值的行为都将引发错误:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufSize = <span class="number">512</span>;<span class="comment">//错误:试图向const对象写值</span></span><br></pre></td></tr></tbody></table></figure><p><strong>因为const对象一旦创建后其值就不能再改变,所以==const对象必须初始化==。</strong>一如既往，初始值可以是任意复杂的表达式:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = get_size();<span class="comment">//正确:运行时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=<span class="number">42</span>;<span class="comment">//正确:编译时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> k;<span class="comment">//错误:k是一个未经初始化的常量</span></span><br></pre></td></tr></tbody></table></figure><h4 id="初始化和const">初始化和const</h4><p>正如之前反复提到的，对象的类型决定了其上的操作。与非const类型所能参与的操作相比，const类型的对象能完成其中大部分，但也不是所有的操作都适合。主要的限制就是<strong>只能在const类型的对象上执行不改变其内容的操作</strong>。例如，constint和普通的int一样都能参与算术运算，也都能转换成一个布尔值，等等。</p><p>在不改变 const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;<span class="comment">//正确:i的值被拷贝给了ci</span></span><br><span class="line"><span class="type">int</span> j= ci;<span class="comment">//正确:ci的值被拷贝给了j</span></span><br></pre></td></tr></tbody></table></figure><p>尽管ci是整型常量，但无论如何ci中的值还是一个整型数。ci的常量特征仅仅在执行改变ci的操作时才会发挥作用。当用ci去初始化j时，根本无须在意ci是不是一个常量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。</p><h4 id="默认情况下const对象只在文件内有效">默认情况下，const对象只在文件内有效</h4><p>当以编译时初始化的方式定义一个const对象时，就如对bufsize的定义一样:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>;<span class="comment">//输入缓冲区大小</span></span><br></pre></td></tr></tbody></table></figure><p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufsize的地方，然后用512替换。</p><p>为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义（参见2.2.2节，第41页)。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。<strong>当多个文件中出现了同名的const变量时,其实等同于在不同文件中分别定义了独立的变量</strong>。</p><p>某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量)对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。</p><p>解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_1.cc定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = fcn() ;</span><br><span class="line"><span class="comment">// file_ 1.h头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;<span class="comment">//与file_1.cc中定义的bufsize是同一个</span></span><br></pre></td></tr></tbody></table></figure><p>如上述程序所示，file_1.cc定义并初始化了bufsize。因为这条语句包含了初始值，所以它(显然）是一次定义。然而，因为bufsize是一个常量，必须<strong>用extern加以限定使其被其他文件使用。</strong></p><p>file1.h头文件中的声明也由extern做了限定，其作用是指明bufsize并非本文件所独有，它的定义将在别处出现。</p><p><strong>如果想在多个文件之间共享const对象,必须在变量的定义之前添加extern关键字。</strong></p><h4 id="练习">练习</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.26:下面哪些句子是合法的?如果有不合法的句子，请说明为什么?</span></span><br><span class="line">(a) <span class="type">const</span> <span class="type">int</span> buf;</span><br><span class="line">(b) <span class="type">int</span> cnt =<span class="number">0</span></span><br><span class="line">(c) <span class="type">const</span> <span class="type">int</span> sz= cnt;</span><br><span class="line">(d)++cnt; ++SZ</span><br></pre></td></tr></tbody></table></figure><ol type="a"><li><code>const int buf;</code></li></ol><p>这个句子是不合法的。在C++中，<strong><code>const</code>关键字用于声明一个常量，它必须被初始化</strong>。因此，<code>const int buf;</code>缺少初始化表达式，正确的声明应该是<code>const int buf = 0;</code>。</p><ol start="2" type="a"><li><p><code>int cnt = 0;</code>这个句子是合法的。它声明了一个整型变量<code>cnt</code>并初始化为0。</p></li><li><p><code>const int sz = cnt;</code></p></li></ol><p>这个句子是不合法的。这里有两个问题：首先，<code>const</code>变量必须在声明时初始化，不能在声明后赋值。其次，即使<code>cnt</code>已经被声明并初始化，<code>sz</code>作为<code>const</code>变量也不能从非<code>const</code>变量<code>cnt</code>那里赋值。正确的做法是直接在声明时初始化，例如<code>const int sz = 5;</code>。</p><ol start="4" type="a"><li><code>++cnt; ++SZ;</code></li></ol><p>首先，<code>++cnt;</code>是合法的，它表示对变量<code>cnt</code>进行自增操作。然而，<code>++SZ;</code>是不合法的，因为<code>SZ</code>没有被声明为一个变量，而且变量名通常不以大写字母开头，这是C++中常见的命名约定，尽管这不是语法错误。如果<code>SZ</code>是一个未声明的变量，那么这个句子将导致编译错误。</p><h3 id="关于const-引用">关于const 引用</h3><blockquote><p>敲重点</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🍌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>常量的引用</strong> 不能用作修改被绑定的对象</p><p>也就是说 原来的数据类型是const xx 类型那么，对这个数据引用后就不能利用引用的变量去更改原有的值（好像有点绕具体看下文）</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>注意 <strong>常量的引用</strong> 和<strong>常量引用 </strong> 的不同 一个是被引用的变量 一个是变量本身下面看的时候要认真一些</p><p>常量的引用 数据类型需要一致相当于对一个const类型的变量进行引用，这个时候就叫<strong>常量的引用</strong></p><p>而<strong>常量引用</strong> 是一个引用类型的变量</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🍑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f351.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>在初始化<strong>常量引用</strong>时允许用任意表达式作为初始值,允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🍊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值:</p></blockquote><p>可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用（referencetoconst)。<strong>与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象:</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;  <span class="comment">//正确:引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>;<span class="comment">//错误:r1是对常量的引用</span></span><br><span class="line"><span class="type">int</span> &amp;r2=ci;<span class="comment">//错误:试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></tbody></table></figure><p>因为不允许直接为ci赋值，当然也就不能通过引用去改变ci。因此，对r2的初始化是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确的。</p><blockquote><p>常量引用是对const的引用</p></blockquote><p>程序员们经常把词组“对const的引用”简称为“常量引用”,这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已。</p><p>严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上,由于C+语言并不允许随意改变引用所绑定的对象,所以从这层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作,却无论如何都不会影响到引用和对象的绑定关系本身</p><h4 id="初始化和对const-的引用">初始化和对const 的引用</h4><p>2.3.1节（第46页）提到，引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是<strong>在初始化常量引用时允许用任意表达式作为初始值</strong>，只要该表达式的结果能转换成(参见2.1.2节，第32页）引用的类型即可。尤其，<strong>允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式:</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">42</span>;·</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;<span class="comment">//允许将const int&amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2=<span class="number">42</span>;  <span class="comment">//正确:r1是一个常量引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="comment">//正确:r3是一个常量引用</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = r1 * <span class="number">2</span>;<span class="comment">//错误:r4是一个普通的非常量引用</span></span><br></pre></td></tr></tbody></table></figure><p>要想理解这种例外情况的原因，<strong>最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么:</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;</span><br></pre></td></tr></tbody></table></figure><p>此处ri引用了一个int型的数。<strong>对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数</strong>。因此为了确保让ri绑定一个整数,编译器把上述代码变成了如下形式:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> temp =dval;</span><br><span class="line"><span class="comment">//由双精度浮点数生成一个临时的整型常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = temp;</span><br><span class="line"><span class="comment">// 让ri绑定这个临时量</span></span><br></pre></td></tr></tbody></table></figure><p>接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则为什么要给ri赋值呢?如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。</p><h4 id="对const的引用可能引用一个并非const-的对象">对const的引用可能引用一个并非const的对象</h4><p>必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;</span><br><span class="line"><span class="comment">//引用ri绑定对象i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;</span><br><span class="line"><span class="comment">// r2也绑定对象i，但是不允许通过r2修改i的值</span></span><br><span class="line">r1 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//r1并非常量，i的值修改为0</span></span><br><span class="line">r2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//错误:r2是一个常量引用</span></span><br></pre></td></tr></tbody></table></figure><p>r2绑定（非常量)整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值,也可以通过像r1一样绑定到i的其他引用来修改。</p><h3 id="指针和const">指针和const</h3><blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 敲重点​</p><p>和上一节一样 常量指针和指向常量的指针 这俩是不一样的！</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>⛵</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26f5.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>指向常量的指针</strong>指向常量的指针不能用于改变其所指向对象的值。存放常量对象的地址只能使用指向常量的指针。和引用一样，指向常量的指针没有规定所指向的对象是一个常量，仅仅要求<strong>不能通过该指针改变对象的值，没有规定那个对象的值不能通过其他途径改变。</strong></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f30a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>常量指针</strong> 必须初始化 一旦初始化，他的值（也就是存放再指针的地址）不会再改变了。*放在const之前说明指针是一个常量，也就是不变的是指针本身的值而不是指向的那个值</p><p>要想弄清楚声明的含义最行之有效的办法是从右向左阅读</p></blockquote><h4 id="指向常量的指针">指向常量的指针</h4><p>指向常量的指针不能用于改变其所指向对象的值。存放常量对象的地址只能使用指向常量的指针</p><p>带有前缀 const</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;<span class="comment">// pi是个常量，它的值不能改变</span></span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi;<span class="comment">//错误:ptr是一个普通指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;<span class="comment">//正确:cptr可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>;<span class="comment">//错误:不能给*cptr赋值</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;<span class="comment">//dval是一个双精度浮点数,它的值可以改变</span></span><br><span class="line">cptr = &amp;dval;<span class="comment">//正确:但是不能通过cptr改变dval的值</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>指针类型不一定要与所致的对象一致</p></blockquote><p>和引用一样，指向常量的指针没有规定所指向的对象是一个常量，仅仅要求<strong>不能通过该指针改变对象的值，没有规定那个对象的值不能通过其他途径改变。</strong></p><h4 id="常量指针">常量指针</h4><p><strong>常量指针必须初始化 一旦初始化，他的值（也就是存放再指针的地址）不会再改变了</strong></p><p>***放在const之前说明指针是一个常量，也就是不变的是指针本身的值而不是指向的那个值**</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb;<span class="comment">// curErr将一直指向errNumb</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi; <span class="comment">// pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></tbody></table></figure><p>如同2.3.3节(第52页）所讲的，要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。此例中，离curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是curErr是一个常量指针。最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。与之相似，我们也能推断出，pip是一个常量指针，它指向的对象是一个双精度浮点型常量。</p><p><strong>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型</strong>。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*pip = <span class="number">2.72</span>;</span><br><span class="line"><span class="comment">//错误:pip是一个指向常量的指针</span></span><br><span class="line"><span class="comment">//如果curErr所指的对象（也就是errNumb）的值不为0</span></span><br><span class="line"><span class="keyword">if</span>(*curErr) {</span><br><span class="line">    <span class="built_in">errorHandler</span> ();</span><br><span class="line">    *curErr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//正确:把curErr所指的对象的值重置</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="练习-1">练习</h4><blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🐋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f40b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ​ps 对于不确定的式子 可以代入代码敲一敲</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.27:下面的哪些初始化是合法的?请说明原因。</span></span><br><span class="line">(a)<span class="type">int</span> i = <span class="number">-1</span>,&amp;r = <span class="number">0</span>;</span><br><span class="line">(b) <span class="type">int</span> *<span class="type">const</span> p2 = &amp;i2;</span><br><span class="line">(c) <span class="type">const</span> <span class="type">int</span> i = <span class="number">-1</span>,&amp;r = <span class="number">0</span>;</span><br><span class="line">(d) <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = &amp;i2;</span><br><span class="line">(e) <span class="type">const</span> <span class="type">int</span> *pl = &amp;i2;</span><br><span class="line">(f)<span class="type">const</span> <span class="type">int</span> &amp;<span class="type">const</span> r2;</span><br><span class="line">(g)<span class="type">const</span> <span class="type">int</span> i2= i,&amp;r = i;</span><br><span class="line"><span class="comment">//练习2.28:说明下面的这些定义是什么意思，挑出其中不合法的。</span></span><br><span class="line">(a)<span class="type">int</span> i, *<span class="type">const</span> cp;</span><br><span class="line">(b)<span class="type">int</span> *p1, *<span class="type">const</span> p2;</span><br><span class="line">(C) <span class="type">const</span> <span class="type">int</span> ic,&amp;r = ic;</span><br><span class="line">(d) <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3;</span><br><span class="line">(e)<span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line"><span class="comment">//练习2.29:假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的?请说明原因。</span></span><br><span class="line">(a)i = ic;</span><br><span class="line">(b)p1 = p3;</span><br><span class="line">(c)p1 = &amp;ic;</span><br><span class="line">(d)p3 = &amp;ic;</span><br><span class="line">(e)p2= pl;</span><br><span class="line">(f)ic = *p3 ;</span><br></pre></td></tr></tbody></table></figure><hr><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🔑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f511.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>答案答案</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.27:下面的哪些初始化是合法的?请说明原因。</span></span><br><span class="line">(a) <span class="type">int</span> i = <span class="number">-1</span>,&amp;r = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">//可能一些小伙伴看不懂 这其实相当于 int i = -1,int &amp;r = 0;  </span></span><br><span class="line"><span class="comment">//  这类引用应初始化一个变量 而不是字面量 不合法（具体看引用篇）</span></span><br><span class="line">(b) <span class="type">int</span> *<span class="type">const</span> p2 = &amp;i2; </span><br><span class="line"><span class="comment">//p2 是一个常量指针  也就是地址不变的指针 如果i2是int类型的则合法， 只能指向int</span></span><br><span class="line">(c) <span class="type">const</span> <span class="type">int</span> i = <span class="number">-1</span>,&amp;r = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//正确  相当于const int &amp;r=0;  是一个常量引用 可以指向字面量</span></span><br><span class="line"><span class="comment">//在初始化常量引用时允许用任意表达式作为初始值,允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。</span></span><br><span class="line">(d) <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = &amp;i2; </span><br><span class="line"><span class="comment">//指向常量的常量指针 不可以用这个指针更改i2的值 同时这个指针的地址也不会变</span></span><br><span class="line"></span><br><span class="line">(e) <span class="type">const</span> <span class="type">int</span> *pl = &amp;i2; </span><br><span class="line"><span class="comment">//指向常量的指针  不可以用这个指针更改i2的值</span></span><br><span class="line"></span><br><span class="line">(f)<span class="type">const</span> <span class="type">int</span> &amp;<span class="type">const</span> r2; </span><br><span class="line"><span class="comment">//这个 应该是语法错误</span></span><br><span class="line"></span><br><span class="line">(g)<span class="type">const</span> <span class="type">int</span> i2= i,&amp;r = i; </span><br><span class="line"><span class="comment">// 相当于 const int &amp;r =i;</span></span><br><span class="line"><span class="comment">//如果i是常量 可以这么做</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.28:说明下面的这些定义是什么意思，挑出其中不合法的。</span></span><br><span class="line">(a)<span class="type">int</span> i, *<span class="type">const</span> cp;</span><br><span class="line"><span class="comment">//int *const cp  常量指针  初始化后不能变地址 也就是地址不能更改，且一定要初始化</span></span><br><span class="line">(b)<span class="type">int</span> *p1, *<span class="type">const</span> p2;</span><br><span class="line"><span class="comment">//int *const p2  常量指针  初始化后不能变地址 也就是地址不能更改，且一定要初始化 </span></span><br><span class="line">(C) <span class="type">const</span> <span class="type">int</span> ic,&amp;r = ic;</span><br><span class="line"><span class="comment">//需要初始化 const int &amp;r=ic  </span></span><br><span class="line">(d) <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3;</span><br><span class="line"><span class="comment">//需要初始化</span></span><br><span class="line">(e)<span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line"><span class="comment">//指向常量的指针 需要指向const int 类型的值   不能通过指针改变指向的值的内容</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.29:假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的?请说明原因。</span></span><br><span class="line">(a)<span class="type">int</span> i;<span class="type">const</span> <span class="type">int</span> ic;</span><br><span class="line">i = ic;</span><br><span class="line"><span class="comment">//合法  i只是用了ic的值 </span></span><br><span class="line">(b)<span class="type">int</span> *p1;<span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3;</span><br><span class="line">p1 = p3; </span><br><span class="line"><span class="comment">//int 指针变量 =指向int 的常量指针 类型不一致</span></span><br><span class="line"></span><br><span class="line">(c)<span class="type">int</span> *p1;<span class="type">const</span> <span class="type">int</span> ic</span><br><span class="line">p1 = &amp;ic;</span><br><span class="line"><span class="comment">//不合法 必须是const int *p1 才可</span></span><br><span class="line"></span><br><span class="line">(d) <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3;<span class="type">const</span> <span class="type">int</span> ic;</span><br><span class="line">p3 = &amp;ic;</span><br><span class="line"><span class="comment">//不合法 p3不可更改地址</span></span><br><span class="line"></span><br><span class="line">(e)<span class="type">int</span> *<span class="type">const</span> p2;<span class="type">int</span> *p1</span><br><span class="line">p2= pl;</span><br><span class="line"><span class="comment">//常量指针 值不可更改  p2</span></span><br><span class="line"><span class="comment">//pl已经初始化了 </span></span><br><span class="line"></span><br><span class="line">(f)<span class="type">const</span> <span class="type">int</span> ic;<span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3;</span><br><span class="line">  ic = *p3 ;</span><br><span class="line"><span class="comment">//不能  const类型 是常量 不可更改</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>完结 欢迎批评指正~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> const </tag>
            
            <tag> 常量指针 </tag>
            
            <tag> 指针常量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计emo的那一天</title>
      <link href="/2024/05/26/feelings/"/>
      <url>/2024/05/26/feelings/</url>
      
        <content type="html"><![CDATA[<h2 id="毕业了-emo-的一下午">毕业了 emo 的一下午</h2><p>今天上午本科毕设答辩 以老师们 “不知道在讲什么，没有听懂” 结束了</p><p>可以说打击还是比较大的 以及我要不要继续去准备后面的内容</p><p>还是要记录一下</p><p>我一直觉得我需要被别人认可，也一直想要获得别人认可的。</p><p>毕业设计做了一个导航相关的东西，和电子信息完全没有任何关系。以及因为那该死的虚荣心，去了985高校做完全不知道的领域，不了解的领域。最后纠结了好久好久，没有发朋友圈，只发了qq空间。以至于很多人不知道我的去向如何，也不想让别人知道我去了个不好的专业。家里母亲也一直在给我宣传我的事迹，只不过不知道我在学校是有多么菜。</p><p>我一直挺想做个优秀的人，然后得到别人的认可。但是我发现好像真的很难。这些年，我不清楚我的成绩绩点是怎么来的，好像什么都没有，我又是怀着侥幸的心理，保研上岸的。我好像，真的占了很多侥幸。</p><p>最后，来到曾经以为我很优秀的班主任那里，做着毕设。为了这个毕设，跟他交流了好几次，但是不管是PPT还是论文，我都是尽力能够完成的最好，但是事实确是我好像还是不太能够去得到他们说的可以，好。也许是我太过于愚笨，或者脑子不知道怎么转。最终在毕设答辩的时候，我还是不知道要怎么回复老师说的一些问题。我曾经以为我答辩这方面还是比较可以的，现在说，不行，真的不行。</p><p>以及班主任一步一步重复说的那些事儿，好像我每次都不太能够理解。这些年偷的懒，好像回来了。我现在好像就是一个废物。什么都不知道，不了解，不会做。</p><p>其实挺羡慕实验室那些同学的，或者说其他同学有一套自己的逻辑框架。而我，感觉就是东扯一点西扯一点，完全凑不出逻辑框架，拼命努力，但是还是努力的不太对。我还是比较愚钝的，也没有自己的逻辑思维框架，我现在想想，未来应该怎么解决。</p><p>或者说 未来的研究生几年，我会特别特别痛苦。</p><p>很痛苦。</p><p>毕业论文答辩完，本来是一件很放松，很快乐的事情。但是我并没有这个感觉。</p><p>我现在emo地想鼠。只是因为可恨的虚荣心。一点都不想面对。</p><p>最后的最后，我应该去想想我到底想要什么。以及，怎么样厚脸皮，不要脸地过完这一生把。毕竟日子确实还是要过下去的 对吧 。还是要想想怎么样 让自己变好吧也不能一直就这样吧</p><p>所以人就是要一辈子就这样不停地运转吗，突然哲学起来，高标准高要求？害。</p><h2 id="续">续</h2><p>关于昨天的emo</p><p>到几天也就是2024/5/27/10：54已经结束了</p><p>对</p><p>我emo 纠结了一天 关于优秀毕设答辩到底要不要去的问题</p><blockquote><p>补充一下 关于优秀毕设的答辩其实是在答辩之前就已经定好的，班主任比较看重我，对我的指导也很多，也就默认我要去，也就是一直不断鼓励我去变得更加优秀那个时候，我就一直在担心，担心自己不行不好</p></blockquote><p>其实昨天我答辩完我就一直在emo因为老师问的几个问题都没怎么回答上来，ppt也被说做的不太规范“你这ppt得大改，讲的一点都不好” 然后就很emo 感觉自己真的不行</p><p>说实话我也知道班主任确实是很希望我好 恨铁不成钢的那种而且他们提出的问题确实也是一针见血 一语中的</p><p>但是问题是 我感觉我就是不喜欢被别人说别人说了也不太愿意去改的那种</p><p>其实真正的 应该是去 认真去听取别人的意见然后思量之后再做考虑。现在冷静下来才想到这些。</p><p>之前我想的都是 要不要去</p><p>去的话：反正我之后也是研究这个方向也有不少的汇报要做，研究生期间还有更多的刁钻问题要去解决就当作是一个平台预训练</p><p>不去的话： 班主任指导了我这么久花了很多时间和精力，这么做是不是对不起他，之前又说去现在又说不去；再一个就是，自己确实做的不行，很多基础性的东西也都讲不出来，被问到了怕丢脸；也怕丢班主任的脸面</p><p>就这样纠结来纠结去</p><p>一直到了当天晚上，和大水怪去看毕业晚会，其实主要是舍友有在表演，关系还不错，她还说要跟我拍照来着。其实最后还是没有拍，微信也没有回复。（看起来我是有点惨）就是说，我去晚会完全是为了看她，但是。。。也没啥，也算是弥补一下好久好久都没有看过的晚会了。但是晚会虽然全程有点心不在焉，但是还是消除了我的一些杂七杂八的影响</p><p>一直到看完晚会回来的时候，还在纠结要不要去。聊天框上已经打好委婉拒绝不去的消息了，一直到今天上午，才发出去。。。</p><p>发出去的一个点就是看了知乎一大堆的关于个人选择性格什么的问题。。。https://www.zhihu.com/question/19868216看了之后真的有让人想要改变自己 重新开始</p>]]></content>
      
      
      <categories>
          
          <category> 成长碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emo </tag>
            
            <tag> 心情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 指针上</title>
      <link href="/2024/05/21/pointer1/"/>
      <url>/2024/05/21/pointer1/</url>
      
        <content type="html"><![CDATA[<p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🙋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 继续C++ Primer 第五版的学习</p><p>可以先看看这两篇 或许可以进一步加深一下对指针的理解</p><p><a href="https://blog.csdn.net/qq_53131867/article/details/134937138?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171630129616800211536873%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=171630129616800211536873&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-134937138-null-null.nonecase&amp;utm_term=%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4450">指针和数组</a></p><p><a href="https://blog.csdn.net/qq_53131867/article/details/134842073?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171630129616800211536873%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=171630129616800211536873&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-4-134842073-null-null.nonecase&amp;utm_term=%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4450">指针简介</a></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 上一次讲了 C++中的引用，总结一下指针和引用的主要区别。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>指针是一个变量，其存储的是另一个变量的地址。而引用是一个别名，它和被它引用的变量共享同一内存地址。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>指针可以被赋予空值（即<code>NULL</code>），而引用必须在定义时初始化，并且不能被赋予空值。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>对指针的操作不会影响其指向的变量，除非通过指针进行赋值或解引。而对引用的操作会影响其引用的变量。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>下面就开始指针的学习叭~</p><h2 id="指针">指针</h2><p>指针(pointer）是“指向（pointto)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。</p><p><strong>其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象</strong>。</p><p><strong>其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</strong></p><p>定义指针类型的方法将声明符写成*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号*:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip1, *ip2;<span class="comment">//ip1和ip2都是指向int型对象的指针</span></span><br><span class="line"><span class="type">double</span> dp,*dp2;<span class="comment">// dp2是指向double型对象的指针，dp是double型对象</span></span><br></pre></td></tr></tbody></table></figure><h3 id="获取对象的地址">获取对象的地址</h3><p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;):</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">//p存放变量ival的地址，或者说p是指向变量ival的指针</span></span><br></pre></td></tr></tbody></table></figure><p>第二条语句把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象。<strong>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</strong></p><p>一般而言，所有指针的类型都要和它所指向的对象严格匹配。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval;</span><br><span class="line"><span class="type">double</span> *pd = &amp;dval;<span class="comment">//正确:初始值是double型对象的地址</span></span><br><span class="line"><span class="type">double</span> *pd2 = pd; <span class="comment">//正确:初始值是指向 double对象的指针</span></span><br><span class="line"><span class="type">int</span> *pi = pd;</span><br><span class="line"><span class="comment">//错误:指针pi的类型和pd的类型不匹配</span></span><br><span class="line">pi = &amp;dval;</span><br><span class="line"><span class="comment">//错误:试图把double型对象的地址赋给int型指针</span></span><br></pre></td></tr></tbody></table></figure><p>因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。</p><h3 id="指针的值">指针的值</h3><p>指针的值（即地址）应属下列4种状态之一:</p><p>1．指向一个对象。</p><p>2．指向紧邻对象所占空间的下一个位置。</p><p>3．空指针，意味着指针没有指向任何对象。</p><p>4．无效指针，也就是上述情况之外的其他值。</p><p>试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。</p><p>尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。</p><h3 id="利用指针访问对象">利用指针访问对象</h3><p>如果指针指向了一个对象，则允许**使用解引用符（操作符*）来访问该对象:**</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p存放着变量ival的地址，或者说p是指向变量ival的指针*</span></span><br><span class="line">*<span class="built_in">cout</span>&lt;&lt;*p;<span class="comment">//由符号*得到指针p所指的对象，输出42</span></span><br></pre></td></tr></tbody></table></figure><p>对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//由符号*得到指针p所指的对象，即可经由p为变量ival赋值</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p;<span class="comment">//输出0</span></span><br></pre></td></tr></tbody></table></figure><p>如上述程序所示，为*p赋值实际上是为p所指的对象赋值。解引用操作仅适用于那些确实指向了某个对象的有效指针。</p><p><strong>关键概念:某些符号有多重含义</strong></p><p>像&amp;和*这样的符号,既能用作表达式里的运算符,也能作为声明的一部分出现,符号的上下文决定了符号的意义:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i= <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r =i;<span class="comment">//&amp;紧随类型名出现，因此走声明的一部分，r是一个引用</span></span><br><span class="line"><span class="type">int</span> *p;<span class="comment">//*紧随类型名出现，因此是声明的一部分,p是一个指针</span></span><br><span class="line">p = &amp;i;<span class="comment">//&amp;出现在表达式中，是一个取地址符</span></span><br><span class="line">*p= i;<span class="comment">//*出现在表达式中，是一个解引用符</span></span><br><span class="line"><span class="type">int</span> &amp;r2= *p;<span class="comment">//&amp;是声明的一部分，*是一个解引用符</span></span><br></pre></td></tr></tbody></table></figure><p>在声明语句中,&amp;和*用于组成复合类型;在表达式中,它们的角色又转变成运算符。在不同场景下出现的虽然是同一个符号,但是由于含义截然不同,所以我们完全可以把它当作不同的符号来看待。</p><h3 id="空指针">空指针</h3><p>空指针（nullpointer）不指向任何对象，在试图使用个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pl = nullptr;</span><br><span class="line"><span class="comment">//等价于int *pl = 0;</span></span><br><span class="line"><span class="type">int</span> *p2 =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//直接将p2初始化为字面常量0</span></span><br><span class="line"><span class="comment">//需要首先#include cstdlib</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//等价于int *p3 = 0;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>得到空指针最直接的办法就是<strong>用字面值nullptr来初始化指针</strong>，这也是CH+11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成(参见2.1.2节，第32页)任意其他的指针类型。另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。</p><p>过去的程序还会用到一个名为NULL 的预处理变量(preprocessorvariable）来给指针赋值,这个变量在头文件cstdlib中定义，它的值就是0。</p><p>2.6.3节（第68页）将稍微介绍一点关于预处理器的知识，现在只要知道预处理器是运行于编译过程之前的一段程序就可以了。预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须在前面加上std: :</p><p>当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用NUL初始化指针和用0初始化指针是一样的。在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。</p><p>把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> zero= <span class="number">0</span>;</span><br><span class="line">pi = zero;</span><br><span class="line"><span class="comment">//错误:不能把int 变量直接赋给指针</span></span><br></pre></td></tr></tbody></table></figure><p><strong>初始化指针</strong></p><p>使用未经初始化的指针是引发运行时错误的一大原因。和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃,而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。</p><p>在大多数编译器环境下,如果使用了未经初始化的指针,则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针,相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是,如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。</p><p>因此建议初始化所有的指针，并且在可能的情况下,尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处,就把它初始化为nullptr或者0,这样程序就能检测并知道它没有指向任何具体的对象了。</p><h3 id="赋值和指针">赋值和指针</h3><p>指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是<strong>引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。</strong></p><p>指针和它存放的地址之间就没有这种限制了。<strong>和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象:</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *pi = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//pi被初始化，但没有指向任何对象</span></span><br><span class="line"><span class="type">int</span> *pi2 = &amp;i;</span><br><span class="line"><span class="comment">//pi2被初始化，存有i的地址</span></span><br><span class="line"><span class="type">int</span> *pi3;</span><br><span class="line"><span class="comment">//如果pi3定义于块内，则pi3的值是无法确定的</span></span><br><span class="line">pi3 = pi2;</span><br><span class="line"><span class="comment">// pi3和pi2指向同一个对象i</span></span><br><span class="line">pi2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//现在pi2不指向任何对象了</span></span><br></pre></td></tr></tbody></table></figure><p>有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易,最好的办法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时，</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi = &amp;ival;</span><br><span class="line"><span class="comment">//pi的值被改变，现在pi指向了ival</span></span><br></pre></td></tr></tbody></table></figure><p>意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。相反的，如果写出如下语句:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pi = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//ival的值被改变，指针pi并没有改变</span></span><br></pre></td></tr></tbody></table></figure><p>则* pi（也就是指针pi指向的那个对象）发生改变。</p><h3 id="其他指针操作">其他指针操作</h3><p>只要指针拥有一个合法值,就能将它用在条件表达式中。和采用算术值作为条件（参见2.1.2节，第32页）遵循的规则类似，如果指针的值是0,条件取false:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = <span class="number">0</span>;<span class="comment">// pi合法，是一个空指针</span></span><br><span class="line"><span class="type">int</span> *pi2 = &amp;ival;<span class="comment">// pi2是一个合法的指针存放着ival的地址</span></span><br><span class="line"><span class="keyword">if</span> (pi)<span class="comment">//pi的值是0，因此条件的值是false</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (pi2)<span class="comment">// pi2指向ival，因此它的值不是0，条件的值是true</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>任何非0指针对应的条件值都是true。</p><p>对于两个类型相同的合法指针，可以用相等操作符(==）或不相等操作符(!=）来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等;反之它们不相等。这里两个指针存放的地址值相同(两个指针相等）有三种可能:它们都为空、都指向同一个对象，或者都指向了同一个对象的下一地址。</p><p>需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。</p><p>因为上述操作要用到指针的值，所以不论是作为条件出现还是参与比较运算，都必须使用合法指针，使用非法指针作为条件或进行比较都会引发不可预计的后果。</p><p>3.5.3节（第105页）将介绍更多关于指针的操作。</p><h3 id="void-指针">void* 指针</h3><p>void<em>是一种特殊的指针类型,可用于存放任意对象的地址。一个void </em>指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> obj= <span class="number">3.14</span>, *pd = &amp;obj;</span><br><span class="line"><span class="comment">//正确:void*能存放任意类型对象的地址</span></span><br><span class="line"><span class="type">void</span> *pv = &amp;obj;</span><br><span class="line"><span class="comment">// obj可以是任意类型的对象</span></span><br><span class="line">pv = pd;</span><br><span class="line"><span class="comment">//pv可以存放任意类型的指针</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>利用void<em>指针能做的事儿比较有限:拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个 void </em>指针。**不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。**</p><p>概括说来，以void *的视角来看内存空间也就仅仅是内存空间,没办法访问内存空间中所存的对象，关于这点将在19.1.1节（第726页）有更详细的介绍，4.11.3节（第144页)将讲述获取void*指针所存地址的方法。</p><h3 id="练习">练习</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.18:编写代码分别更改指针的值以及指针所指对象的值。</span></span><br><span class="line"><span class="comment">//练习2.19:说明指针和引用的主要区别。</span></span><br><span class="line"><span class="comment">//练习2.20:请叙述下面这段代码的作用。</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *pl = &amp;i;</span><br><span class="line">*p1 = *p1 * *pl;</span><br><span class="line"><span class="comment">//练习2.21:请解释下述定义。在这些定义中有非法的吗?如果有，为什么?</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">(a) <span class="type">double</span>* dp = &amp;i; (b)<span class="type">int</span> *ip = i; (c) <span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="comment">//练习2.22:假设p是一个int型指针，请说明下述代码的含义。</span></span><br><span class="line"><span class="keyword">if</span> (p)<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span>(*p)<span class="comment">// ...</span></span><br><span class="line"><span class="comment">//练习2.23:给定指针p，你能知道它是否指向了一个合法的对象吗?如果能，叙述判断的思路;如果不能，也请说明原因。</span></span><br><span class="line"><span class="comment">//练习2.24:在下面这段代码中为什么p合法而lp非法?</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">void</span> *p = &amp;i;</span><br><span class="line"><span class="type">long</span> * lp = &amp;i;</span><br></pre></td></tr></tbody></table></figure><hr><h4 id="答案">答案</h4><p>答案<span class="github-emoji" style="display:inline;vertical-align:middle"><span>🏮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3ee.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.18:编写代码分别更改指针的值以及指针所指对象的值。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">int</span> *q = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改指针的值</span></span><br><span class="line">p = q; <span class="comment">// 现在p和q指向相同的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改指针所指对象的值</span></span><br><span class="line">*p = <span class="number">20</span>; <span class="comment">// 现在a的值变为20</span></span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.19:说明指针和引用的主要区别。</p><ol type="1"><li>指针是一个变量，其存储的是另一个变量的地址。而引用是一个别名，它和被它引用的变量共享同一内存地址。</li><li>指针可以被赋予空值（即<code>NULL</code>），而引用必须在定义时初始化，并且不能被赋予空值。</li><li>对指针的操作不会影响其指向的变量，除非通过指针进行赋值或解引。而对引用的操作会影响其引用的变量。</li></ol><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.20:请叙述下面这段代码的作用。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *pl = &amp;i;</span><br><span class="line">*p1 = *p1 * *pl;</span><br></pre></td></tr></tbody></table></figure><p>它首先定义了一个整型变量<code>i</code>并赋值为42，然后定义了一个指向<code>i</code>的指针<code>pl</code>。接着，它尝试通过<code>p1</code>修改<code>p1</code>所指向的变量的值，使其变为<code>p1</code>所指向的值与<code>i</code>值的乘积。</p><p>就是说先定义并初始化了一个变量i，然后pl指向i，也就是<em>pl就是i的值，即42，然后</em>pl= <em>p1 </em> <em>pl; 于是 </em>pl=42 <em>42；又由于然后pl指向i，所以i此时也被更改为42 </em> 42</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.21:请解释下述定义。在这些定义中有非法的吗?如果有，为什么?</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">(a) <span class="type">double</span>* dp = &amp;i; (b)<span class="type">int</span> *ip = i; (c) <span class="type">int</span> *p = &amp;i;</span><br></pre></td></tr></tbody></table></figure><ol type="a"><li><p>非法。因为<code>i</code>是整型变量，而<code>double</code>类型和整型不兼容。</p></li><li><p>非法。因为<code>i</code>是一个整型变量，不能直接作为指针赋值。</p></li><li><p>合法</p></li></ol><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>5⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0035-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.22:假设p是一个int型指针，请说明下述代码的含义。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p)<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span>(*p)<span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>if(p)</code>检查<code>p</code>是否不为<code>NULL</code>，即<code>p</code>是否指向了一个有效的内存地址。</li><li><code>if(*p)</code>检查<code>p</code>所指向的内存地址的内容是否不为零（或其他非真值）。</li></ul><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>6⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0036-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.23:给定指针p，你能知道它是否指向了一个合法的对象吗?如果能，叙述判断的思路;如果不能，也请说明原因。</p><p>不能。判断指针是否指向一个合法的对象，需要检查指针是否为<code>NULL</code>，以及它所指向的地址是否有效。然而，这并不总是安全的，因为指针可能指向一个有效的地址，但该地址的内容可能是不合法的或者已经被释放。</p><p>所以不论是作为条件出现还是参与比较运算，都必须使用合法指针，使用非法指针作为条件或进行比较都会引发不可预计的后果。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>7⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0037-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>练习2.24:在下面这段代码中为什么p合法而lp非法?</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">void</span> *p = &amp;i;</span><br><span class="line"><span class="type">long</span> * lp = &amp;i;</span><br></pre></td></tr></tbody></table></figure><p>void* 是一种特殊的指针类型,可用于存放任意对象的地址。一个void *指针存放着一个地址。在这段代码中，<code>p</code>是合法的，因为它被初始化为指向<code>i</code>的地址，这是一个有效的整型地址。</p><p><code>lp</code>是非法的，因为<code>int</code>和<code>long</code>类型不兼容。虽然<code>lp</code>被赋予了<code>i</code>的地址，但这个地址对于<code>long</code>类型的数据是不正确的，因此这种用法是非法的。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习 关于引用</title>
      <link href="/2024/05/21/rvalue-reference/"/>
      <url>/2024/05/21/rvalue-reference/</url>
      
        <content type="html"><![CDATA[<p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🙋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>本文主要讲讲C++的引用 是基础入门篇~</p><blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 关于引用 几个比较重要的点</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>引用相当于<strong>为一个已经存在的对象所起的另外一个名字</strong></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong></p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌺</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 另外要注意 类型不能混用</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🐳</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f433.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>相信看完后 你会有所收获~</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>⛵</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26f5.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li>引用并非对象</li><li>引用必须初始化</li><li>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</li><li>类型要严格匹配</li></ul></blockquote><h1 id="引用">引用</h1><p>C++11中新增了一种引用:所谓的<strong>“右值引用(rvaluereference)”,我们将在13.6.1节(第471页)做更详细的介绍。这种引用主要用于内置类</strong>。严格来说,当我们使用术语“引用（reference)”时，指的其实是“左值引用（Ivaluereference)”。</p><p>引用（reference）为对象起了另外一个名字，<strong>引用类型引用(refersto)另外一种类型</strong>。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival =<span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival;</span><br><span class="line"><span class="comment">// refVal 指向ival（是ival的另一个名字)</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2;</span><br><span class="line"><span class="comment">//报错:引用必须被初始化</span></span><br></pre></td></tr></tbody></table></figure><p>一般在初始化变量时，初始值会被拷贝到新建的对象中。<strong>然而定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</strong></p><p>引用并非对象，相反的，<strong>它只是为一个已经存在的对象所起的另外一个名字。</strong></p><p>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refval = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//把2赋给refVal指向的对象，此处即是赋给了ival</span></span><br><span class="line"><span class="type">int</span> ii = refval;<span class="comment">//与ii = ival执行结果一样</span></span><br></pre></td></tr></tbody></table></figure><p>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确: refval3绑定到了那个与refval绑定的对象上，这里就是绑定到ival上</span></span><br><span class="line"><span class="type">int</span> &amp;refVal3 = refVal;</span><br><span class="line"><span class="comment">//利用与refval绑定的对象的值初始化变量i</span></span><br><span class="line"><span class="type">int</span> i = refval; <span class="comment">//正确:i被初始化为ival的值</span></span><br></pre></td></tr></tbody></table></figure><p>因为引用本身不是一个对象，所以<strong>不能定义引用的引用。</strong></p><h2 id="引用的定义">引用的定义</h2><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =<span class="number">1024</span>,i2 =<span class="number">2048</span>;<span class="comment">// i和i2都是int</span></span><br><span class="line"><span class="type">int</span> &amp;r = i, r2= i2; <span class="comment">// r是一个引用，与i绑定在一起，r2是int</span></span><br><span class="line"><span class="type">int</span> i3 = <span class="number">1024</span>, &amp;ri = i3;<span class="comment">// i3是int,ri是一个引用，与i3绑定在一起</span></span><br><span class="line"><span class="type">int</span> &amp;r3 = i3,&amp;r4= i2; <span class="comment">// r3和r4都是引用</span></span><br></pre></td></tr></tbody></table></figure><p>除了2.4.1节（第55页）和15.2.3节(第534页）将要介绍的两种例外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，<strong>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</strong>，相关原因将在2.4.1节详述:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;refVal4 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//错误:引用类型的初始值必须是一个对象</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal5 = dval;</span><br><span class="line"><span class="comment">//错误:此处引用类型的初始值必须是int型对象</span></span><br></pre></td></tr></tbody></table></figure><h2 id="练习">练习</h2><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>👊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 检验一下成果叭~​</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.15:下面的哪个定义是不合法的?为什么?</span></span><br><span class="line">(a)<span class="type">int</span> ival = <span class="number">1.01</span>;</span><br><span class="line">(b) <span class="type">int</span> &amp;rval1 = <span class="number">1.</span></span><br><span class="line">(c)<span class="type">int</span> &amp;rval2 = ival;</span><br><span class="line">(d) <span class="type">int</span> &amp;rval3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2.16:考查下面的所有赋值然后回答:哪些赋值是不合法的?为什么?哪些赋值是合法的?它们执行了什么样的操作?</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,&amp;rl = i;</span><br><span class="line"><span class="type">double</span> d= <span class="number">0</span>,&amp;r2=d;</span><br><span class="line">(a) r2 = <span class="number">3.14159</span>;</span><br><span class="line">(b)r2= rl;</span><br><span class="line">(c) i = r2;</span><br><span class="line">(d)rl = d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2.17:执行下面的代码段将输出什么结果?</span></span><br><span class="line"><span class="type">int</span> i, &amp;ri = i;</span><br><span class="line">i = <span class="number">5</span>; ri = <span class="number">10</span>;</span><br><span class="line">std::cout&lt;&lt; i&lt;&lt;<span class="string">" "</span>&lt;&lt;ri &lt;&lt;std::endl;</span><br></pre></td></tr></tbody></table></figure><hr><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>答案答案</p><blockquote><p>//练习2.15:下面的哪个定义是不合法的?为什么?</p></blockquote><ol type="a"><li><p><code>int ival = 1.01;</code>是不合法的。因为<code>int</code>类型只能存储整数，不能存储浮点数<code>1.01</code>。</p></li><li><p><code>int &amp;rval1 = 1;</code>是不合法的。因为<code>1</code>是一个字面量，它代表了整数1，但字面量不能被直接赋值给引用。而且，引用的定义需要一个已存在的变量作为其目标。</p></li><li><p><code>int &amp;rval2 = ival;</code>是合法的，假设<code>ival</code>已经正确定义并且是一个<code>int</code>类型的变量。</p></li><li><p><code>int &amp;rval3;</code>是合法的，但<code>rval3</code>未被初始化，它将包含未定义的值。</p></li></ol><blockquote><p>练习2.16:考查下面的所有赋值然后回答:哪些赋值是不合法的?为什么?哪些赋值是合法的?它们执行了什么样的操作?</p></blockquote><ol type="a"><li><p><code>r2 = 3.14159;</code>是合法的。它将<code>double</code>类型的字面量<code>3.14159</code>赋值给<code>r2</code>，<code>r2</code>是一个<code>double</code>类型的引用。</p></li><li><p><code>r2 = rl;</code>是不合法的。因为<code>rl</code>是一个<code>int</code>类型的引用，而<code>r2</code>是一个<code>double</code>类型的引用。类型不匹配。</p></li><li><p><code>i = r2;</code>是不合法的。因为<code>i</code>是一个<code>int</code>类型的变量，而<code>r2</code>是一个<code>double</code>类型的引用。尝试将一个<code>double</code>类型的值赋给一个<code>int</code>类型的变量会导致数据丢失。</p></li><li><p><code>rl = d;</code>是合法的，但可能导致数据丢失。因为<code>rl</code>是一个<code>int</code>类型的引用，而<code>d</code>是一个<code>double</code>类型的值。<code>int</code>类型不能准确表示<code>double</code>类型的值，所以只有<code>d</code>的整数部分会被存储在<code>rl</code>指向的<code>int</code>类型变量中。</p></li></ol><blockquote><p>练习2.17:执行下面的代码段将输出什么结果?</p></blockquote><p>虽然<code>i</code>的值被<code>5</code>所赋值，随后<code>ri</code>被赋值为<code>10</code>，但<code>std::cout</code>会输出<code>i</code>和<code>ri</code>当前的值（不是所赋的值），此时<code>i</code>由于<code>ri</code>的赋值操作而覆盖了原本的值，<code>ri</code>输出为<code>10</code>。引用只是为其他变量提供了一个别名，并不复制原变量的值。所以<code>i</code>也是<code>10</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习  关于无符号数的计算</title>
      <link href="/2024/05/20/C-Calculation-of-unsigned-numbers/"/>
      <url>/2024/05/20/C-Calculation-of-unsigned-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="c-学习-关于无符号数的计算">C++ 学习 关于无符号数的计算</h1><blockquote><p>这篇blog 来源于C++ 的学习 当然C语言同样适用</p><p>C++ Primer 的笔记</p></blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>让我们从一个问题开始 如果你回答对了 那么就可以跳过了~</p><p>对于下面的问题</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读程序写结果。</span></span><br><span class="line"><span class="type">unsigned</span> u = <span class="number">10</span>,u2= <span class="number">42</span>;</span><br><span class="line">std::cout &lt;&lt; u2 - u&lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;u - u2 &lt;&lt; std:: endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>,i2 =<span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt; i2 -i&lt;&lt; std::endl;  </span><br><span class="line">std::cout &lt;&lt; i - i2&lt;&lt; std::endl; </span><br><span class="line">std::cout &lt;&lt; i - u&lt;&lt; std::endl; </span><br><span class="line">std::cout &lt;&lt; u- i&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> k1 = <span class="number">42</span>,k2 = <span class="number">10</span>;</span><br><span class="line">std::cout&lt;&lt;k2-k1&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;k1-k2&lt;&lt;std::endl;</span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>尝试一下最终输出什么结果</p><hr><p>揭晓答案！</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">4294967264</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">-32</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4294967264</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></tbody></table></figure><p>🤭 你答对了嘛 没有的话 可以接下去看（我刚开始也是懵的其实~）</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌺</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 首先明确一下，不管是C还是C++ 类型都是很重要的！所以先看看类型转换相关的内容，然后再来讨论上面无符号表达式转换的内容~</p><h2 id="关于类型转化">关于类型转化</h2><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>C/C++里面类型是很重要的！你能判断出下面每执行一行后，相应变量的值不？（嘻嘻梅开二度~）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b=<span class="number">32</span>;</span><br><span class="line"><span class="type">int</span> i=b;</span><br><span class="line">i=<span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> pi=i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c= <span class="number">-1</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> c2=<span class="number">256</span>;</span><br></pre></td></tr></tbody></table></figure><hr><p>答案揭晓！</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b=<span class="number">32</span>;<span class="comment">//b为真</span></span><br><span class="line"><span class="type">int</span> i=b;<span class="comment">//i=1</span></span><br><span class="line">i=<span class="number">3.14</span>;<span class="comment">//i=3</span></span><br><span class="line"><span class="type">double</span> pi=i;<span class="comment">//pi=3.0</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c= <span class="number">-1</span>;<span class="comment">//若char 为8bit c为255</span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> c2=<span class="number">256</span>; <span class="comment">//若char 为8bit 那么c2是未定义的 溢出啦</span></span><br></pre></td></tr></tbody></table></figure><p>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false,否则结果为true。</p><p>当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true 则结果为1。</p><p>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</p><p>当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</p><p>当我们赋给无符号类型一个超出它表示范围的值时,结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsignedchar可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsignedchar所得的结果是255。</p><p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的(undefined)。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</p><h2 id="含有无符号类型的表达式">含有无符号类型的表达式</h2><p>尽管我们不会故意给无符号对象赋一个负值，却可能(特别容易)写出这么做的代码。例如,<strong>当一个算术表达式中既有无符号数又有int值时，</strong><strong>那个int值就会转换成无符号数</strong>。把int转换成无符号数的过程和把int直接赋给无符号变量一样:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> u= <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i =<span class="number">-42</span>;</span><br><span class="line">std::cout &lt;&lt; i+i&lt;&lt; std::endl; <span class="comment">//输出-84</span></span><br><span class="line">std::cout&lt;&lt; u +i &lt;&lt; std::endl;<span class="comment">//如果int占32位，输出4294967264</span></span><br><span class="line"><span class="comment">//理由是 int 是8个字节 那就是32位 最大为2的32次方-1 也就是4294967295  也就是当-42  先转无符号数（也就是-1对应的是4294967295，依次类推）然后相加 </span></span><br><span class="line"><span class="comment">//10+（-42）=10+（4294967295-42+1）=4294967264</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>关于无符号数和有符号数</p><p><a href="https://www.cnblogs.com/lazycoding/archive/2011/03/21/unsigned-signed.html">理解有符号数和无符号数</a></p></blockquote><p>在第一个输出表达式里，两个（负）整数相加并得到了期望的结果。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>在第二个输出表达式里，相加前首先<strong>把整数-42转换成无符号数。把负数转换成无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。</strong></p><p>当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> ul = <span class="number">42</span>，u2 = <span class="number">10</span>;</span><br><span class="line">std::cout&lt;&lt; ul -u2&lt;&lt; std::endl; <span class="comment">//正确:输出32</span></span><br><span class="line">std::cout &lt;&lt; u2 - ul&lt;&lt; std::endl;<span class="comment">//正确:不过，结果是取模后的值  也是 10-42=10+（-42）=10+（4294967295-42+1）=4294967264</span></span><br></pre></td></tr></tbody></table></figure><p>无符号数不会小于0这一事实<strong>同样关系到循环的写法</strong>。例如，在1.4.1节的练习(第11页)中需要写一个循环，通过控制变量递减的方式把从10到0的数字降序输出。这个循环可能类似于下面的形式:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">std:: cout&lt;&lt; i &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure><p>可能你会觉得反正也不打算输出负数，可以用无符号数来重写这个循环。然而，这个不经意的改变却意味着死循环:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:变量u永远也不会小于0，循环条件一直成立</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> u= <span class="number">10</span>; u &gt;= <span class="number">0</span>;--u)</span><br><span class="line">std::cout&lt;&lt;u&lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure><p>来看看当u等于0时发生了什么，这次迭代输出0，然后继续执行for语句里的表达式。表达式--u从u当中减去1，得到的结果-1并不满足无符号数的要求，此时像所有表示范围之外的其他数字一样，<strong>-1被自动地转换成一个合法的无符号数。假设int类型占32位，则当u等于0时，--u的结果将会是4294967295。</strong></p><p>一种解决的办法是，用while语句来代替for语句，因为前者让我们能够在输出变量之前（而非之后）先减去1:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> u= <span class="number">11</span>;<span class="comment">//确定要输出的最大数，从比它大1的数开始</span></span><br><span class="line"><span class="keyword">while</span> (u &gt;<span class="number">0</span>){</span><br><span class="line">    <span class="comment">//先减1，这样最后一次迭代时就会输出0</span></span><br><span class="line">    --u;</span><br><span class="line">    std::cout &lt;&lt;u&lt;&lt;std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改写后的循环先执行对循环控制变量减1的操作，这样最后一次迭代时，进入循环的u值为1。此时将其减1，则这次迭代输出的数就是0;下一次再检验循环条件时，u的值等于0而无法再进入循环。因为我们要先做减1的操作，所以初始化u的值应该比要输出的最大值大1。这里，u初始化为11，输出的最大数是10。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>提示:切勿混用带符号类型和无符号类型</strong></p><p>如果表达式里<strong>既有带符号类型又有无符号类型,当带符号类型取值为负时会出现异常结果</strong>，这是因为带符号数会自动地转换成无符号数。例如,在一个形如a*b的式子中,如果a=-1,b=-1，而且a和b都是int,则表达式的值显然为-1。然而,<strong>如果a是int，而b是unsigned,则结果须视在当前机器上int所占位数而定。在我们的环境里，结果是4294967295</strong></p><hr><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🤙</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f919.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 好，结束！！撒花</p><p>现在回到开始的问题你会分析了不？</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习2.3:读程序写结果。</span></span><br><span class="line"><span class="type">unsigned</span> u = <span class="number">10</span>,u2= <span class="number">42</span>;</span><br><span class="line"><span class="comment">//usigned 8位  </span></span><br><span class="line">std:: cout &lt;&lt; u2 - u&lt;&lt; std::endl;<span class="comment">//32</span></span><br><span class="line">std::cout &lt;u - u2 &lt;&lt; std:: endl;<span class="comment">//10+4294967295-42+1=4294967264</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>,i2 =<span class="number">42</span>;</span><br><span class="line"><span class="comment">//int 32位 4294967296-1=4294967295</span></span><br><span class="line">std::cout&lt;&lt; i2 -i&lt;&lt; std::endl;  <span class="comment">//32</span></span><br><span class="line">std::cout &lt;&lt; i - i2&lt;&lt; std::endl; <span class="comment">//-32</span></span><br><span class="line">std::cout &lt;&lt; i - u&lt;&lt; std::endl; <span class="comment">//0</span></span><br><span class="line">std::cout &lt;&lt; u- i&lt;&lt; std::endl;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> k1 = <span class="number">42</span>,k2 = <span class="number">10</span>;</span><br><span class="line">std::cout&lt;&lt;k2-k1&lt;&lt;endl;<span class="comment">//10+4294967295-42+1=4294967264</span></span><br><span class="line">std::cout&lt;&lt;k1-k2&lt;&lt;endl;<span class="comment">//32</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无符号数的计算 </tag>
            
            <tag> C++ </tag>
            
            <tag> 容易坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读——Factor Graphs for Robust GNSS</title>
      <link href="/2024/05/18/%E8%AE%BA%E6%96%87-Review-of-Factor-Graphs-for-Robust-GNSS/"/>
      <url>/2024/05/18/%E8%AE%BA%E6%96%87-Review-of-Factor-Graphs-for-Robust-GNSS/</url>
      
        <content type="html"><![CDATA[<h1 id="review-of-factor-graphs-for-robust-gnss">Review of Factor Graphsfor Robust GNSS</h1><blockquote><p>Cite : Das S, Watson R, Gross J. Review of factor graphs for robustGNSS applications. arxiv preprint arxiv:2112.07794. 2021 Dec 14.</p></blockquote><p>本文是该文的翻译版 适合大概的因子图综述阅读</p><h2 id="什么是因子图">什么是因子图</h2><p>概率建模是任何一种估计问题的一个非常重要的工具。这导致了图形模型[1]的发展，该模型使用图中的顶点对系统的已知变量和未知变量进行建模，并定义它们之间的边来表示它们之间的关系。由于系统建模中固有的不确定性，这些关系是概率性的。</p><p>一个因子图连接了这些图形化的许多类型的模型，如马尔可夫随机场，贝叶斯网络，坦纳图[2]。<strong>因子图的主要动机是将许多变量的全局函数表示为具有变量的较小子集的局部函数的乘积。因子图不是一种方法，而是一种使用其局部性结构建模任何系统的框架，即每个变量只依赖于其他几个局部变量，并且独立于其他局部变量。</strong>正如在[3]中所解释的那样，正是这种局部性特性使它在建模各种问题中非常有用，包括映射、视觉惯性测程法、运动规划、轨迹估计和深度学习。<strong>因子图被定义为一个二部图有两种类型的顶点，一个是变量（即状态向量）顶点是估计和另一个是因子顶点编码约束（例如，一组GNSS观察）应用于变量的顶点。一条边只能存在于因子顶点和变量顶点之间。因子顶点表示局部函数，它依赖于与它的变量顶点共享它的边。</strong></p><p>机器人技术中一个常见的估计问题是利用因子图框架来估计未知机器人姿态以及根据问题的其他参数。这是通过求解最大后验（MAP）问题来实现的，该问题使状态和测量值之间的概率约束因子的乘积最大化。[4]给出了一个严格的数学描述，如何解决这个最大化问题在机器人感知领域。</p><p>因子图已被视为解决估计问题的替代框架，并已被证明是非常有效的特定应用，在克隆同步定位和映射（SLAM）。由于该方法的灵活性和通过提供GTSAM[5]、g2o [6]、Ceres[7]等开源图优化库而易于实现，该框架得到了广泛的使用。<strong>虽然因子图框架已被证明对许多应用程序是有益的，但应该注意的是，框架可以等同于（即，它是一种遗传化）现有的状态估计实现（例如，卡尔曼滤波器和它的许多变体）</strong>。为了开始这个比较，我们将注意到因子图最终编码了一个目标函数，该函数通过非线性优化程序（例如，高斯-牛顿，莱夫-恩伯格-马夸特）重复重新线性化来求解。先前的工作已经证明，对扩展卡尔曼滤波的测量更新迭代和迭代之间的系统模型等价于高斯-牛顿优化[8]。结果表明，<strong>在一定的约束条件下，批处理模式下的因子图等价于反向平滑扩展卡尔曼滤波器（EKF）[9]，使系统和观测模型重新线性化并迭代。</strong></p><h2 id="使用因子图有什么优势">使用因子图有什么优势</h2><p>因子图优化比标准的非迭代卡尔曼滤波器具有一些优势，对某些应用具有一定的价值。</p><p>首先，像任何优化问题一样，<strong>它使用多次迭代来最小化成本</strong>，而不是像标准卡尔曼滤波器那样对每个状态只进行一次迭代。其次，它还将标准卡尔曼滤波器的<strong>非线性测量模型线性化</strong>，而不是用标准卡尔曼滤波器进行的单线性化。因子图也被证明可以<strong>更好地利用过去和当前时代之间的时间相关性，这被归因于估计方法的批处理性质</strong>。特别是，当在批处理模式下操作时，一个因子图将<strong>相当于一个前向滤波器和向后平滑器</strong>。</p><p>对于GNSS/INS应用，这些好处得到了[10]实验结果的支持，其中因子图已被证明在城市环境中比EKF表现更好。随着较长时间内新测量值的积累，<strong>批估计可能会失去实时性能</strong>。<strong>滑动窗口方法</strong>也可以使用类似于[11]来减轻计算成本。窗口大小已被发现对良好的优化结果至关重要，并可取决于环境条件[10]。<strong>因子图通过利用雅可比矩阵和信息矩阵的稀疏性来实现有效的计算。这有助于快速的矩阵分解和反替换</strong>。</p><p>直接从图形中删除早期的姿态可能会导致信息丢失。这可以避免使用平方根信息形式中的边缘化来删除变量从贝叶斯网络从因子图使用消除算法。<strong>由于图中的稀疏性，增量QR分解也可以有效地实现</strong>[5]。除了固定滞后平滑之外，isam2公式[12]在添加一个新的约束时，通过将因子图转换为贝叶斯树[13]来实现实时性能。<strong>对于高度非线性的测量模型，这是一种更精确的增量和平滑的方法</strong>。贝叶斯树的顶点代表了在因子分解过程中由因子图得到的贝叶斯网中的团系。<strong>只有包含在新约束中的状态和贝叶斯树中的状态以及它们在贝叶斯树中的前一个状态需要更新</strong>。Watson和Gross[14]在GNSS因子图中使用了isam2，显示出比传统的EKF-精确点定位（PPP）方法有更好的定位性能。Wen等人[15]将因子图优化应用于GNSS和GNSS-实时运动学（RTK）定位问题，显示出比EKF更好的性能。</p><h2 id="因子图如何运用于gnss">因子图如何运用于GNSS</h2><p>在[14]中详细描述了用GNSS观察结果产生的因素。<strong>在GNSS因子图中通常估计的状态是重新收发器的位置、对流层延迟、载波相位偏置和接收机时钟偏置。</strong>图1提供了GNSS因子图的可视化表示，其中ψ表示状态和测量值之间可能存在的任何概率约束。</p><figure><img src="https://cdn.jsdelivr.net/gh/xi-song/blog-image/202405181544533.png" alt="image-20240518154433289"><figcaption aria-hidden="true">image-20240518154433289</figcaption></figure><p>在这个特定的实现中，ψ是对每个状态的先验信念，这取决于特定的数据集和环境心理特征。<span class="math inline">\(ψ^p\)</span>是<strong>沿轨迹的两个连续状态之间的运动约束</strong>，例如，可以合并来自惯性测量单元（IMU）或车轮里程表的运动数据。在GNSS/IMU导航中使用的<span class="math inline">\(ψ^b\)</span>的一个常见例子是使用IMU预积分[16]来计算两个因子图位置之间的位移，它们之间有多个IMU测量值的积分。最后，在一个状态和从该状态感知到的测量值之间的<span class="math inline">\(ψ^m\)</span>测量约束，例如GNSS伪距或载波相位测量值。为了找到GNSS因子图的MAP估计值，<strong>我们可以找到使因子乘积最大化的状态集。</strong>然而，在实践中，这个优化问题可以大大简化采用高斯噪声假设，使问题的转换最大化因素的乘积非线性最小二乘问题的每个组件是一个马氏成本，代表归一化残差的平方和，如等式提供1，其中f（∗）在不同时期的状态映射和h（∗）之间的映射是从状态空间到观测空间的映射。</p><p><span class="math inline">\(\begin{aligned}\hat{X}&amp;=\underset{x}{\operatorname*{argmin}}\left[\sum_{i=1}^I\left\|\psi_i^p\right\|_\Sigma^2+\sum_{j=1}^J\left\|\psi_j^b\right\|_\Lambda^2+\sum_{k=1}^K\left\|\psi_k^m\right\|_\Xi^2\right]\\&amp;=\underset{x}{\operatorname*{argmin}}\left[\sum_{i=1}^I\left\|x_0-x_i\right\|_\Sigma^2+\sum_{j=1}^J\left\|x_j-f_j(x_{j-1})\right\|_\Lambda^2+\sum_{k=1}^K\left\|y_k-h_k\left(x_k\right)\right\|_\Xi^2\right]\\&amp;&amp;\text{(1)}\end{aligned}\)</span></p><h2 id="在gnss中使用因子图进行鲁棒估计的方法是什么">在GNSS中使用因子图进行鲁棒估计的方法是什么？</h2><p>如前所述，因子图框架也便于添加现有的和新的鲁棒估计方法，有助于减少欺骗攻击时的定位误差或多路径或大气效应的大噪声。下面的讨论列举了一些应用于GNSS的健壮方法。桑德豪夫等人[17]定义了开关约束（SC），这是一种提升优化[18]方法，定义了观察加权函数<span class="math inline">\(Ψ（）\)</span>，它是开关变量的函数，与感兴趣的状态参数一起估计。SC方法最初是用于SLAM中的鲁棒环闭合检测的，然后扩展到GNSS用于多路径缓解[19]。当使用开关约束时，伪距因子代价函数表示为预测和实际测量之间的马氏成本的比例版本。<span class="math display">\[\left\|\mathbf{e}_k^\mathrm{switch}\right\|_{\boldsymbol{\Sigma}_k}^2=\left\|\Psi\left(s_k\right)\cdot\left(y_k-h_k(x_k)\right)\right\|_{\boldsymbol{\Sigma}_k}^2\]</span> 其中，函数 <span class="math inline">\(Ψ\)</span>是开关变量的线性函数。为这些开关变量添加先验因子，以阻止优化使所有<span class="math inline">\(s_k\)</span>变成零。还可以添加一个过渡因子来模拟<span class="math inline">\(s_{k−1}\)</span>和在下一个时间步观测到的同一卫星之间的变化。这些开关功能有助于自动减轻错误测量（例如，可疑的多路径测量），并被认为比计算昂贵的射线追踪方法[19]表现更好。在[20]中推导出了SC的一个扩展，称为<strong>动态协方差尺度</strong>（DCS），其中开关变量从优化方法中提取，并使用残差、电流测量不确定度和先验开关不确定度分别进行计算。在计算<span class="math inline">\(s_k\)</span>后，与GNSS观测因子相关的信息矩阵用$Ψ(s_k)^2$进行缩放。<strong>最大混合（MM）</strong>[21]也使用高斯混合模型（GMM）来解决假循环闭包，但不是使用多模态不确定模型时不适合最大似然的和算子，目标函数转换为使用最大算子，如等式所示3 <span class="math display">\[p\left(y_i\mid x\right)=\max_kw_kN\left(\mu_k,\Lambda_k^{-1}\right)\]</span>SC、DSC和MM的好处已经在[22,23]中评估了具有真实世界数据的GNSS因子图应用。这两项研究都表明，在对退化的GNSS观测值进行优化时，通过使用鲁棒估计技术，可以实现实质性的定位改进。</p><p>为了扩展最大混合工作<strong>，Watson等人[24]提出基于观测残差的聚类在运行时学习GMM</strong>。最初，这项工作是是在一个批处理框架中实现的.然而，后来通过一种逐步合并gmm的有效方法，它被扩展到增量[25]工作，通过一种有效的方法来逐步合并gmm。</p><p>m-估计器[26]最近也在GNSS框架中以批处理形式的[27]进行了测试，并发现它比非鲁棒估计器性能更好。m-估计器假设有一个不同于平方损失函数的损失函数。平方损失函数对离群值高度敏感，因为它在较大的残差值下积极增长。因此，引入了一组损失函数，它们的增长侵略性小于平方损失函数。Huber成本函数[28]，如等式中提供的4就是这样一个函数。<span class="math display">\[\rho(z)=\begin{cases}z^2/2&amp;|z|\leq\Delta\\\Delta|z|-\Delta^2/2&amp;|z|&gt;\Delta\end{cases}\]</span> 当目标函数被修改为利用m-估计量时，优化问题的形式如等式中所示5. <span class="math display">\[\hat{X}=\arg\min_x\sum_i\rho\left(\frac{r_i(x)}\sigma\right)\quad(5)\]</span> 式中，<span class="math inline">\(r_i (x)\)</span>为每次测量的残差，<span class="math inline">\(σ\)</span>为尺度参数。</p><p>增加∆参数会使该函数更接近平方损失函数。方程5可以用加权最小二乘法迭代求解方法[27,26]。选择一个合适的∆参数并不简单，因为它依赖于测量噪声的统计量。阿加门诺尼等人[29]利用这样一个事实，即一些m估计量，如胡贝尔，柯西，拉普拉斯有一个对应的椭圆分布来估计期望最大化（EM）框架下的∆和状态。Barron[30]联合优化了计算机视觉应用程序的状态和参数。因子图在m估计器应用中提供了更大的灵活性，<strong>因为它不仅可以帮助降低当前测量的权重，而且还可以改变过去测量的权重</strong>。如果后来发现一些过去的测量值，那么它是一个异常值，而在卡尔曼滤波器中，过去的测量值的贡献不能以实时的方式改变。大多数图形操作时间化库还内置了使用健壮的成本函数的功能，这也很有帮助。</p><p>最后，Yang等人[31]导出的鲁棒估计技术结合了计算机视觉的两个著名思想，黑-朗加拉扬<strong>对偶性[32]和分级非凸性[33]，利用鲁棒代价函数迭代解决点云重构问题。</strong>根据黑-朗加拉扬对偶性，方程5可以重写为<span class="math display">\[\hat{X},\mathbf{w}=\underset{x,w_i\in[0,1]}{\operatorname*{\arg\min}}\sum_i\left[w_ir_i^2\left(x\right)+\Phi_\rho\left(w_i\right)\right],\]</span> 其中 <span class="math inline">\(w_i\)</span>是该测量的权重，<span class="math inline">\(Φ_ρ\)</span>是一个惩罚项，它取决于权重和稳健代价ρ。分级非凸性（GNC）是一种不面临局部极小值问题的非凸函数f最小化的方法。其思想是代替函数用<span class="math inline">\(f_µ\)</span> 替代f，<span class="math inline">\(f_µ\)</span>的凸性由参数µ控制。优化从<span class="math inline">\(f_µ\)</span>和<span class="math inline">\(µ\)</span>的凸形式开始，迭代地改变，使非凸性增加。[31]将这两种方法结合起来，解决了方程5中的两个问题，</p><p>1)在优化鲁棒代价函数的同时避免局部最小值</p><p>2)将方程5转换为一个总是更容易求解的加权最小二乘问题。这个问题与GNSS的相似性对读者来说应该是显而易见的。[34]显示了在GNSS因子图中应用这种稳健估计技术在减轻城市峡谷多路径效应中的重要性。大多数这些鲁棒估计方法的批处理性质使它适合用于因子图，而不是EKF。</p><h2 id="因子图对gnss和无线电导航社区的潜在用途是什么">因子图对GNSS和无线电导航社区的潜在用途是什么？</h2><p>EKF一直是基于GNSS的状态估计的首选，因为其简单性、计算效率，以及GNSS观测模型可以用线性近似很好地建模，并且经常通过高斯误差进行很好的描述。尽管如此，但在某些情况下，无线电导航社区可能可以受益于因子图优化。</p><p>首先，最近的工作强调了机会信号（SOP）在无线电导航应用中的潜在用途和好处。SOP可能包括作为手机信号的[35,36,37]和近地轨道卫星。<strong>sop的使用通常包括对解决一个未知的或非常不确定的发射机位置和时钟偏移量的需要。</strong>因此，这类问题与SLAM有许多相似之处，因此可以从使用因子图中获得类似的好处，如基于视觉或激光雷达的姿态图SLAM所公认的那样。</p><p>其次，正如在GNSS的背景下所讨论的，许多鲁棒估计技术已经被开发出来用于因子图。<strong>对于使用容易出现多路径错误的GNSS城市环境，使用这些鲁棒因子图可能是有益的。</strong>例如，谷歌智能手机解密器挑战的获胜解决方案，包括收集到不同环境设置的各种数据集，确实是一个因子图实现[38]。</p><p>最后，因子图的采用可能是有益的，因为因子图框架已经成为机器人和自治社区中的标准状态估计范式（即，除了GNSS之外，几乎所有的传感器模态都利用并显示了因子图框架的好处）。采用GNSS因子图可以使GNSS和其他传感器模式之间更无缝集成，多个信息源的集成是任何关键导航系统的关键。</p><h2 id="其他相关问题">其他相关问题</h2><h3 id="关于本文提出的反向平滑ekf-9">关于本文提出的反向平滑EKF [9]</h3><blockquote><p>OURNAL OFGUIDANCE, CONTROL,ANDDYNAMICS Vol. 28, No. 5,September–October 2005</p></blockquote><p>推广了迭代扩展卡尔曼滤波器的原理，提出了一种新的在估计问题存在严重非线性时具有优越性能的滤波器。当非噪声可能会显著降低其他滤波器的精度或收敛可靠性时，新的滤波器是有用的。该新的滤波器利用迭代数值技术解决了当前和过去样本区间的非线性平滑问题。这种方法保留了在感兴趣的阶段之前的固定数量的阶段的非线性，并以一种近似的方式处理来自早期阶段的信息。该算法已经在一个困难的航天器姿态估计问题上进行了仿真测试，该问题包括少于三个轴的感知和显著的动态模型不确定性。该滤波器通过同时估计惯性矩参数来补偿这种不确定性。对于初始姿态或姿态率误差较大的估计问题，该滤波器和无迹卡尔曼滤波器具有更好的收敛可靠性和精度。</p><p>反向平滑扩展卡尔曼滤波器（BSEKF）比其他过滤器更直接地处理更多的非线性。EKF使用了非线性动力学和测量函数的一项或两项泰勒级数近似。展开是对后验或先验均值展开的，以可用的为准。利用这些展开式和线性卡尔曼方程动态传播，更新状态状态及其估计误差协方差。1IEKF试图通过改变一个关于一个基于先前线性化的后验状态估计来改进其测量方程的线性近似。在IEKF的一个选项中，可以实现几种重新线性化。1UKF通过非线性动力学和测度函数传播点的分布。这些点被称为西格玛点，它们被用来估计非线性函数输出分布的高斯近似值的均值和协方差。如果你要注意如何选择UKF的西格玛点，那么它将保留二阶非线性效应，这些效应被EKF，2,3的某些细节所遗漏，这就是为什么与许多EKF相比，它可以提高收敛性和准确性。</p><p>BSEKF改进的改进来自于它处理现在和过去的动力学和测量函数的非线性的方法。该方法是对IEKF原理的一种扩展。<strong>其想法是重新线化化当前和过去的测量函数，以及当前和过去的动态函数，以改进对当前和过去状态和过程噪声向量的猜测。</strong>在一个结束的时间间隔内，通过迭代的非线性平滑来选择适当的再线性化点在当前的采样时间内。这个过程产生了一个状态估计算法，该算法处理多个阶段上的所有非线性，而没有任何近似。</p><p>BSEKF在本质上与参考文献中描述的过滤器参考文献4.目前的公式的主要区别是，它适用于一般的离散时间问题，而参考文献4的滤波器直接工作于为特定应用程序导出的采样数据连续时间问题。目前的离散时间形式简化了数学如下：它既消除了指定状态向量的确定性和非确定性部分的需要，也消除了开发不包括过程噪声向量的联合概率分布的需要。</p><p><strong>BSEKF可以被归类为一种特殊的因果批处理过滤器。一个仔细的研究人员可以从文献中关于批过滤的各种想法中综合BSEKF方法，</strong>但没有一个参考文献将所有必要的组件组合在一个地方。在参考文献5中，<strong>使用移动窗口批处理过滤器nonlin-ear高斯-牛顿更新是提到执行因果非线性滤波，但公式不包括过程噪声，也没有解释重要细节如何最好地将数据从批处理窗口的影响</strong>。在参考文献6提到了一个具有类似缺点的移动窗口批处理过滤器，但给出的细节更少。在参考文献7定义了一种解决排除过程噪声的离散时间批估计问题的方法，但没有提到移动窗口实现作为因果非线性滤波的手段。在参考文献1，概述了非线性最大后验（MAP）平滑及其与动态规划的关系，但没有给出算法的解，也没有讨论用于因果滤波的移动窗口实现。</p><p>本文没有将BSEKF与使用蒙特卡罗技术的粒子滤波（PF）方法进行比较。理论上，粒子滤波器能够计算出比BSEKF或任何竞争的非线性滤波器更好的估计，但由于在状态空间中选择相关点的差异，它对具有挑战性的问题有很大的计算代价。BSEKF在精神上更类似于EKF、IEKF和UKF，因为每个算法都是一种使用有界计算数的近似方法。将这种方法与在无限次计算的极限下精确的方法进行比较似乎没有什么意义。另一方面，对于极端非线性问题，一个有用的方法可能是将BSEKF和PF技术技术结合起来。前者可用于指导粒子（状态空间中的点）的选择，以有效地实现后者。本文的其余部分分为三个主要部分，以及一些结论。在第二部分，非线性离散时间滤波问题被定义为一个地图估计问题，以及EKF、IEKF和UKF如何使用近似来解决它的各个方面谈论。本文描述了BSEKF如何比任何其他任何过滤器更少地逼近MAP问题，并详细描述了如何实现该算法。在摘要给出了一个同时进行参数计算的姿态估计问题。IV部分是BSEKF、EKF和UKF滤波结果。本文的结论在V.部分</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 因子图 </tag>
            
            <tag> 综述 </tag>
            
            <tag> 鲁棒性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文粗略阅读——Sqare Root SAM</title>
      <link href="/2024/05/12/%E8%AE%BA%E6%96%87%E2%80%94%E2%80%94SAM/"/>
      <url>/2024/05/12/%E8%AE%BA%E6%96%87%E2%80%94%E2%80%94SAM/</url>
      
        <content type="html"><![CDATA[<h1 id="sqare-root-sam">Sqare Root SAM</h1><p>Simultaneous Localization and Mapping via Square Root InformationSmoothing 基于平方根信息平滑法的同步定位和映射</p><blockquote><p>后面的其他部分 和 因子图优化相关问题重了</p></blockquote><h2 id="摘要">摘要</h2><p>我们研究平滑方法作为一个可行的替代扩展卡尔曼滤波的解决方案。<strong>特别地，我们研究了将相关信息矩阵或度量雅可比矩阵分解为平方根形式的方法。</strong>与EKF相比，这种技术有几个显著的优势：<strong>它们更快又精确，可以批量或增量模式使用，可以更好地处理非线性过程和测量模型，并以更低的成本产生整个机器人轨迹。</strong>此外，以一种间接但引人注目的方式，列排序启发式自动利用了SLAM问题的地理本质中固有的局部性。在本文中，我们提出了这些方法背后的理论，以及根据与SLAM问题相关的图形模型对因子分解的解释。我们在大规模环境中展示了模拟结果和实际的SLAM实验，这强调了这些方法作为基于EKF的方法的替代方案的潜力。</p><h2 id="介绍">1.介绍</h2><p>其中最早和最流行的方法是基于扩展的卡尔曼滤波器（EKF）[68,60,59,2,69,51,49]。EKF递归地估计机器人当前姿态和所有地标的位置（地图）上的高斯密度。然而，众所周知，EKF的计算复杂度很快就变得相当棘手，因此大量的工作都集中在修改和扩展过滤方法，以应对更大规模的环境。[62,17, 21, 8, 44, 47,37, 63, 48, 5, 75, 38,65].然而，当应用于固有的非线性SLAM问题[43]时，过滤本身已经被证明是不一致的，即，即使是占用大量实验的平均值也偏离了真正的解。由于这主要是由于在过滤框架中无法撤销的线性化选择，最近人们对SLAM问题的平滑版本产生了相当大的兴趣</p><h3 id="smoothing-and-mapping-or-sam">Smoothing and Mapping or SAM</h3><p>SLAM的平滑方法不仅涉及最新的机器人位置，还涉及整个机器人的轨迹。许多作者考虑了平滑机器人轨迹的问题，这特别适用于传感器，如激光距离查找器，容易在附近的机器人姿态之间产生成对约束。更一般地说，我们可以考虑完整的SLAM问题[74]，即最优估计整个传感器姿态集以及环境中所有特征的参数的问题。事实上，这个问题在测量[35]、摄影测量[7,36,66,10]、被称为“束调整”和计算机视觉[24,70,71,76,40]、被称为“运动结构”方面有着悠久的历史。特别是在过去的五年里，有一系列的工作，这些想法被应用到SLAM的背景下。</p><p>在本文中，<strong>我们展示了平滑是如何成为基于过滤的方法的一种非常快速的替代方法，并且在许多情况下，保持轨迹周围有助于而不是损害性能</strong>。特别地，与全SLAM相关的优化问题可以用稀疏线性代数简明地表示，它传统上涉及最小二乘问题[34]的解。在这个框架中，我们研究了将信息矩阵I或度量雅可比矩阵A分解为平方根形式，并应用于同时平滑和映射（SAM）的问题。因为它们是基于矩阵平方根的，所以我们将这类方法称为平方根SAM，或简称√SAM，首先在[18]中引入。我们认为√SAM是SLAM比EKF更好的解决SLAM问题的方法：</p><ol type="1"><li>与扩展的卡尔曼滤波协方差或信息矩阵相比，两者都随着时间的推移而完全密集。<strong>与平滑相关联的信息矩阵I是和保持稀疏的。</strong></li><li>在典型的映射场景中，这个矩阵I，或者，度量雅可比矩阵A，是映射协方差结构的更紧凑的表示</li><li>两种稀疏，可以分别用稀疏分解或QR分解有效地分解，分别，生成一个平方根信息矩阵R可以用来立即获得机器人的最佳轨迹和地图。</li></ol><p>在序列估计文献中，分解信息矩阵被称为平方根信息滤波(SRIF），并于1969年开发用于喷气推进实验室的水手10号金星任务（如[3]所述）。使用协方差或信息矩阵的平方根可以得到更准确和稳定的算法，并且引用梅贝克[57]的话，“许多实践者以相当大的逻辑认为，应该始终采用平方根滤波器，而不是标准的卡尔曼滤波器递归”</p><p>梅贝克简要地讨论了SRIF关于平方根过滤的章节，以及它和其他平方根类型的算法是Bierman[3]的一本书的主题。但是，从文献文献数量较少来判断，SRIF和平方根信息平滑器（SRIS）并不常用。</p><h3 id="稀疏线性代数图论和稀疏sam">稀疏线性代数，图论，和稀疏√SAM</h3><p>性能的关键是利用稀疏线性代数中的大量工作，并充分利用与平滑SLAM问题相关的矩阵的稀疏性。性能上最显著的改进来自于在分解矩阵时选择一个良好的变量排序。为了更好地理解这一事实，我们需要研究类似于slam的问题、线性代数和图论之间的密切关系，图论一直是稀疏线性代数30多年的中心[31]。例如，<strong>虽然QR分解通常被用作“黑盒”算法，但它实际上是在图上的一种优雅的计算。这是一个反复出现的主题：线性代数的最新进展是数值方法和高级图论的混合，与图形模型文献中常见的推理算法有许多共同的特征。</strong>特别是，稀疏最小二乘解的图论算法是变量消去，其中每个变量（如机器人姿态或地标位置）都用其他变量表示。剔除变量的顺序对QR和Cholesky等矩阵分解算法的运行时间有很大的影响。找到一个最优排序是一个np-完整的问题，但是有一些排序启发式和近似算法在一般问题[1,41]上表现良好，并被内置到像MATLAB这样的程序中。</p><p>虽然通用的排序方法极大地提高了性能，但在对变量进行排序时，通过利用SLAM问题的特定图形结构，还可以获得另外15倍的改进。从图表的角度来看SLAM本身有丰富的历史，特别是在过去几年[61,58,29,63,25,30,75,26,74]导致了一些新颖和令人兴奋的发展。下面我们将更仔细地研究图形模型视图和SLAM的稀疏线性代数公式之间的紧密联系。众所周知，信息矩阵I与连接机器人姿态和地标的无向图相关联（见[75]）。不太容易理解的事实是，测量雅可比矩阵A是与SLAM相关的因子图的矩阵。此外，平方根信息矩阵R，即分解I或A的结果，本质上对应于一个结树，从图形模型[11]的推理中知道，最近也应用于SLAM[63]。利用领域知识来获得良好的排序也是线性代数（如[15]）的一种趋势，我们相信，通过将这个问题看作是一个图上的计算问题，甚至可以开发出更有效的算法。</p><h2 id="slam-and-graph">2. SLAM and Graph</h2><p>SLAM是指在定位机器人环境的同时定位机器人的问题，如图1的例子所示。在本节中，我们将介绍SLAM问题，我们使用的符号，并展示文献中已知的三个主要图形模型表示如何对SLAM问题产生独特的视图，从而强调问题的某些方面。在本文的后面，我们建立了这些图和它们的（稀疏）矩阵等价物之间的联系。</p><p>下面我们假设我们熟悉基于EKF的SLAM[69,49,8,21]方法。我们不重新推导出扩展的卡尔曼滤波器。相反，在第3节中，我们立即采取了一种平滑的方法，其中地图和机器人的轨迹都被恢复。</p><h3 id="slam-as-a-belief-net">SLAM as a Belief Net</h3><blockquote><p>信念网也叫贝叶斯网络</p></blockquote><p>根据FastSLAM和其他[61,58,63,29,25,74]设定的趋势，我们通过引用一个信念网络表示来表述这个问题。信念网是一个有向无环图，它编码一组变量的条件独立结构，其中每个变量只直接依赖于图中的前身。我们所采用的模型如图2所示。这里我们用xi表示机器人的时间步长状态，i∈0..M，lj的地标，j∈1..N，用zk测量，用k∈1..K.该网络对应的联合概率模型为</p><p><span class="math inline">\(P(X,L,Z)=P(x_0)\prod_{i=1}^MP(x_i|x_{i-1},u_i)\prod_{k=1}^KP(z_k|x_{i_k},l_{j_k})\)</span></p><p>其中P（x0）为初始状态的先验，P（xi|xi−1，ui）为运动模型，由控制输入ui参数化，P（z|x，l）为地标测量模型。以上假设在地标l上有一个统一的先验。此外，它假设数据关联问题已经得到解决，即每个测量zk所对应的指标ik和jk都是已知的。</p><p>SLAM问题的贝叶斯信念网络表示。机器人的状态x由顶部的马尔可夫链控制，而机器人的环境在底部由一组地标l表示。中间层的测量z由机器人的状态和测量的地标参数控制。<span class="math display">\[{x_i=f_i(x_{i-1},u_i)+w_i\quad\Leftrightarrow\quadP(x_i|x_{i-1},u_i)\propto\exp-\frac12\|f_i(x_{i-1},u_i)-x_i\|_{\Lambda_i}^2}\]</span>其中，fi（.）是一个过程模型，以及具有正态分布的具有协方差矩阵Λi的零均值过程噪声，和<span class="math display">\[z_k=h_k(x_{i_k},l_{j_k})+v_k\quad\Leftrightarrow\quadP(z_k|x_{i_k},l_{j_k})\propto\exp-\frac{1}{2}\|h_k(x_{i_k},l_{j_k})-z_k\|_{\Sigma_k}^2\]</span>其中，hk（）是一个测量方程，它是正态分布的零平均测量噪声与协方差Σk。在||e||Σ被定义为给定一个协方差矩阵Σ的马氏距离的平方。</p><p>上述方程分别模拟了机器人对控制输入及其传感器的响应行为。</p><blockquote><p>这两个式子展示的是状态空间模型中的状态转移的描述，一个是通过随机方程的形式，另一个是通过条件概率密度的形式.</p><p>在状态空间模型中，每个状态<span class="math inline">\(x_i\)</span>是基于上一个状态<span class="math inline">\(x_{i-1}\)</span>和一些控制输入<span class="math inline">\(u_i\)</span>,通过一个确定性的函数 <span class="math inline">\(f_i\)</span> 来预测的，并加上一些随机噪声<span class="math inline">\(w_i\)</span>。随机噪声通常假定为高斯分布，也就是正态分布，具有零均值和一定的协方差矩阵<span class="math inline">\(Q_i\)</span>。</p><p><img src="D:\typora\pic\image-20240510171449639.png" alt="image-20240510171449639" style="zoom:67%;"></p></blockquote><h3 id="slam-as-a-factor-gragh">SLAM as a Factor Gragh</h3><p>虽然信念网是思考SLAM问题的生成方面的一种非常自然的表示，但因子图与潜在的优化问题有更紧密的联系。由于测量值z_k在图2是已知的（证据，在图形模型的术语中），我们可以自由地消除它们作为变量。相反，我们把它们作为实际未知数上的联合概率因子的参数，这自然导致了众所周知的因子图表示，这是一类二部图图形模型，可以用来表示这种因子密度[46]。在因子图中，有未知数的节点和定义在它们上的概率因子的节点，图的结构表示每个因子涉及哪些未知数。图1中的示例的因子图如图3所示。可以看出，地标测量zk和测程链接ui都有因子节点.</p><blockquote><p>在讨论SLAM（Simultaneous Localization andMapping）问题时，我们通常需要处理大量的变量和测量数据。信念网（或贝叶斯网络）和因子图是两种常用的图形表示，用以表达这些变量之间的依赖关系。这两种表示方式各有优缺点，而对于SLAM这类优化问题，因子图提供了一种更直接且与问题求解密切相关的表示形式。</p><h3 id="为什么可以自由消除测量值-z_k-作为变量">为什么可以自由消除测量值( z_k ) 作为变量</h3><p>在因子图中，我们通常关注的是如何根据已知的测量值（如传感器数据）来推断机器人的位置和地图的配置。测量值( z_k )通常被视为“已知”的，它们是收集到的传感器数据，不是需要求解的未知数。在构建模型时，我们不需要将这些测量值作为待求解的变量；它们是给定的条件或“证据”，已经存在并用于影响其他未知变量的估计。</p><h3 id="为什么我们把它们作为实际未知数上的联合概率因子的参数">为什么我们把它们作为实际未知数上的联合概率因子的参数</h3><p>在因子图表示中，每一个因子通常表示变量之间的概率关系。例如，在SLAM中，一个因子可能表示在特定的位置和地图配置下获得某个测量值的概率。这样，测量值( z_k )作为参数出现在因子中，而非作为独立的变量。这使得因子图直接反映了未知变量（如机器人位置和地图配置）之间的条件依赖关系。通过这种方式，因子图将关注点集中在如何根据测量数据来推断或优化未知变量上，而非处理测量数据本身作为未知数。</p><h3 id="这自然导致了众所周知的因子图表示">这自然导致了众所周知的因子图表示</h3><p>因子图的这种表示方式使得它非常适合于SLAM这类问题的求解，因为SLAM本质上是一个基于大量测量数据对未知状态进行优化的问题。在因子图中，各个因子直接关联到一组变量，并定义这些变量间的局部关系，这对于执行如图搜索、优化和推断等操作是非常有效的。相对于信念网，因子图提供了一种更为紧凑和针对优化问题的自然表示，使得算法能更直接地操作相关的概率分布，从而更有效地实现SLAM。</p><p>总之，因子图通过将测量值作为已知的参数而不是变量来简化问题表示，使得模型更直接地关联到优化问题本身，这对于高效解决SLAM等复杂问题至关重要。</p></blockquote><blockquote><p>因子图是图形模型中的一种，它用于表示多个变量间复杂的依赖关系。在因子图中，节点表示变量（例如，在SLAM中的机器人位置和地图的特征点），而边则表示这些变量之间的条件依赖，即因子。因子通常定义了一组变量之间的概率关系，这些概率关系直接反映了变量间如何相互影响。</p><h3 id="反映未知变量之间的条件依赖关系">反映未知变量之间的条件依赖关系</h3><p>在SLAM问题中，机器人的位置和地图的特征点都是未知变量，它们之间的关系通过传感器的测量数据（如激光雷达、摄像头等）被间接地捕获。因子图通过以下方式来反映这些未知变量之间的条件依赖关系：</p><ol type="1"><li><strong>变量节点</strong>：表示SLAM中的每一个未知元素，如每个时刻的机器人位置、地图上的每一个特征点。</li><li><strong>因子节点</strong>：表示测量数据与这些未知变量之间的概率函数。例如，<strong>一个因子节点可以表示在给定机器人位置和方向的情况下，预期的激光雷达测量与实际测量之间的误差概率分布。</strong></li></ol><h3 id="集中关注点在未知变量的推断或优化上">集中关注点在未知变量的推断或优化上</h3><p>因子图将关注点放在了如何使用这些条件依赖关系来推断或优化未知变量上，而不是将测量数据本身作为解决问题的一部分。这是通过以下步骤实现的：</p><ol type="1"><li><p><strong>整合测量数据</strong>：测量数据作为参数整合到因子节点中，而不是作为独立的求解变量。<strong>这意味着我们不需要对测量数据本身进行优化或求解，而是使用这些数据作为已知的信息来帮助确定未知变量的最可能值。</strong></p></li><li><p><strong>优化或推断</strong>：使用图中的结构和因子定义，我们可以应用优化算法（如非线性最小二乘、梯度下降）或概率推断方法（如粒子滤波、贝叶斯推断）来估计这些未知变量的值。算法会根据因子图中定义的数学关系和输入的测量数据，寻找使得整个系统概率最大（或误差最小）的未知变量的配置。</p></li></ol><p>通过这种方式，因子图能够有效地利用每个测量的信息，同时保持对未知变量间复杂关系的清晰表示，从而使得求解过程更为直接和高效。因此，因子图在SLAM及其他涉及大量变量和数据的领域中非常受欢迎。</p></blockquote><p>在SLAM问题中，我们（通常）只考虑单个和成对的派系，导致一组未知Θ上的以下因子图表达式：</p>{{$$P(\Theta)\propto\prod_i\phi(\theta_i)\prod_{\{i,j\},i<j}\psi_{ij}(\theta_i,\theta_j) $$="" }}="" <p="">通常，势φ（θi）在未知θi∈Θ处编码先验或单一测量约束，而成对势ψij（θi，θj）与涉及两个未知θiandθj之间关系的测量或约束有关。注意，第二个产品是成对的团系{i，j}，计算一次。方程(1)和(4)之间的等价性可以很容易地通过下列各式来建立<span class="math display">\[\phi_0(x_0)\propto P(x_0)\\\psi_{(i-1)i}(x_{i-1},x_i)\proptoP(x_i|x_{i-1},u_i)\\\psi_{i_kj_k}(x_{i_k},l_{j_k})\proptoP(z_k|x_{i_k},l_{j_k})\]</span>图1对应的完整SLAM问题的因子图表示。未知的姿态和地标分别对应于圆形和正方形的变量节点，而每个测量值对应于一个因子节点（填充的黑色圆圈）。<p></p><h3 id="slam-as-a-markov-random-field">SLAM as a Markov RandomField</h3><p>最后，用图形模型来表示SLAM问题的第三种方法是通过马尔可夫随机场，其中消除了因子节点本身。一个MRF的图是无向的，并且没有因子节点：它的邻接结构表示哪些变量是由一个共同的因子（度量或约束）连接起来的。在这个抽象级别上，形式(4)完全对应于一个成对的马尔可夫随机场[78]的表达式，因此是mrf和因子图是这里的等价表示。图1中的示例的MRF如图4所示。请注意，它看起来与图3非常相似，但是MRF是一个完全不同于因素图的结构（无向图和二部图）。</p><h2 id="sam-as-a-least-squares-problem">3.SAM as a Least SquaresProblem</h2><p>虽然前一节涉及建模，但我们现在讨论推理，即，给定我们可用的所有测量值，获得未知数集的最优估计。我们使用平滑而不是滤波，也就是说，我们想要恢复整个轨迹X={xi}和映射L={lj}的最大后验估计，给定测量值Z={zk}和控制输入U={ui}。让我们在Θ=（X，L）中收集X和L中的所有未知数。在上述假设下，我们通过最大化方程1中的联合概率P（X，L，Z）得到最大后验（MAP）估计。</p><p><span class="math display">\[\begin{aligned}\Theta^*\triangleq\underset{\Theta}{\operatorname*{argmax}}P(X,L|Z)&amp;=\quad\underset{\Theta}{\operatorname*{argmax}}P(X,L,Z)\\&amp;=\quad\underset{\Theta}{\operatorname*{argmin}}-\logP(X,L,Z)\end{aligned}\]</span></p><p>这使我们通过(2)和(3)得出以下非线性最小二乘问题： <span class="math display">\[\Theta^*\triangleq\underset{\Theta}{\operatorname*{argmin}}\left\{\sum_{i=1}^M\|f_i(x_{i-1},u_i)-x_i\|_{\Lambda_i}^2+\sum_{k=1}^K\|h_k(x_{i_k},l_{j_k})-z_k\|_{\Sigma_k}^2\right\}\]</span>对于先前的P（x0），我们将假设x0是给定的，因此它被视为一个常数。这大大简化了本文档其余部分中的方程式。这是很常见的事情。在实践中：坐标系的原点是任意的，我们可以把x0固定在原点。该阐述很容易适应这种假设无效的情况。</p><p>在实践中，人们总是考虑公式(5)的线性化版本。如果过程模型和测量方程是非线性的，并且没有良好的线性化点，非线性优化方法，如高斯-牛顿迭代或莱文堡-马夸特算法将求解(5)的一系列线性近似，以接近最小[20]。这类似于[68,69,50]首创的针对SLAM的扩展卡尔曼滤波方法，但允许多次迭代以收敛，同时控制在哪个区域愿意信任线性假设（因此，这些方法通常被称为区域信任方法）。</p><p>我们现在将非线性最小二乘目标函数(5)中的所有项线性化。在最低点时，我们将假设一个好的线性化点是可用的，或者我们正在进行一个非线性优化方法的一次迭代。在任何一种情况下，我们都可以将(5)中的过程项线性化如下：<span class="math display">\[f_i(x_{i-1},u_i)-x_i\approx\left\{f_i(x_{i-1}^0,u_i)+F_i^{-1}\deltax_{i-1}\right\}-\left\{x_i^0+\delta x_i\right\}=\left\{F_i^{i-1}\deltax_{i-1}-\delta x_i\right\}-a_i\quad(6)\\]</span> <span class="math inline">\(\text{where }F_i^{i-1}\text{ isthe Jacobian of }f_i(.)\text{ at the linearization point}x_{i-1}^0,\text{defined by}\)</span> <span class="math display">\[F_i^{i-1}\triangleq\frac{\partial f_i(x_{i-1},u_i)}{\partialx_{i-1}}\Bigg|_{x_{i-1}^0}$​\]</span> <span class="math inline">\(a_i\stackrel{\Delta}{=}x_i^0-f_i(x_{i-1}^0,u_i)\)</span>是测程预测误差（注意，<span class="math inline">\(u_i\)</span>是这里是给出的，因此是常数）。(5)中的线性化测量项也同样得到，<span class="math display">\[h_k(x_{i_k},l_{j_k})-z_k\approx\left\{h_k(x_{i_k}^0,l_{j_k}^0)+H_k^{i_k}\deltax_{i_k}+J_k^{j_k}\delta l_{j_k}\right\}-z_k=\left\{H_k^{i_k}\deltax_{i_k}+J_k^{j_k}\delta l_{j_k}\right\}-c_k\]</span></p><p><span class="math display">\[H_k^{i_k}\triangleq\frac{\partial h_k(x_{i_k},l_{j_k})}{\partialx_{i_k}}\bigg|_{(x_{i_k}^0,l_{j_k}^0)}J_k^{j_k}\triangleq\frac{\partialh_k(x_{i_k},l_{j_k})}{\partial l_{j_k}}\bigg|_{(x_{i_k}^0,l_{j_k}^0)}\\]</span></p><p><span class="math inline">\(c_k\triangleqz_k-h_k(x_{i_k}^0,l_{j_k}^0)\)</span>是测量预测误差。</p><p>分别使用线性化的过程和测量模型(6)和(7)，(5)开始 <span class="math display">\[\delta^*=\underset{\delta}{\operatorname*{argmin}}\left\{\sum_{i=1}^M\|F_i^{i-1}\deltax_{i-1}+G_i^i\deltax_i+a_i\|_{\Lambda_i}^2+\sum_{k=1}^K\|H_k^{i_k}\deltax_{i_k}+J_k^{j_k}\delta l_{j_k}-c_k\|_{\Sigma_k}^2\right\}\]</span>也就是说，我们得到了一个需要有效求解的δ中的线性最小二乘问题。为了避免处理<span class="math inline">\(\deltax_{i}\)</span>的一种特殊方法，我们引入了矩阵<span class="math inline">\(G_i^i=-I_{d\times d},\)</span>，xi维数为d。</p><p>我们总是可以通过预乘以<span class="math inline">\(F_i^{i-1},G_i^i,\)</span>和<span class="math inline">\(a_i\)</span>的每个项<span class="math inline">\(\Lambda_i^{-T/2},\)</span>来消除<span class="math inline">\(\Lambda_i,\)</span>(8)，对于测量协方差矩阵Σk也是如此。对于标量测量，这仅仅意味着将每一项除以测量的标准差。下面我们假设已经这样做了，然后去掉马氏符号。</p><p>最后，将雅可比矩阵收集为矩阵a，并将向量纳入右侧（RHS）向量b，得到以下标准最小二乘问题，<span class="math display">\[\delta^*=\underset{\sim}{\operatorname*{argmin}}\left\|A\delta-b\right\|_2^2\]</span>这是我们下面的起点。A可以变得非常大，但却非常稀疏，如图5所示。如果dx、dl和dz是状态、地标和测量值的尺寸，则A的大小为（NdxKdz）×（Ndx Mdl）。此外，A具有典型的块状结构，例如，具有M = 3、N = 2和K= 4： <span class="math display">\[\left.A=\left[\begin{array}{cccccc}G_1^1&amp;&amp;&amp;&amp;&amp;\\F_2^1&amp;G_2^2&amp;&amp;&amp;&amp;\\&amp;F_3^2&amp;G_3^3&amp;&amp;&amp;\\H_1^1&amp;&amp;&amp;J_1^1&amp;&amp;\\H_2^1&amp;&amp;&amp;&amp;J_2^2&amp;\\&amp;H_3^2&amp;&amp;J_3^1&amp;&amp;\\&amp;&amp;H_4^3&amp;&amp;J_4^2&amp;\end{array}\right.\right],\quadb=\left[\begin{array}{c}a_1\\a_2\\a_3\\c_1\\c_2\\c_3\\c_4\end{array}\right]\]</span>上半部分描述了机器人的运动，下半部分是测量值。不同类型（和尺寸）的地标和/或测量值易于混合。</p><h2 id="a-linear-algebra-perspective线性代数透视">4. A Linear AlgebraPerspective（线性代数透视）</h2><p><a href="https://www.bilibili.com/video/BV1Ag411M76G/?share_source=copy_web&amp;vd_source=8d5f94cac4ef1f7256e3572189ec255b">cholesky分解是什么</a></p><p>在本节中，我们将简要回顾 Cholesky 和 QR 因式分解及其在 (9)中全秩线性最小二乘 (LS) 问题中的应用。(9) 中的全秩线性最小二乘 (LS)问题的应用。这些材料已广为人知，给出它们主要是为了回顾线性代数算法与下一节的图论观点进行对比。论述紧跟[34]，更深入的论述可参阅[34]。</p><p>原始问题是一个典型的最小二乘问题，目的是找到向量 <span class="math inline">\(\delta\)</span>，使得 <span class="math inline">\(A\delta - b\)</span> 的欧几里得范数（即 <span class="math inline">\(L_2\)</span> 范数）最小化：</p><p><span class="math display">\[\delta^* = \underset{\delta}{\operatorname*{argmin}} \|A\delta - b\|_2^2\]</span></p><p>最小化函数 <span class="math inline">\(\|A\delta - b\|_2^2\)</span>可以表示为：</p><p><span class="math display">\[\|A\delta - b\|_2^2 = (A\delta - b)^T (A\delta - b)\]</span></p><p>展开此式：</p><p><span class="math display">\[= (A\delta)^T (A\delta) - 2b^T (A\delta) + b^T b\]</span></p><p><span class="math display">\[= \delta^T A^T A \delta - 2b^T A \delta + b^T b\]</span></p><p>为了找到这个函数的最小值，我们对 <span class="math inline">\(\delta\)</span>求导，并设其导数为零。由于这里是一个二次式，其导数可以用来找到极小值点：</p><p><span class="math display">\[\frac{\partial}{\partial \delta} (\delta^T A^T A \delta - 2b^T A \delta+ b^T b) = 0\]</span></p><p>求导得：</p><p><span class="math display">\[2A^T A \delta - 2A^T b = 0\]</span></p><p>简化此式，我们得到：</p><p><span class="math display">\[A^T A \delta = A^T b\]</span></p><p>这就是所谓的<strong>正规方程</strong>，它提供了一个求解 <span class="math inline">\(\delta\)</span> 的直接方法，即通过求解线性方程组<span class="math inline">\(A^T A \delta = A^T b\)</span>来找到原始最小二乘问题的解。</p><p>这样，我们从最小化欧几里得范数的问题过渡到解线性方程的问题，两者实际上是等价的。解<span class="math inline">\(A^T A \delta = A^T b\)</span> 不仅找到了使得<span class="math inline">\(A\delta\)</span> 最接近 <span class="math inline">\(b\)</span> 的 <span class="math inline">\(\delta\)</span>，而且还以线性方程组的形式给出了直接的计算方法。这也是为什么在实际应用中（尤其是在数据拟合和机器学习中）我们经常需要计算<span class="math inline">\(A^T A\)</span> 和 <span class="math inline">\(A^T b\)</span></p><h3 id="cholesky分解">Cholesky分解</h3><p>对于全秩m×n矩阵a，具有m≥n，通过求解正规方程可以得到(9)的唯一LS解：<span class="math inline">\(A^TA\delta^*=A^Tb\)</span></p><p>这通常是通过信息矩阵I的Cholesky因子分解来完成的，定义和分解如下：<span class="math inline">\(\mathcal{I}\triangleq A^TA=R^TR\)</span></p><p>Cholesky三角分解R是一个上三角n×n矩阵，使用Cholesky分解矩阵计算，即对称正定矩阵的LU分解的一个变体。对于密集矩阵，Cholesky分解需要n<sup>3</sup>/3的运算量。<span class="math display">\[{\text{first }R^T}y=A^Tb\text{ and then }R\delta^*=y\]</span> 在此之后，可以通过求解找到δ<sup>∗</sup>通过反向替代。</p><p>Cholesky分解需要n<sup>3</sup>/3的运算量。计算一半的对称A<sup>T</sup>A，需要mn<sup>2</sup>复杂度，整个算法，包括计算一半的对称A<sup>T</sup>A，需要（m+n/3）n<sup>2</sup>复杂度。</p><p>对于图1的例子，I和它的cholelesky三角形R在图5中与A一起显示。请注意，当A的列以典型的方式排序时，I的非常典型的块结构，例如，首先是轨迹X，然后映射L（下面我们将其称为XL排序）<span class="math display">\[\left.\mathcal{I}=\left[\begin{array}{cc}A_X^TA_X&amp;\mathcal{I}_{XL}\\\mathcal{I}_{XL}^T&amp;A_L^TA_L\end{array}\right.\right]\]</span> <span class="math inline">\(\mathcal{I}_{XL}\triangleqA_X^TA_L\)</span>对机器人状态X和映射L之间的相关性进行编码，对角线块为带对角线。</p><p>避免计算平方根的Cholesky分解的一个变体是LDL分解，它计算一个下三角矩阵L和一个对角矩阵D<span class="math display">\[\mathcal{I}=R^TR=LDL^T\]</span>另一种更精确和数值稳定的Cholesky分解的方法是通过QR分解而不计算信息矩阵I。相反，我们计算A本身的QR分解及其相应的RHS：<span class="math display">\[\left.Q^TA=\left[\begin{array}{c}R\\0\end{array}\right.\right]\quadQ^Tb=\left[\begin{array}{c}d\\e\end{array}\right]\]</span>这里Q是一个m×m正交矩阵，R是上三角的Cholesky三角。分解密集矩阵A的首选方法是逐列计算R，从左到右进行。对于每一列j，对角线下的所有非零元素都通过将左边的A与Householder反射矩阵Hj相乘而归零。经过n次迭代后，A被完全分解。<span class="math display">\[\left.H_n..H_2H_1A=Q^TA=\left|\begin{array}{c}R\\0\end{array}\right.\right|\]</span> 正交矩阵Q通常不形成：相反，转换后的RHS <span class="math inline">\(Q^Tb\)</span>是通过将b作为A的附加一列来计算的。因为Q因子是正交的，我们有：<span class="math display">\[\left\|A\delta-b\right\|_2^2=\left\|Q^TA\delta-Q^Tb\right\|_2^2=\left\|R\delta-d\right\|_2^2+\left\|e\right\|_2^2\]</span> 显然，||e||将是最小二乘残差，通过求解平方系统可以得到LS解δ∗:Rδ= d</p><p>通过反向替代。QR的成本主要由Householder反射的成本决定，即2（m−n/3）n<sup>2</sup></p><p>比较QR和Cholesky分解，我们发现两种算法都需要O（mn<sup>2</sup>）运算(m&gt;n)，但QR分解要慢2倍。虽然这些数字只对密集矩阵有效，但我们已经看到，在实践中，LDL和Cholesky因子分解在稀疏问题上也远远优于QR因子分解，而不仅仅是一个常数因子。</p><h2 id="a-graphical-model-perspective图像模型透视图">5.A Graphical ModelPerspective(图像模型透视图)</h2><h3 id="matrices-graphs-矩阵-图">5.1 Matrices ⇔ Graphs （矩阵 图）</h3><p>从上面的说明中，现在可以很容易地认识到，测量雅可比矩阵A是与SLAM相关的因子图的矩阵。我们可以从两个层面上理解这个说法。首先，A的每个块对应于最小二乘准则(8)中的一项，要么是一个地标测量，要么是一个测程约束，并且每一个块行对应于因子图中的一个因子。在每个块行中，稀疏性模式表示哪些未知的姿态和/或地标与该因素相连。因此，A的块结构完全对应于与SAM相关的因子图的邻接矩阵。</p><p>其次，在标量水平上，每一行Ai在A（见图5）对应于稀疏矩阵最小二乘准则(9)中的一个标量项<span class="math inline">\(\|A_i\delta-b_i\|_2^2\)</span>，如 <span class="math display">\[\left\|A\delta-b\right\|_2^2=\sum_i\left\|A_i\delta-b_i\right\|_2^2\]</span> 因此，这定义了一个精细结构的因图，通过 <span class="math display">\[P(\delta)\propto\exp-\frac12\left\|A\delta-b\right\|_2^2=\prod_i\exp-\frac12\left\|A_i\delta-b_i\right\|_2^2\]</span>重要的是要认识到，在这个更精细的观点中，SLAM问题的块结构被丢弃了，并且它是这个图被通用的线性代数方法所检验。通过使用块结构来代替，我们将能够做得更好。</p><p>如之前在[75]以及其他文献中提到的，信息矩阵Ⅰ=A<sup>T</sup>A是与SLAM问题关联的马尔可夫随机场(MRF）的矩阵表达形式。同时，从块级别来看，A<sup>T</sup>A的稀疏模式完全等同于相应MRF的邻接矩阵。方程5中的目标函通过哈默斯利-克利福德定理[77]对应于成对马尔可夫随机场（MRF）[77,78]。而在这个MRF中，节点对应于机器人的状态和地标。链接代表里程计或地标测量。</p><p>在文献[63,75]中，采用马尔可夫随机场（MRF）图的视角来揭示SLAM滤波版本中固有的相关性结构。<strong>研究表明，当将过去的轨迹<span class="math inline">\(𝑋_{1:𝑀−1}\)</span>边缘化时，信息矩阵不可避免地变得完全密集</strong>。因此，这些方法的重点是选择性地移除链接以减少滤波器的计算成本，并取得了显著的成功。相比之下，本文考虑的是与平滑信息矩阵<span class="math inline">\(I\)</span>关联的MRF，该信息矩阵不会变得密集，因为过去的状态从未被边缘化。</p><h3 id="因式分解变量消除">5.2 因式分解⇔变量消除</h3><p>剩下的一个问题是平方根信息矩阵R对应于什么图？请记住，R是在第4节中对I或A进行因素分解的结果。Cholesky或QR因子分解最常被用作“黑盒”算法，但实际上它们与最近在图形模型[11]中开发的推理方法相似。从下面可以看到，R与结树基本对应，从图形模型的推理中知道，最近也在SLAM中应用</p><p>两种因式分解方法，QR和Cholesky（或LDL），都基于变量消除算法[4,11]。这两种方法的区别在于QR通过消除因子图中的变量节点得到<span class="math display">\[A=QR\]</span>，而Cholesky或LDL则从马尔可夫随机场(MRF)开始，因此得到<span class="math display">\[A^TA = R^TR\]</span>。这两种方法都是从<span class="math display">\[\delta_1\]</span>开始，一次消除一个变量，<span class="math display">\[\delta_1\]</span>对应于<span class="math display">\[A\]</span>或<span class="math display">\[\mathcal{I}\]</span>的最左列。消除的结果是<span class="math display">\[\delta_1\]</span>现在表示为所有其他未知数<span class="math display">\[\delta_{j&gt;1}\]</span>的线性组合，系数位于对应的<span class="math display">\[R_1\]</span>行中。然而，在此过程中，新的依赖性被引入到所有与<span class="math display">\[\delta_1\]</span>相连的变量之间，这导致图中添加了边。然后以类似方式处理下一个变量，直到所有变量都被消除。这正是图形模型推理中熟悉的公理化和三角化过程。消除所有变量的结果是一个有向的、三角化（弦图）的图，在我们的示例中显示在图6中。</p><blockquote><p>这段话描述的是在处理线性系统或矩阵分解时，如何使用变量消除算法，具体包括QR分解和Cholesky分解（或LDL分解）。以下是每部分的具体解释：</p><ol type="1"><li><p><strong>变量消除算法</strong>:这是一种算法框架，用于通过逐步简化变量来处理数学问题。在矩阵分解的上下文中，这意味着选择某个变量并重新组织方程，使得这个变量可以通过其它变量线性表示。</p></li><li><p><strong>QR分解和Cholesky分解的对比</strong>:</p><ul><li><strong>QR分解</strong>(<span class="math display">\[A =QR\]</span>)：这是通过在因子图中消除变量节点实现的。在此过程中，矩阵<span class="math display">\[A\]</span>被分解为一个正交矩阵<span class="math display">\[Q\]</span>和一个上三角矩阵<span class="math display">\[R\]</span>。QR分解特别适用于求解具有线性独立列的线性系统。</li><li><strong>Cholesky分解</strong>(<span class="math display">\[A^TA =R^TR\]</span>)：这种方法以马尔可夫随机场(MRF)为起点。在数学上，这涉及到将矩阵<span class="math display">\[A\]</span>的转置与<span class="math display">\[A\]</span>本身相乘，得到的结果是一个对称正定矩阵，然后对这个矩阵进行因式分解以得到一个上三角矩阵<span class="math display">\[R\]</span>。此方法适用于正定矩阵的分解。</li></ul></li><li><p><strong>变量消除过程</strong>:</p><ul><li>从<span class="math display">\[\delta_1\]</span>开始，它是矩阵<span class="math display">\[A\]</span>或<span class="math display">\[\mathcal{I}\]</span>的最左列所对应的变量。这个变量被消除或解算出来，并用其它变量(<span class="math display">\[\delta_{j&gt;1}\]</span>)的线性组合表示。</li><li>在消除<span class="math display">\[\delta_1\]</span>的过程中，会在图中介入新的依赖性，这些依赖性在与<span class="math display">\[\delta_1\]</span>相连的所有变量之间形成新的边。这是因为消除一个变量通常会使其相关的其他变量之间产生直接的联系，这些联系在原始图中可能并不存在。</li></ul></li><li><p><strong>公理化和三角化过程</strong>:</p><ul><li>这是图形模型推理中的常见步骤。消除变量的过程不仅涉及代数运算，还涉及图的结构变化，比如添加新的边来填充环路，使得图变成有向且无环的。</li></ul></li><li><p><strong>结果</strong>:</p><ul><li>完成所有变量的消除后，结果是一个有向的、三角化（或称为弦图）的图。在此上下文中，这意味着所有的变量都通过某种方式关联，并且关联结构支持高效的图形模型推理。</li></ul></li></ol><p>这些概念通常用于数值分析、统计建模和计算机视觉等领域，用于优化算法的效率并减少计算复杂性。</p></blockquote><p>一旦获得了弦图 <span class="math inline">\((R!)\)</span>，我们就可以得到 <span class="math inline">\(R\)</span>的消元树，它被定义为消元后弦图的深度优先生成树，并且在反向替代阶段中用于说明计算流程。为了说明这一点，图7展示了使用<strong>先消除地标再消除姿态</strong>的著名启发式方法所获得的弦图（我们将其称为<span class="math inline">\(LX\)</span> 排序）。相应的消元树在图 8中展示。树的根对应于最后一个被消除的变量 <span class="math inline">\(\delta_n\)</span>，它是在反向替代（方程13）中首先被计算的。然后，计算沿树向下进行，尽管这通常按逆列顺序完成，但在不相连的子树中的变量可以按任何顺序计算。实际上，如果只对某些变量感兴趣，那么没有必要计算不包含这些变量的任何子树。</p><p>然而，分析并没有就此结束。<span class="math inline">\(R\)</span>的图具有一个可以完全封装在称为团树（cliquetree）的根树数据结构中的团结构 [64,4]，在人工智能文献中也称为连接树（junction tree）[11]。例如，图 1问题上的 <span class="math inline">\(LX\)</span> 排序的团树在图 9中展示。对应关系几乎是一对一的：每个 <span class="math inline">\(R\)</span>准确对应一个团树，反之亦然，仅需在团内进行列重排。团树也是多前端 QR 方法[56] 的基础，我们在下面的模拟中也对此进行了评估。在多前端 QR因式分解中，计算从树的叶子到根进行，以分解一个稀疏矩阵，然后从根到叶子进行反向替代步骤。关于平方根信息矩阵和团树之间关系的完整处理超出了当前论文的范围，但在其他工作中，我们已经在分布式推断的新算法中使用了团树结构[19]。</p><h3 id="提高性能减少填料">5.3提高性能⇔减少填料</h3><p>良好性能的最重要的因素是变量的顺序。<strong>不同的变量顺序</strong>可以显著地产生或多或少的填充，定义为在因子分解过程中添加到图中的边的量。由于每条边对应于Choleseky三角形R中的非零，计算R和反向替换的成本在很大程度上取决于发生的填充量。不幸的是，找到一个最优排序是np完备的。发现近似最优排序的算法是稀疏线性代数研究的一个活跃领域。一种常用的处理中型问题的方法是联合[1]，另一种基于图论的常用方法是广义嵌套解剖[53,52]。</p><p>假设最优排序通常是遥不可及的，启发式或领域知识可以比通用算法做得更好。一个简单的想法是使用一个标准的方法如colamd，但它工作块的稀疏模式而不是通过原来的测量雅可比a正如我们上面提到的，块结构是真正的知识SLAM问题，不能访问colamd或任何其他近似排序算法。虽然对colamd性能的影响可以忽略不计，但我们发现，让它在SLAMMRF上工作，而不是直接在稀疏矩阵上工作，有时可以提高2到100倍，15是一个很好的经验法则。</p><p>请注意，在某些情况下，任何排序都会导致相同的大填充。最坏的情况是一个完全连接的二部2MRF：每个地标都可以从每个位置看到。在这种情况下，消除任何变量将完全连接所有变量的另一边，之后集团树的结构是完全已知的：如果首先选择一个姿势，根将整个地图，和所有姿态将计算一旦地图。反之亦然，如果选择了一个地标，那么轨迹将是团树根团，计算将通过（昂贵的）轨迹优化进行，然后是（非常便宜的）地标计算。最重要的是，这两种情况构成了“舒尔补体”技巧的基础，它在结构中从运动应用[76,40]中闻名，也在GraphSLAM[74]中使用。</p><p>然而，上面概述的最坏情况是机器人技术中的一个例外：传感器的范围有限，并且被墙壁、物体、建筑物等遮挡。这在大规模映射应用程序中尤其如此，它本质上意味着MRF通常将是稀疏连接的，即使它是一个大的连接组件。</p><blockquote><p>这一段文本详细解释了如何利用QR和Cholesky（或LDL）因子分解方法来处理矩阵，以及这些方法与图形模型中的推理如何相互关联。下面我将逐步解释这些内容：</p><ol type="1"><li><strong>因子分解方法</strong>:<ul><li><strong>QR 和Cholesky（或LDL）因子分解</strong>：这两种方法都基于变量消除算法。QR方法通过从因子图中消除变量节点来获得<span class="math display">\[A =QR\]</span>，而Cholesky或LDL方法从马尔可夫随机场(MRF)出发，得到 <span class="math display">\[A^T A = R^T R\]</span>。</li><li><strong>变量消除过程</strong>：从 <span class="math display">\[\delta_1\]</span> 开始，逐一消除变量，<span class="math display">\[\delta_1\]</span> 是矩阵 <span class="math display">\[A\]</span> 或 <span class="math display">\[\mathcal{I}\]</span>的最左列。消除的结果是，<span class="math display">\[\delta_1\]</span>被表示为所有其他未知数 <span class="math display">\[\delta_{j&gt;1}\]</span> 的线性组合，系数存放在<span class="math display">\[R_1\]</span>行中。这个过程引入了新的依赖性，导致图中增加了边。</li></ul></li><li><strong>图的形成与消元树</strong>:<ul><li><strong>形成弦图</strong>：通过上述变量消除，最终得到一个有向的、三角化（弦图）的图。</li><li><strong>消元树</strong>：一旦得到弦图，可以定义一个消元树，这是消元后弦图的深度优先生成树。这个树在反向替代阶段中非常有用，用于指导计算流程。</li></ul></li><li><strong>团树结构</strong>:<ul><li><strong>团树（clique tree）或连接树（junction tree）</strong>：<span class="math display">\[R\]</span>的图具有可以完全封装在团树数据结构中的团结构。团树几乎与 <span class="math display">\[R\]</span> 一一对应，每个 <span class="math display">\[R\]</span>精确对应一个团树，反之亦然，只需在团内进行列重排。</li><li><strong>多前端QR方法</strong>：在多前端QR因式分解中，计算从树的叶子到根进行，以分解一个稀疏矩阵，然后从根到叶子进行反向替代步骤。这种方法基于团树结构进行计算。</li></ul></li><li><strong>应用与扩展</strong>:<ul><li>在其他工作中，已经在分布式推断的新算法中使用了团树结构。这显示了此类数学工具不仅限于单一应用，而是可以广泛应用于各种复杂问题的求解中。</li></ul></li></ol><p>这段描述不仅阐述了两种主要的因子分解方法的技术细节，还链接了这些数学技术和图形模型理论的关系，尤其是在如何使用图结构来优化计算和推理过程中。</p></blockquote><h2 id="square-root-sam">6 Square Root SAM</h2><p>在本节中，我们将获取我们从上面所知道的所有内容，并说明三个简单的√SAM变体，这取决于它们是以批处理还是增量模式运行，以及是否涉及非线性。</p><h3 id="batchsam">6.1 Batch√SAM</h3><p>一个批量版本的平方根信息平滑和映射是很简单的，也是解决一个大的、稀疏的最小二乘问题的一种通用的标准方法：</p><p><span class="math display">\[\begin{aligned}&amp;\frac{\textbf{Algorithm 1 Batch}\sqrt{\text{SAM}}}{\text{I. Build the measurement Jacobian}A\mathrm{~and~the~RHS~}b\text{ as explained in Section3.}}\\&amp;2.\text{ Find a good column odering }p,\text{ and reorder}A_p\xleftarrow{p}A\\&amp;3.\text{ Solve }\delta_p^*=\text{ argmin}_\delta\left\|A_p\delta_p-b\right\|_2^2\text{ using ether the Choleskyor QR factorization method}\\&amp;\text{from Section 4}\\&amp;4.\text{Recover the optimal solution by }\delta\xleftarrow{r}\delta_p,\text{with}r=p^{-1}\end{aligned}\]</span></p><ol type="1"><li>建立第3节所述的雅可比值A和RHS b</li><li>找到一个好的列排序p，并重新排序App←a</li><li>使用第4节中的Cholesky或QR分解方法 解决 δ∗p=argminδkApδp−bk22</li><li>用δr←δp恢复最优解，用r=p−1</li></ol><p>在测试中，我们获得了稀疏LDL分解[13]的最佳性能，如上所述，它是计算I =LDL<sup>T</sup>的一个变体，D为对角矩阵，L是对角上的三角矩阵。同样的算法也适用于非线性情况，但被非线性优化器简单地调用。但是，请注意，排序只需要计算一次。</p><h2 id="其他">其他</h2><h3 id="消元树">消元树</h3><p>消元树是一种用来表示消除过程中变量依赖关系的树状结构，它帮助指导了矩阵分解过程中的计算流程，特别是在反向替代阶段。这里用一个具体的例子来说明这一点：</p><p>假设我们有一个系统的矩阵 <span class="math display">\[A\]</span>，我们想要进行Cholesky分解（假设<span class="math display">\[A\]</span>是对称正定的）。我们首先选择一个变量来消除，这通常是基于某种启发式方法，比如最小填充法或最小度法。</p><p>考虑以下矩阵：</p><p><span class="math display">\[A = \begin{bmatrix}4 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 4 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 4 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 3 \\\end{bmatrix}\]</span></p><p><strong>第一步：消除第一个变量</strong></p><p>我们首先消除第一个变量，这会影响与它直接相连的变量（这里是第二个变量）。消除第一个变量后，更新矩阵（做适当的行和列操作）可能会导致非零元素填充原本为零的位置，即产生“填充”。</p><p><strong>弦图的形成</strong></p><p>在这个过程中，如果我们将每个变量和与它相邻的变量视为图的一个节点和边，消除一个变量相当于在图中移除一个节点及其相关的边，并可能在未被消除的相邻节点间添加新的边（如果它们之前不直接相连）。这个操作最终形成了一个弦图，即每个循环都至少有一个弦（非环的边）的图。</p><p><strong>构建消元树</strong></p><p>在构建弦图的基础上，消元树被定义为消除过程中的依赖关系图。例如：</p><ol type="1"><li>将第一个被消除的变量作为树的根节点。</li><li>每次消除一个变量后，将受到影响的变量作为当前消除变量的子节点添加到树中。</li></ol><p>对于上面的矩阵，消元树可能如下：</p><ul><li>根节点为第一个被消除的变量。</li><li>第二个被影响的变量成为第一个节点的子节点。</li><li>依次类推，直到所有变量都被放置在树中。</li></ul><p><strong>在反向替代阶段的作用</strong></p><p>在进行例如Cholesky分解后，求解线性系统 <span class="math display">\[Ax = b\]</span> 需要先进行前代（使用 <span class="math display">\[L\]</span> 矩阵）和后代（使用 <span class="math display">\[L^T\]</span>矩阵）。在后代过程中，消元树指导了计算的顺序：从树的叶子（最先消除的变量）开始，逐步向根节点（最后消除的变量）进行，确保在计算当前变量值之前，所有依赖于它的变量值已经被计算。</p><p>通过这种方式，消元树不仅帮助优化计算过程，还确保了在计算过程中遵循正确的依赖关系，有效地利用了矩阵的稀疏性质。</p><h3 id="滤波器与平滑器">滤波器与平滑器</h3><p>在SLAM（Simultaneous Localization andMapping，即同时定位与建图）问题中，信息矩阵 (I)是一个关键的概念，用于表示机器人的状态（如位置和方向）以及环境中地标的不确定性。信息矩阵是协方差矩阵的逆，其中每个元素反映了状态变量之间的条件依赖性。</p><p><strong>滤波器与平滑器的区别</strong></p><p>在SLAM中，主要有两种处理信息的方法：滤波和平滑。</p><ol type="1"><li><strong>滤波</strong>：<ul><li>在滤波过程中，为了保持计算的实时性和可管理性，通常只会保留当前状态的信息，而把旧的状态信息“边缘化”（即从当前考虑的状态集中移除）。<strong>这种边缘化过程会引入额外的非零元素到信息矩阵中，因为边缘化旧状态意味着需要将这些状态的信息“分摊”到剩余的状态上</strong>。结果是信息矩阵变得密集，即使原来很多状态之间是条件独立的。</li><li>为了处理这种密集化，研究者通常会采用各种技术（如稀疏化技术）来移除信息矩阵中的某些链接，以减少计算负担。</li></ul></li><li><strong>平滑</strong>：<ul><li>平滑处理，相比于滤波，不会边缘化任何过去的状态。相反，它保留了所有历史和当前的状态信息，因此可以在整个时间线上提供更精确的状态估计。</li><li>在平滑方法中，由于不进行边缘化操作，所以不会引入额外的非零元素导致信息矩阵密集化。这意味着信息矩阵能够保持其原始的稀疏结构，其中非零元素主要集中在时间线上相邻状态之间的依赖关系。这种稀疏性是因为在大多数SLAM场景中，只有时间上相邻的状态或空间上邻近的地标才具有直接的相互依赖。</li></ul></li></ol><p><strong>结论</strong></p><p>因此，在与平滑信息矩阵 (I)关联的MRF中，信息矩阵保持稀疏，主要是因为平滑处理不涉及边缘化过去的状态。这样，每个状态只与其直接相关的少数几个其他状态或地标相关联，而不是与整个历史状态集相关联，从而避免了矩阵的密集化。这种方法不仅保持了计算效率，而且通常能提供比滤波更为精确的状态估计。</p><p><strong>滤波</strong>是一种在线处理方式，即它只处理当前和过去的信息，通常用于实时系统中。在滤波过程中，随着新数据的持续加入，为了维持计算的可管理性，旧的数据或状态往往需要被边缘化（移除），这导致信息矩阵趋向于变得密集。</p><p><strong>平滑</strong>则是一种离线处理方式，它考虑全部的数据（包括过去和未来的数据）。在平滑处理中，由于不需要边缘化任何状态（因为所有状态对计算都是可用的），所以关联的信息矩阵维持稀疏性，这是因为不存在需要通过边缘化引入新依赖的需求。</p><h4 id="滤波">滤波</h4><p>当然可以，让我们通过一个具体的例子来解释为什么在SLAM中进行滤波操作时，边缘化过去的状态会导致信息矩阵变得密集。</p><p><strong>示例情景</strong></p><p>假设一个机器人在一个简单的环境中沿直线移动，每移动一段距离记录一次位置，形成状态序列(X_1, X_2, X_3, ,X_t)。每个状态都与其前后状态有直接的连接（例如通过里程计测量），并可能与环境中的某些地标有关联。</p><p>在开始，信息矩阵 (I)是稀疏的，因为只有时间上相邻的状态或与某个地标直接相关的状态之间存在连接。例如，如果(X_1)和(X_2)通过里程计相关联，那么在信息矩阵中，(I_{1,1})，(I_{1,2})，和(I_{2,2})是非零的。</p><p><strong>边缘化过程</strong></p><p>当机器人继续前进并且需要在滤波器中处理新的状态时（比如(X_{t+1})），为了保持计算的可管理性，较早的状态（比如(X_1))可能会被边缘化掉。边缘化(X_1)意味着我们需要从当前激活的状态集中移除(X_1)的影响。</p><ul><li>原本(X_1)直接影响(X_2)，在边缘化(X_1)后，我们必须将(X_1)对(X_2)的影响“转移”给与(X_2)相关的其他状态，比如(X_3)。这意味着原先(X_1)与(X_3)可能没有直接关系，但在边缘化(X_1)后，(X_2)与(X_3)之间的关系需要加强，以反映从(X_1)到(X_3)的间接影响。</li></ul><p><strong>结果</strong></p><p>这个转移过程在信息矩阵中表现为原先为零的元素变成非零，因为(X_2)和(X_3)现在有了新的依赖关系。随着越来越多状态的边缘化，这种间接依赖会累积，导致信息矩阵逐渐从稀疏变为密集。</p><p><strong>几何直观</strong></p><p>可以想象，每个状态不仅与其直接的邻居有联系，还因为边缘化而与更多其他状态产生了联系。随着时间的推移，几乎每个状态都以某种方式间接地与其他所有状态连接，从而增加了信息矩阵中的非零元素数量，使矩阵变得密集。</p><p>这种密集化不仅增加了计算的复杂度，还可能影响滤波器的性能，因此在实际应用中，开发者会寻找各种方法（例如使用稀疏近似或选择性地保留关键状态）来尽可能减少这种影响。</p><h4 id="平滑">平滑</h4><p>我们可以用一个具体的数学例子来解释SLAM问题中平滑方法的信息矩阵是如何维持其稀疏性的。在这个例子中，我们考虑一个小规模的机器人轨迹，其中机器人在四个时间点上测量其位置。我们将看到在不进行边缘化的情况下，信息矩阵如何保持其结构。</p><p>假设有四个状态 (X_1, X_2, X_3,X_4)，它们代表机器人在四个连续时间点的位置。在SLAM中，通常只有连续的状态之间存在直接的测量依赖关系。</p><p>在平滑方法中，信息矩阵 (I)初始化时将反映状态之间的这些直接依赖关系。例如，如果我们假设每个状态只与其前后状态有关系，并且每个这样的依赖对信息矩阵贡献(1) 的信息值，那么信息矩阵可能看起来像这样：</p><p><span class="math display">\[I = \begin{bmatrix}1 &amp; -1 &amp; 0 &amp; 0 \\-1 &amp; 2 &amp; -1 &amp; 0 \\0 &amp; -1 &amp; 2 &amp; -1 \\0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\]</span> 这里，对角线上的元素 (2)表示一个状态依赖于其前后状态的信息总和（除了边界条件，即 (X_1) 和(X_4)）。非对角线的 (-1) 表示状态 (X_i) 与 (X_{i+1}) 和 (X_{i-1})之间的信息依赖。</p><p>在平滑方法中，由于不进行边缘化操作，我们保留所有历史状态的数据。这意味着在任何给定的时刻，我们都可以访问到所有历史和未来的状态信息，而不是只有当前和未来的状态。因此，信息矩阵的非零结构不会改变——它始终保持与初始时刻相同的稀疏模式。</p><p>这种方法的优点是，信息矩阵维持了其稀疏性，这大大减少了计算的复杂性和内存需求。例如，当使用稀疏矩阵技术处理大型SLAM问题时，这一特性非常重要。每个状态只与直接相邻的状态有关系，没有因边缘化而引入的额外复杂依赖关系。</p><p>这样的稀疏结构是高效处理大规模SLAM问题的关键，因为它减少了必须处理的数据量，并允许使用优化的数值方法来处理信息矩阵。</p><p><strong>为什么在平滑中仍然会有变量消除</strong></p><p>尽管在平滑处理中，信息矩阵维持其稀疏性质，我们仍可能需要执行某种形式的变量消除，这主要是为了效率和算法实现上的考虑。例如，在求解线性系统时（如<span class="math display">\[Ax =b\]</span>），通常会采用一些数学技术来简化问题，比如通过Cholesky分解等。在这个过程中，创建弦图和消元树是为了优化这些数学操作：</p><ol type="1"><li><p><strong>弦图的创建</strong>：在进行Cholesky分解等操作前，弦图能帮助我们识别并利用信息矩阵的稀疏结构，以减少计算过程中的填充（非零元素的添加）。</p></li><li><p><strong>消元树的建立</strong>：即便信息矩阵是稀疏的，构建消元树可以进一步提高解线性系统的效率。消元树能够指导计算顺序，确保依赖关系得到正确处理，并优化内存访问模式。</p></li></ol><p>因此，尽管平滑信息矩阵在理论上不需要通过边缘化来维护其稀疏性，但在实际计算和算法实现中，变量消除和相关的图形表示（如弦图和消元树）仍然是优化性能和保证算法效率的重要工具。</p><h3 id="qr分解">QR分解</h3><p>QR分解是将矩阵 ( A ) 分解成一个正交矩阵 ( Q ) 和一个上三角矩阵 ( R )的方法。如果 ( A ) 是一个 ( m n ) 矩阵且 ( m n)，那么分解形式通常写为：</p><p><span class="math display">\[A = QR\]</span></p><p>其中，( Q ) 是 ( m m ) 正交矩阵（( Q^T Q = QQ^T = I )），( R ) 是 ( mn ) 的上三角矩阵，其中除了前 ( n )行可能有非零元素外，其余部分全为零。在许多实际情况中，我们更关心 ( R )的前 ( n n ) 部分，因为它是一个完全的上三角矩阵。</p><p><strong>为什么 ( R ) 下面有一个0</strong></p><p>在 ( Q^T A = ) 的表达式中，( R ) 是 ( n n )的上三角矩阵，而下面的0表示在 ( Q^T ) 作用后，剩下 ( m-n )行都被消减到了零。这是因为 ( Q ) 通过正交变换将 ( A )的所有向量投影到一个由 ( A ) 的列空间张成的正交子空间。</p><p><strong>如何进行QR分解</strong></p><p>QR分解可以通过多种方式进行，包括Householder反射、Gram-Schmidt正交化或Givens旋转等。其中，Householder反射是最常用的方法，因为它具有很好的数值稳定性。</p><p><strong>Householder反射</strong>:</p><ol type="1"><li>选取一个列向量，构造一个反射矩阵 ( H)，使得除了第一项外，该列的其余项变为零。</li><li>重复应用上述过程，每次将 ( A )的一个列向量（逐步从左到右）变为期望的上三角形式。</li><li>通过连续左乘不同的Householder矩阵（( H_1, H_2, , H_n)），我们最终得到 ( Q^T A = )。</li></ol><p><strong>QR分解在最小二乘中的应用</strong></p><p>在最小二乘问题中，我们通常要最小化 ( |A- b|_2^2)。通过QR分解，我们可以转化这个问题为：</p><p><span class="math display">\[\|Q^T(A\delta - b)\|_2^2 = \|R\delta - Q^Tb\|_2^2\]</span></p><p>由于 ( Q ) 是正交的，所以转换不会改变二范数。因此，问题简化为最小化 (|R- d|_2^2 )（其中 ( d ) 是 ( Q^Tb ) 的前 ( n ) 个元素）加上 ( |e|_2^2)（其中 ( e ) 是 ( Q^Tb ) 的剩余 ( m-n ) 个元素，代表方程的残差）。</p><p>由于 ( R ) 是上三角的，这个问题可以通过反向替换直接求解 ( R= d)，从而找到最小二乘解 ( ^* )。</p><p>在说明为什么在 ( A = QR ) 分解中，矩阵 ( R ) 除了前 ( n )行可能有非零元素外，其余部分全部为 0之前，有必要澄清上面的描述有些不够精确。对于标准的 ( A = QR )分解，特别是当 ( A ) 是 ( m n ) 矩阵且 ( m n )时，我们应该更明确地表示这个关系。</p><p><strong>正确的 ( R ) 矩阵结构</strong></p><p>在 ( A = QR ) 分解中，( R ) 实际上是一个 ( n n ) 的上三角矩阵，而不是( m n ) 的矩阵。这是因为 ( Q ) 是一个 ( m m ) 的正交矩阵，而 ( R )是一个 ( m n ) 的矩阵，其中只有顶部的 ( n n ) 部分是上三角形的，其余 (m-n ) 行则全部为零。这样，( QR ) 的乘积仍然能重构出原始的 ( m n ) 矩阵 (A )。</p><p><strong>为什么 ( R ) 的下部为零</strong></p><ol type="1"><li><p><strong>正交变换的作用</strong>：在 ( QR ) 分解中，( Q )的作用是通过正交变换（如Householder变换或Givens旋转）逐步将 ( A )的列向量变为上三角形式。每次变换主要集中在将当前处理的列下方的元素变为零。</p></li><li><p><strong>维度限制</strong>：当处理到 ( A ) 的第 ( n ) 列时，如果 (m &gt; n )，则在 ( n )行之下没有更多的列元素可以继续处理。因此，在完成所有列的变换后，( R )矩阵中 ( n ) 行以下的部分将会保持为零。这是因为这部分 ( Q )中的变换已经将 ( A ) 的所有相关信息“推”到了其前 ( n )行中的上三角形状。</p></li></ol><p>因此，( R ) 矩阵的结构确保了 ( QR ) 分解的过程只影响 ( A ) 的前 ( n )行，而其余 ( m-n ) 行为零，确保 ( QR ) 乘积可以精确重构原始矩阵 ( A)。这种结构特点是 ( QR )分解的一个重要特性，使得它在解决线性最小二乘问题和其他矩阵相关计算中非常有效。</p><h3 id="信息矩阵i">信息矩阵I</h3><p>在机器人定位和地图构建的问题中，通常涉及到估计机器人在环境中的位置（轨迹(X)）以及环境本身的结构（地图 (L)）。在这种情况下，信息矩阵()，也被称为费舍尔信息矩阵，是用来表示这些未知量的不确定性和相互依赖关系的关键工具。</p><p>信息矩阵 () 是由雅可比矩阵 (A)（或系统的设计矩阵）通过 (A^T A)计算得到的。这个矩阵可以从以下几个方面描述机器人轨迹和地图内部的信息：</p><ol type="1"><li><strong>量化不确定性</strong>:<ul><li><strong>对角线元素</strong>：信息矩阵的对角线元素量化了每个参数（位置或地图特征）的信息量或确信度。对角线元素的值越大，表示对应参数的不确定性越小，我们对该参数的估计越精确。</li><li><strong>非对角线元素</strong>：非对角线元素描述了参数之间的依赖关系或相关性。例如，如果位置(x_i) 和位置(x_j)（或地图特征）在矩阵中的对应元素非零，这表明这两个位置（或特征）的估计值相互依赖。</li></ul></li><li><strong>编码相关性</strong>:<ul><li>分块 (<em>{XL}) 和 (</em>{XL}^T) 特别重要，因为它们编码了轨迹 (X)和地图 (L)之间的相关性。这意味着机器人在特定位置的估计如何依赖于地图的特定特征，反之亦然。这种相关性对于同时定位和地图构建（SLAM）至关重要，因为它帮助系统同时解决导航和地图创建的问题。</li></ul></li><li><strong>优化和解算</strong>:<ul><li>在实际应用中，基于信息矩阵的结构，可以采用更有效的数值方法来解决估计问题，如使用稀疏矩阵技术处理大规模SLAM问题。信息矩阵的稀疏性表明很多参数之间的依赖性较低，这可以大大减少计算量。</li></ul></li></ol><p>总之，信息矩阵 ()不仅提供了对机器人轨迹和地图每一部分的内部信息的详尽描述，而且还通过其结构揭示了不同部分之间的相互作用和依赖性，从而在理论和实践中都是解决SLAM问题的核心部分。</p><p>这段话描述的是矩阵()，它代表了信息矩阵，在这个具体例子中，它是用于机器人状态估计的问题。矩阵() 是通过矩阵 (A) 的转置乘以 (A) 计算得到的，这里 (A)被分为两部分：对应于机器人轨迹 (X) 的 (A_X) 和对应于地图 (L) 的(A_L)。</p><p>矩阵 () 的结构表明它分为四个部分：</p><ol type="1"><li>(A_X^T A_X)：这是左上角的块，代表轨迹 (X) 内部的信息。</li><li>(A_L^T A_L)：这是右下角的块，代表地图 (L) 内部的信息。</li><li>(<em>{XL}) 和 (</em>{XL}^T)：这两个块分别位于非对角线的位置，(_{XL}A_X^T A_L) 和其转置表示轨迹 (X) 和地图 (L) 之间的相关性。</li></ol><p><span class="math display">\[\mathcal{I}_{XL} \triangleq A_X^T A_L\]</span></p><p>表示的是 (A_X) 和 (A_L) 之间的交叉信息，它编码了机器人状态 (X) 和地图(L) 之间的相关性。对角线块 (A_X^T A_X) 和 (A_L^T A_L)表明它们是“带对角线”的，这通常意味着这些块主要关注各自的内部结构和相互作用，而不是外部的。</p><h3 id="关于ax-b-中a和b的物理意义">关于AX-b 中A和b的物理意义</h3><p>在SLAM（Simultaneous Localization andMapping）问题中，机器人的动态与环境交互通过一系列的状态转移和观测更新来描述。矩阵( A )在这个问题中的作用，是将这些动态和交互的关系转化为数学形式，特别是以线性化的方式来近似非线性系统的行为。下面详细解释这一点：</p><p><strong>机器人的动态</strong></p><p>机器人的动态指的是机器人如何根据其控制指令（如速度和方向）从一个状态（位置和方向）移动到另一个状态。这些动态通常可以用一个非线性函数( f ) 表示：</p><p><span class="math display">\[x_i = f(x_{i-1}, u_i)\]</span></p><p>其中，( x_i ) 和 ( x_{i-1} ) 分别是连续两个时间步的状态，( u_i )是在时间 ( i ) 应用的控制指令。在SLAM问题的线性化处理中，我们对函数 ( f) 在某个点进行泰勒展开，通常是在预测状态附近，得到：</p><p><span class="math display">\[x_i \approx F_i^{i-1} x_{i-1} + G_i^i u_i\]</span></p><p>其中，( F_i^{i-1} ) 和 ( G_i^i )是偏导数矩阵，代表状态和控制输入对新状态的线性影响。这一部分在矩阵 ( A )中以块的形式出现，描绘了状态之间的转移关系。</p><p><strong>环境的观测</strong></p><p>环境的观测描述了机器人如何通过其传感器（如摄像头、激光雷达）观察到周围环境，特别是地标的位置。这些观测同样可以表示为一个非线性关系( h )：</p><p><span class="math display">\[z_k = h(x_{i_k}, l_{j_k})\]</span></p><p>其中，( z_k ) 是第 ( k ) 次观测，( x_{i_k} ) 是观测时的机器人状态，(l_{j_k} )是被观测的地标。同样地，通过在预测观测点附近进行泰勒展开，我们得到观测的线性化模型：</p><p><span class="math display">\[z_k \approx H_k^{i_k} x_{i_k} + J_k^{j_k} l_{j_k}\]</span></p><p>这里的 ( H_k^{i_k} ) 和 ( J_k^{j_k} )代表观测模型的线性化矩阵，反映了状态和地标位置对观测结果的线性影响。这部分在矩阵( A ) 中也以块的形式呈现。</p><p><strong>总结</strong></p><p>因此，矩阵 ( A )通过其块状结构和各个元素，捕捉了机器人如何移动（动态）和如何观察周围环境（观测）的数学描述。这不仅包括了机器人状态的转移关系，还包括了状态与环境地标之间的相互作用。通过优化问题最小化( |A- b|_2^2)，我们实际上是在调整对机器人状态和地图的估计，使得这些线性化的预测尽可能贴近实际观测，从而实现同时定位与地图构建的目的。在SLAM（Simultaneous Localization and Mapping）问题中，矩阵 ( A ) 和向量( b ) 代表了机器人定位与地图构建问题的线性化模型。这里详细解释矩阵 ( A )的意义和重要性：</p><p><strong>矩阵 ( A ) 的意义：</strong></p><ol type="1"><li><strong>物理意义</strong>：矩阵 ( A )表示系统状态变量之间的关系，以及状态变量与观测之间的线性关系。具体来说：<ul><li><strong>运动模型部分</strong>：矩阵 ( F_i^{i-1} ) 和 ( G_i^i )表示从状态 ( x_{i-1} ) 到状态 ( x_i )的线性化运动模型。这些块表示了机器人如何从一个位置（和/或方向）移动到下一个位置，通常基于机器人的控制指令如转向和前进。</li><li><strong>观测模型部分</strong>：矩阵 ( H_k^{i_k} ) 和 ( J_k^{j_k} )表示状态 ( x_{i_k} ) 和地标 ( l_{j_k} ) 如何影响第 ( k )次观测。这反映了如何从当前状态和地标位置预测观测值（例如，从摄像头或激光雷达）。</li></ul></li><li><strong>计算意义</strong>：在最优化问题中，我们通常求解最小化 (|A-b|_2^2)，这是一个最小二乘问题，意味着我们在寻找最佳的状态变量更新 ()，使得线性化模型的预测尽可能接近实际观测和运动指令的结果。</li></ol><p><strong>为什么 ( A ) 重要：</strong></p><ul><li>( A )矩阵捕捉了机器人动态和环境的整体结构，这是理解和解决SLAM问题的核心。正确构建和更新这个矩阵对于准确地估计机器人的状态和地图至关重要。</li><li>矩阵的稀疏性表明大多数状态变量不直接相互影响，这在数值计算上是有利的。稀疏矩阵技术可以显著提高求解SLAM问题的效率。</li></ul><p>因此，( A )矩阵不仅在物理上描绘了机器人在环境中的动态和相互作用，而且它是数学上解决状态估计问题的基础。通过理解和利用这种结构，可以更有效地实现机器人的自主导航和环境感知。</p><p>在SLAM（Simultaneous Localization and Mapping）问题中，矩阵 ( A )和向量 ( b )的物理意义及其在优化问题中的作用是核心部分，反映了状态估计的数学模型与实际操作间的联系。以下是使用LaTeX 语法格式输出的详细解释：</p><p><strong>矩阵 ( A ) 和向量 ( b ) 的物理意义</strong></p><ol type="1"><li><strong>矩阵 ( A )</strong>：矩阵 ( A )在SLAM中代表系统的线性化状态转移和观测模型。它是状态和观测之间关系的线性近似表示，包含了如下两个主要部分：<ul><li><strong>状态转移模型</strong>：通过 ( F_i^{i-1} ) 和 ( G_i^i )描述的块，这些块说明了给定控制输入 ( u_i ) 下，机器人状态从 ( x_{i-1} )转移到 ( x_i ) 的预测模型。</li><li><strong>观测模型</strong>：通过 ( H_k^{i_k} ) 和 ( J_k^{j_k} )描述的块，这些块表明如何从当前的状态和地标位置预测可能的观测结果 ( z_k)。</li></ul></li><li><strong>向量 ( b )</strong>：向量 ( b )通常包含观测数据与由模型预测的状态转移或观测的差异。在SLAM中，( b )可能由实际观测值 ( z_k )减去根据当前状态估计和地标估计得到的预测观测值构成。</li></ol><p><strong>最小化正规方程 ( A^T A x = A^T b )</strong></p><p>在SLAM问题的线性化模型中，我们通常希望找到一个状态变量的更新量 ()，使得模型预测尽可能贴近实际的观测。具体来说，我们尝试最小化以下目标函数：</p><p><span class="math display">\[\| A \delta - b \|_2^2\]</span></p><p>这里：</p><ul><li>( | |_2^2 ) 表示二范数的平方，用于度量误差的大小。</li><li>( A ) 表示对当前状态估计的改正（或更新）。</li><li>( b ) 是观测数据与模型预测之间的差异。</li></ul><p><strong>通过最小化这个误差，我们在数学上是在寻找一个向量 ( )，使得 (A ) 尽可能接近 ( b)，即尝试对预测的状态和观测进行校正，以逼近真实的观测值。</strong></p><p>解决这个最小化问题通常涉及到求解正规方程：</p><p><span class="math display">\[A^T A \delta = A^T b\]</span></p><ul><li>( A^T A ) 是一个方阵，通常更易于处理，尤其是当 ( A )是稀疏或结构化的时，这种方法效率更高。</li><li>( A^T b )是一个向量，表示在当前误差度量下，最佳更新方向的投影。</li></ul><p>简而言之，矩阵 ( A ) 和向量 ( b )在SLAM中承载着将复杂的非线性系统模型化并使之适合数学优化的重任。通过这种优化，我们能够不断提高对机器人在未知环境中位置及其环境地图的估计精度。</p><h3 id="因子图的迭代优化算法">因子图的迭代优化算法</h3><p>图优化的迭代优化通常涉及到通过逐步优化来调整和改进图中的节点估计（即状态变量），以最小化整个图中所有误差函数（因子）的总和。这个过程通常使用类似于高斯-牛顿或者Levenberg-Marquardt（LM）算法的优化方法。</p><p><strong>图优化迭代过程</strong></p><ol type="1"><li><strong>初始化</strong>：<ul><li>节点的初始估计通常基于传感器的原始数据或某些先验知识。</li></ul></li><li><strong>构建误差函数</strong>：<ul><li>对于图中的每一个因子，构建一个误差函数，该函数衡量当前节点状态估计与观测数据之间的差异。</li></ul></li><li><strong>线性化误差函数</strong>：<ul><li>在当前估计点附近对误差函数进行线性化，通常是通过计算误差函数相对于每个节点状态的雅可比矩阵。</li></ul></li><li><strong>构建正规方程</strong>：<ul><li>将所有线性化的误差函数组合成一个大的系统方程。这通常表现为一个大的稀疏线性系统，可以写成<span class="math display">\[ H\delta = b \]</span> 的形式，其中 ( H )是信息矩阵（或海森矩阵），而 ( b ) 是基于误差的向量。</li></ul></li><li><strong>求解线性系统</strong>：<ul><li>使用直接求解器（如Cholesky分解）或迭代求解器（如共轭梯度法）来解决上述线性系统，以找到状态更新()。</li></ul></li><li><strong>更新状态估计</strong>：<ul><li>将解得的 () 应用到当前的状态估计中，更新所有节点的状态。</li></ul></li><li><strong>迭代和收敛检查</strong>：<ul><li>检查解的改进程度，如果未达到预设的收敛标准（如状态改变量的大小低于某个阈值或达到最大迭代次数），则重复步骤2-6。</li></ul></li><li><strong>最终优化结果</strong>：<ul><li>当迭代收敛时，当前的状态估计被认为是优化的解，即图中所有节点的最优估计。</li></ul></li></ol><p><strong>使用Levenberg-Marquardt方法的特别说明</strong></p><p>Levenberg-Marquardt算法是高斯-牛顿算法的一个变种，通过引入一个调整参数（阻尼因子）来平衡算法的迭代速度与稳定性。这个阻尼因子可以动态调整，以在必要时约束更新步长，从而提高收敛性和算法的鲁棒性。</p><p>图优化的迭代优化是一个强大的工具，特别适用于大规模、复杂的环境建模，如同时定位与地图创建（SLAM）等应用场景中。通过迭代改进，算法能够有效地精炼传感器数据与模型之间的不一致，最终达到高精度的状态估计。</p><h3 id="为什么用cholesky-分解求解正规方程">为什么用Cholesky分解求解正规方程</h3><p>当然可以，这里是使用 LaTeX 语法重新整理的解释：</p><p><strong>为什么使用 Cholesky 分解？</strong></p><ol type="1"><li><strong>效率和稳定性</strong>：<ul><li><strong>效率</strong>：Cholesky分解相比于其他方法（如LU分解或QR分解）通常更为高效。它的计算复杂度大约是<span class="math display">\[\frac{1}{3} n^3\]</span> 对于 <span class="math display">\[n \times n\]</span>矩阵，而LU分解和QR分解的计算复杂度分别大约是 <span class="math display">\[\frac{2}{3} n^3\]</span> 和 <span class="math display">\[2n^3\]</span>。这使得Cholesky分解成为求解大型正定线性系统的首选方法。</li><li><strong>稳定性</strong>：对于对称正定矩阵，Cholesky分解非常稳定。由于对称性和正定性保证了分解的成功执行，它避免了在数值分解过程中的潜在不稳定性。</li></ul></li><li><strong>数值属性</strong>：<ul><li>在数值线性代数中，Cholesky分解对于对称正定矩阵来说是一种数值上稳定的方法，特别是当矩阵<span class="math display">\[A^T A\]</span>的条件数相对较低时。这是因为它直接利用了矩阵的对称性和正定性。</li></ul></li><li><strong>简化求解过程</strong>：<ul><li>通过Cholesky分解，矩阵 <span class="math display">\[A^T A\]</span>被分解为一个下三角矩阵 <span class="math display">\[L\]</span>和其转置的上三角矩阵 <span class="math display">\[L^T\]</span>的乘积，即 <span class="math display">\[A^T A = LL^T\]</span>。这种分解简化了线性系统的求解，因为只需先解下三角系统 <span class="math display">\[L \mathbf{y} = A^T \mathbf{b}\]</span>获得临时向量 <span class="math display">\[\mathbf{y}\]</span>，然后解上三角系统 <span class="math display">\[L^T \mathbf{x} = \mathbf{y}\]</span> 获取最终解<span class="math display">\[\mathbf{x}\]</span>。</li><li>这种分步求解的过程比直接求解原方程更易于处理，并且可以有效地利用现代计算机体系结构。</li></ul></li></ol><p><strong>总结</strong></p><p>由于上述优点，Cholesky分解成为解决正定线性系统（特别是在涉及正规方程时）的理想选择，提供了一种高效、稳定的方法来求解最小二乘问题中的线性系统。这在实际应用中，如图优化、信号处理、统计数据分析等领域，具有广泛的应用。</p><h3 id="为什么要引进g_ii-i_dtimes-d">为什么要引进<span class="math inline">\(G_i^i=-I_{d\times d}\)</span></h3><p>在因子图和图优化中进行线性化处理时，引入矩阵<span class="math inline">\(G_i^i = -I_{d \timesd}\)</span>是为了便于表达和操作线性化的状态变化量。这里，$ I_{d d} $表示( d )-维的单位矩阵。矩阵 ( G_i^i ) 的作用是在数学表达式中简化状态变量 (x_i ) 的运算，从而使得该线性系统易于使用线性代数技术求解。</p><p><strong>背景</strong></p><p>在线性化的SLAM或图优化问题中，我们通常处理的是两类项：</p><ol type="1"><li><strong>过程模型项</strong>：它们涉及从一个状态 ( x_{i-1} )到下一个状态 ( x_i ) 的过渡，如机器人的运动模型。</li><li><strong>测量模型项</strong>：涉及从状态变量到测量变量的映射，如从机器人的位置到传感器观测的映射。</li></ol><p><strong>引入 $G_i^i = -I_{d d} $</strong></p><p>在方程 (6) 中，我们考虑了状态变量 ( x_i ) 和 ( x_{i-1} )之间的关系。线性化后的模型需要处理这些状态变量的增量 ( x_i ) 和 (x_{i-1} )。线性化过程后的表达式为：</p><p><span class="math display">\[f_i(x_{i-1}, u_i) - x_i \approx \{ f_i(x_{i-1}^0, u_i) + F_i^{i-1}\delta x_{i-1} \} - \{ x_i^0 + \delta x_i \}\]</span> 要将这个方程转换成标准的线性形式，我们需要确保 ( x_i ) 和 (x_{i-1} ) 在同一方程中有适当的正负号。在这里，引入 ( G_i^i = -I_{d d} )允许我们将 ( x_i ) 项简单地表示为加法形式的负增量，即：</p><p><span class="math display">\[F_i^{i-1} \delta x_{i-1} - \delta x_i = F_i^{i-1} \delta x_{i-1} + G_i^i\delta x_i\]</span> 这样，线性方程更容易处理，因为它将状态变化量 ( x_i )直接以线性代数的标准形式表示，允许使用矩阵运算直接进行计算。</p><p><strong>线性最小二乘问题</strong></p><p>通过引入 ( G_i^i = -I_{d d})，整个问题可表示为一个标准的线性最小二乘问题：</p><p><span class="math display">\[\delta^* = \underset{\delta}{\operatorname*{argmin}} \left\{\sum_{i=1}^M \| F_i^{i-1} \delta x_{i-1} + G_i^i \delta x_i + a_i\|_{\Lambda_i}^2 + \sum_{k=1}^K \| H_k^{i_k} \delta x_{i_k} + J_k^{j_k}\delta l_{j_k} - c_k \|_{\Sigma_k}^2 \right\}\]</span>这个形式使得应用线性代数和优化方法成为可能，从而可以有效求解大规模SLAM问题。</p><h3 id="因子图的即插即用">因子图的即插即用</h3><p>因子图对于处理传感器更新频率不一致问题提供了一种灵活且有效的方式，特别是在复杂的多传感器融合系统中。这主要得益于因子图在处理多源信息与维持全局状态估计方面的灵活性。</p><p>在因子图中，每个传感器的输入可以被视为一个因子，它只与图中的某些变量（例如机器人的某个位置）相关联。当新的传感器数据到来时，可以简单地将相应的新因子添加到图中，而无需重新配置整个系统。这使得因子图非常适合于处理具有不同更新频率的传感器数据。</p><p><strong>具体例子</strong></p><p>假设一个机器人装备了一个高频率的IMU（惯性测量单元）和一个低频率的GPS。IMU能够提供高频率但低精度的位置和方向更新，而GPS提供低频率但高精度的位置测量。</p><ol type="1"><li><strong>构建因子图</strong>：机器人的每个状态（位置和姿态）都是图中的一个节点。IMU和GPS的每次读数分别产生一个新的因子，这些因子与特定的状态节点相连接。</li><li><strong>IMU因子</strong>：IMU的数据频繁更新，为图中相邻的状态节点间提供动态的约束（如速度和方向）。</li><li><strong>GPS因子</strong>：GPS数据不频繁，但每当数据到来时，会在因子图中创建一个新的因子，这个因子直接将GPS测量的位置与最近的状态节点相关联。</li><li><strong>因子更新</strong>：无论何时收到新的传感器数据，都只需将对应的新因子添加到图中并重新优化，而不必修改或重处理整个图。</li></ol><p><strong>与卡尔曼滤波的比较</strong></p><p>卡尔曼滤波器（包括其扩展和无迹变体）通常需要处理所有传感器数据的固定结构和预设的处理流程。每个传感器都需要在每个时间步被处理，即使某些传感器的数据并未更新。</p><ul><li><strong>即插即用</strong>：卡尔曼滤波处理新传感器集成通常需要重新设计滤波过程和状态协方差的计算，而因子图可以更容易地通过添加新的因子来整合新传感器，无需重新设计或重新初始化整个系统。</li><li><strong>处理非同步数据</strong>：卡尔曼滤波器对于非同步传感器数据处理通常需要额外的插值或同步机制，而因子图可以更自然地通过在适当的时间点插入因子来处理这种数据。</li></ul><p>因子图的这种灵活性使其非常适合于动态环境中的实时应用，特别是当涉及多个传感器，且这些传感器可能动态变化（如增加或移除传感器）时。因子图提供了一种高效、灵活且可扩展的方法来处理这种复杂性。</p><p>卡尔曼滤波器（KF）是一种适用于线性系统（或近似线性）的递推滤波方法，它依赖于数据输入的同步和连续性。在实际应用中，如自动驾驶车辆、机器人导航或多传感器融合系统中，传感器可能无法以同一频率或同步的方式产生数据。这会给基于卡尔曼滤波的系统设计带来挑战。</p><p><strong>卡尔曼滤波器和非同步数据处理</strong></p><p>当使用卡尔曼滤波器处理来自不同传感器的数据时，若这些传感器的更新频率不一致或数据非同步接收，可能需要进行额外处理以保证数据的时序一致性。这主要是因为卡尔曼滤波器在每个时间步更新状态估计时都假定接收到的数据是当前时刻的准确反映。</p><p><strong>举例说明</strong></p><p>假设有一个移动机器人使用两种传感器：一个激光雷达（LIDAR）和一个轮速计。激光雷达每100毫秒更新一次位置信息，而轮速计每30毫秒更新一次速度信息。如果直接将这些数据输入到一个卡尔曼滤波器，可能会出现问题，因为两种数据的时间戳不匹配。</p><p>为了同步这些传感器数据，一个常见的方法是使用插值：</p><ul><li><strong>插值</strong>：例如，可以使用线性插值或更复杂的插值方法（如样条插值）来估计激光雷达测量间隙中的位置数据，或者在轮速计测量间隙中估计速度，以便在非测量时刻提供数据估计。</li><li><strong>数据缓冲</strong>：另一种方法是对快速更新的传感器（轮速计）数据进行缓冲，直到慢速传感器（激光雷达）的下一次数据到来，然后一起处理这些数据。</li></ul><p>卡尔曼滤波器（KF）处理的核心在于它按照严格的时序顺序处理观测数据来更新状态估计。这个处理过程基于两个关键假设：系统的动态是已知的，并且观测数据是同步到特定的时间点的。当观测数据来自频率不同或非同步的多个传感器时，这些假设可能不再成立，直接接受数据而不进行任何处理可能会导致以下问题：</p><p><strong>1. 误差累积</strong></p><p>卡尔曼滤波器在每个时间步更新其状态估计时，假设最新的观测数据反映了当前的系统状态。如果直接使用非同步的观测数据，滤波器可能无法准确地关联观测数据与其对应的状态，从而导致误差累积。例如，如果一个传感器的数据延迟或提前了，而滤波器误以为这些数据是最新的，那么更新的状态估计可能会基于错误的信息。</p><p>卡尔曼滤波器（KF）处理的核心在于它按照严格的时序顺序处理观测数据来更新状态估计。这个处理过程基于两个关键假设：系统的动态是已知的，并且观测数据是同步到特定的时间点的。当观测数据来自频率不同或非同步的多个传感器时，这些假设可能不再成立，直接接受数据而不进行任何处理可能会导致以下问题：</p><p><strong>1. 误差累积</strong></p><p>卡尔曼滤波器在每个时间步更新其状态估计时，假设最新的观测数据反映了当前的系统状态。如果直接使用非同步的观测数据，滤波器可能无法准确地关联观测数据与其对应的状态，从而导致误差累积。例如，如果一个传感器的数据延迟或提前了，而滤波器误以为这些数据是最新的，那么更新的状态估计可能会基于错误的信息。</p><p><strong>2. 时间戳不匹配</strong></p><p>在处理来自不同传感器的数据时，每个传感器的输出通常带有时间戳。如果这些时间戳不一致，直接接受数据意味着滤波器可能会在错误的时间点应用观测数据，导致状态更新不准确。这对于那些高度依赖精确时间信息的应用（如导航和跟踪系统）尤为重要。</p><p><strong>3. 数据丢失或重叠</strong></p><p>非同步数据可能导致数据在时间轴上出现重叠或缺口。例如，一个传感器可能在另一个传感器的两次读数之间多次更新，或者在长时间内没有更新。这种情况下，直接处理可能导致某些观测数据被忽略或重复计算，影响滤波器的性能。</p><p><strong>解决方法：插值和数据缓冲</strong></p><p>为了解决这些问题，卡尔曼滤波器通常采用以下策略：</p><ul><li><p><strong>插值</strong>：通过插值方法（如线性插值、样条插值等）创建虚拟的观测数据，填补时间上的缺口，使得每个时间步都有相应的数据输入。这有助于保持滤波器的连续性和准确性。</p></li><li><p><strong>数据缓冲</strong>：将来自不同传感器的数据存储在缓冲区中，直到收集到所有相关传感器的数据为止。然后，根据这些数据的时间戳一起处理它们。这样可以保证数据在时间上的一致性，减少由于时间错配引起的误差。</p></li></ul><p>这两种方法使得卡尔曼滤波器能够更加稳定和准确地处理来自多源的非同步数据，从而提高系统的整体性能。</p><p>在处理来自不同传感器的数据时，每个传感器的输出通常带有时间戳。如果这些时间戳不一致，直接接受数据意味着滤波器可能会在错误的时间点应用观测数据，导致状态更新不准确。这对于那些高度依赖精确时间信息的应用（如导航和跟踪系统）尤为重要。</p><p><strong>3. 数据丢失或重叠</strong></p><p>非同步数据可能导致数据在时间轴上出现重叠或缺口。例如，一个传感器可能在另一个传感器的两次读数之间多次更新，或者在长时间内没有更新。这种情况下，直接处理可能导致某些观测数据被忽略或重复计算，影响滤波器的性能。</p><p><strong>解决方法：插值和数据缓冲</strong></p><p>为了解决这些问题，卡尔曼滤波器通常采用以下策略：</p><ul><li><p><strong>插值</strong>：通过插值方法（如线性插值、样条插值等）创建虚拟的观测数据，填补时间上的缺口，使得每个时间步都有相应的数据输入。这有助于保持滤波器的连续性和准确性。</p></li><li><p><strong>数据缓冲</strong>：将来自不同传感器的数据存储在缓冲区中，直到收集到所有相关传感器的数据为止。然后，根据这些数据的时间戳一起处理它们。这样可以保证数据在时间上的一致性，减少由于时间错配引起的误差。</p></li></ul><p>这两种方法使得卡尔曼滤波器能够更加稳定和准确地处理来自多源的非同步数据，从而提高系统的整体性能。</p><p><strong>因子图的优势</strong></p><p>相比之下，因子图提供了一个更灵活的框架来处理非同步数据。因子图是一种图形模型，它以图的形式表示变量之间的条件依赖关系。在因子图中，每个传感器的读数可以作为一个因子被添加到图中，这些因子与它们影响的状态变量相关联。如果传感器数据是非同步的，可以：</p><ul><li><strong>动态添加因子</strong>：根据每个传感器的时间戳动态地向图中添加新的因子。这意味着每个传感器更新只影响相关的状态变量，不需要人为地同步所有数据。</li><li><strong>时间标记</strong>：每个因子可以携带时间信息，因此状态更新可以在正确的时间点进行，与数据实际测量的时间相匹配。</li></ul><p>因此，因子图模型通过在合适的时间点添加因子来自然地处理非同步的传感器数据，从而避免了在卡尔曼滤波器中必须进行的数据插值或同步。这样不仅简化了处理过程，而且可能提高了系统的整体性能和精度。</p><h3 id="因子图优化更新节点状态"><strong>因子图优化更新节点状态</strong></h3><ul><li><strong>应用方式</strong>：图优化通常处理的是整个数据集（如历史路径或多个观测数据点），并且通常适用于离线或批处理模式，适用于大规模空间问题，如SLAM。而EKF通常在线性化当前或最近的状态来进行实时更新，适用于需要快速反应的动态系统，如实时机器人导航。</li><li><strong>数据处理方式</strong>：EKF以递归方式连续更新状态，侧重于实时估计；图优化则可能在获得新数据后对整个历史数据进行重新优化，侧重于精度和全局一致性。</li></ul><p>让我们逐一探讨这两个问题：</p><p><strong>1. 根据导数信息计算状态更新量的例子</strong></p><p>考虑一个简单的SLAM问题，其中机器人需要确定它的位置 ( x )和地图上一个地标的位置 ( l )。假设有一个观测 ( z )与机器人的位置和地标之间的距离相关。</p><p><strong>步骤</strong></p><ul><li><p><strong>误差函数</strong>：设 ( h(x, l) ) 是从机器人位置 ( x )到地标 ( l ) 的预测测量，误差函数 ( e ) 可表示为 ( e = z - h(x, l))。</p></li><li><p><strong>雅可比矩阵</strong>：计算误差 ( e ) 关于状态 ( x )和地标位置 ( l ) 的雅可比矩阵 ( J_x ) 和 ( J_l )。</p></li><li><p><strong>更新公式</strong>：使用高斯牛顿法，更新公式可以写作：</p><p><span class="math display">\[\begin{pmatrix} \Delta x \\ \Delta l \end{pmatrix} = -(J^T J + \lambdaI)^{-1} J^T e\]</span></p><p>其中 ( J ) 是组合了 ( J_x ) 和 ( J_l ) 的雅可比矩阵，( )是为了提高数值稳定性而添加的阻尼因子（Levenberg-Marquardt算法中使用），(I ) 是单位矩阵。</p></li><li><p><strong>状态更新</strong>：计算得到的 ( x ) 和 ( l )用来更新当前状态和地标位置。</p></li></ul><p><strong>2. 增量式图优化方法的实际操作</strong></p><p>在实时系统如自动驾驶车辆中，增量图优化主要关注最近的观测和状态，以减少每次更新所需的计算资源。</p><p><strong>步骤</strong></p><ul><li><strong>局部图更新</strong>：每当接收到新的观测数据时，只更新与这些新数据直接相关的节点和边，这些通常是最近的机器人状态和相关地标。</li><li><strong>窗口优化</strong>：一种常见的策略是固定滑动窗口方法，即仅在固定大小的最近状态窗口内进行优化。较旧的状态和地标，一旦它们超出窗口，可以被边缘化（从优化问题中移除但考虑其对现有状态的统计影响）或锁定。</li><li><strong>增量求解器</strong>：使用专门设计的增量求解器，如 iSAM 或g2o，这些工具能够有效地更新信息矩阵和求解增量更新问题。</li><li><strong>实时反馈</strong>：通过快速更新仅涉及局部改动的解决方案，系统能够快速地对新数据做出响应。</li></ul><p>这种增量更新方法能够显著降低因每个新观测而进行全局优化的计算成本，使系统更适合实时应用场景，如自动驾驶或动态环境中的机器人导航。</p><h3 id="如何根据联合概率密度分布-求解">如何根据联合概率密度分布求解</h3><p>在解决导航和地图构建的问题中，目标通常是找到一组变量（机器人的位置和地图配置）的配置，<strong>这些配置最能解释观测数据和已知信息。</strong>这里的“解释”通常是指在给定模型下，找到最大化联合概率<span class="math inline">\(P(X, L, Z)\)</span> 的 (X)（位置）和(L)（地图）的配置。这种方法是基于最大似然估计或最大后验估计的原理。</p><p><strong>最大似然估计和最大后验估计</strong></p><ul><li><p><strong>最大似然估计（MLE）</strong>:在这种情况下，我们寻找的是最大化观测数据 (Z) 出现概率的位置 (X) 和地图(L) 配置，不考虑位置和地图的先验概率。数学上表达为 <span class="math inline">\(\arg\max_{X, L} P(Z|X, L)\)</span>。</p></li><li><p><strong>最大后验估计（MAP）</strong>:更常见的是，我们寻找能够最大化后验概率<span class="math inline">\(P(X, L| Z)\)</span>的 (X) 和 (L)。由于根据贝叶斯公式，<span class="math inline">\(P(X, L | Z) \propto P(Z | X, L) P(X,L)\)</span>，这不仅考虑了观测数据的似然度，还包括了关于位置和地图的先验知识。</p></li></ul><p><strong>计算过程</strong></p><ol type="1"><li><strong>定义概率模型</strong>:<ul><li>状态转移概率 <span class="math inline">\(P(x_i | x_{i-1},u_i)\)</span>描述了给定前一状态和控制输入后，当前状态的概率。</li><li>观测模型 <span class="math inline">\(P(z_k | x_{i_k},l_{j_k})\)</span>描述了给定当前状态和地图配置时，观测数据出现的概率。</li><li>先验<span class="math inline">\(P(X,L)\)</span>可能基于以前的知识或假设（如位置的均匀分布，或地图的某些特征）。</li></ul></li><li><strong>优化过程</strong>:<ul><li>在实践中，最大化<span class="math inline">\(P(X, L | Z)\)</span>通常涉及到优化算法，如梯度上升、期望最大化（EM）算法或其他非线性优化技术。</li><li>在机器人技术中，常见的优化工具包括粒子滤波（用于非线性/非高斯问题）和卡尔曼滤波（用于线性/高斯问题）。</li></ul></li><li><strong>联合概率和解释</strong>:<ul><li>我们不是寻找最小的联合概率，而是寻找最大化后验概率的 (X, L)配置，因为后验概率高意味着给定观测数据和先验知识下，该配置更可能是正确的。</li></ul></li></ol><p><strong>结论</strong></p><p>通过最大化后验概率<span class="math inline">\(P(X, L |Z)\)</span>，我们找到一组 (X) 和 (L)，使得在已有的观测 (Z)和可能的先验知识下，这组配置是最有可能的。这就是如何使用联合概率模型来优化并解释机器人的导航和地图构建问题。这种方法使得可以在不确定的环境中做出最好的估计和决策。</p><h3 id="为什么用联合概率密度来描述导航问题">为什么用联合概率密度来描述导航问题</h3><p>在导航和其他机器人感知系统中，状态估计问题经常涉及位置（X），地图（L）和观测数据（Z）的不确定性。利用联合概率密度函数来表示这些变量，可以系统地包含所有相关的不确定性和依赖关系，从而使得可以进行精确的推断和决策。以下是详细解释为什么采用这种表示方法：</p><p>在导航问题中：</p><ul><li><strong>X</strong>表示机器人的位置状态序列，即在不同时间点的位置状态。</li><li><strong>L</strong> 表示环境的地图，包括可能的地标或其他特征。</li><li><strong>Z</strong>表示机器人的观测数据序列，即机器人通过其传感器相对于环境特征的观测。</li></ul><p><strong>概率模型表示</strong></p><ol type="1"><li><p><strong>初始状态的概率</strong>(P(x_0))：这是机器人在开始导航前的位置状态的初始概率分布。这通常是基于先验知识或初始观测所给定的。</p></li><li><p><strong>状态转移概率</strong> (<em>{i=1}^M P(x_i|x</em>{i-1},u_i))：这一部分表示机器人位置的演化，其中每个状态 (x_i) 取决于前一个状态(x_{i-1}) 和执行的控制指令(u_i)。状态转移概率捕捉了系统动态和可能的过程噪声。</p></li><li><p><strong>观测模型</strong> (<em>{k=1}^K P(z_k|x</em>{i_k},l_{j_k}))：每个观测 (z_k) 都依赖于特定时刻 (i_k) 的位置 (x_{i_k})和相关联的地图特征(l_{j_k})。观测模型描述了如何根据机器人的当前位置和周围环境的地标特征产生观测数据，包括观测噪声。</p></li></ol><p><strong>联合概率密度函数的优势</strong></p><p>使用联合概率密度函数 (P(X, L, Z)) 的优势在于：</p><ul><li><strong>全面性</strong>：通过整合所有可能的不确定性来源（控制输入的不确定性、位置的不确定性和观测的不确定性），这种方法提供了一个全面的系统描述。</li><li><strong>条件依赖性的显式表达</strong>：明确表达了各状态和观测之间的条件依赖关系，这对于理解和实现滤波器和估计算法至关重要。</li><li><strong>灵活性</strong>：这种表示允许使用各种概率推断技术，如卡尔曼滤波、粒子滤波或图优化，来估计位置和地图。</li><li><strong>信息整合</strong>：可以有效地整合多时刻和多来源的信息，优化状态估计和地图构建。</li></ul><p>总之，联合概率密度函数通过对所有变量的依赖关系进行建模，为解决导航中的状态估计问题提供了一个强大的数学框架，使得可以利用概率方法处理不确定性和推导最优解。这种方法是解决SLAM问题的基石，也是现代自动驾驶和机器人导航系统中不可或缺的一部分。</p><p>再尝试用一个更简单和直观的方式来理解为什么在导航中的状态估计问题可以通过一个联合概率密度函数来表示。我们可以通过具体的例子和逐步解析来帮助理解。</p><p><strong>一个具体的例子</strong></p><p>假设我们有一个机器人在一个未知的环境中导航。机器人的任务是理解自己的位置（状态X），探索并绘制周围的地图（L），同时根据自己的传感器收集信息（观测Z）。</p><ol type="1"><li><strong>初始状态 (P(x_0))</strong>:<ul><li>在一开始，我们只知道机器人可能在一个初始位置，比如我们可以假设它以某个概率分布（如高斯分布）位于起点附近。</li></ul></li><li><strong>状态转移 (P(x_i|x_{i-1}, u_i))</strong>:<ul><li>每次机器人移动，它的新位置 (x_i) 将基于前一个位置 (x_{i-1})和其执行的移动指令(u_i)（比如向前移动一米）。这个过程不是完全准确的，因此我们使用概率模型（如另一个高斯分布）来表示可能的新位置。</li></ul></li><li><strong>观测模型 (P(z_k|x_{i_k}, l_{j_k}))</strong>:<ul><li>同时，机器人会使用传感器（如摄像头或激光雷达）观测周围环境。这些观测(z_k) 取决于机器人的当前位置 (x_{i_k}) 和它所观测到的环境特征(l_{j_k})（比如附近的一个门或窗户）。观测也不是完全精确的，同样用概率模型来描述。</li></ul></li></ol><p><strong>为什么使用联合概率密度函数</strong></p><p>当我们想要同时考虑所有这些因素来估计机器人的最可能的位置、绘制地图和解释观测数据时，我们可以构造一个联合概率模型(P(X, L, Z))：</p><ul><li><strong>综合所有信息</strong>：这个联合模型把所有关于机器人位置的不确定性、地图的不确定性和观测数据的不确定性都整合在一起。我们通过计算这个联合概率来寻找最有可能解释所有观测数据和已知信息的位置和地图配置。</li><li><strong>条件依赖关系</strong>：这个模型同时还能清晰地表达各种条件依赖关系，例如观测依赖于位置和地图的某些特定特征，位置的更新依赖于先前的位置和移动指令。</li><li><strong>灵活的推断和优化</strong>：有了这个联合模型，我们可以利用不同的数学工具和算法（如贝叶斯滤波器、粒子滤波、最大似然估计等）来推断未知的状态和地图。</li></ul><p>总结来说，这个联合概率密度函数提供了一种全面并且系统的方法来考虑和处理导航问题中的所有不确定性和依赖性。这种方法使得可以更有效地进行状态估计和环境映射，帮助机器人更好地理解和操作在其所处的环境中。</p><h3 id="因子图通过将测量值作为已知的参数而不是变量来简化问题表示">因子图通过将测量值作为已知的参数而不是变量来简化问题表示？</h3><p>因子图通过将测量值作为已知的参数而不是变量来简化问题表示，使得模型更直接地关联到优化问题本身，这对于高效解决SLAM等复杂问题至关重要。这段话怎么理解？通过将测量值作为已知的参数而不是变量来简化问题表示？</p><p>这段话指出因子图在处理如SLAM这样的问题时的一个关键特性：将测量数据视为已知参数，而不是作为需要求解的变量。这种处理方式在建模和求解复杂系统时有几个重要的好处：</p><p><strong>简化问题表示</strong></p><ol type="1"><li><p><strong>明确角色分配</strong>：在SLAM等问题中，我们的主要目标是推断或优化未知的状态变量（如机器人的位置、地图的特征点等），而测量数据（如来自传感器的读数）是用来帮助确定这些未知变量的。将测量值视为已知参数，意味着这些数据在模型中的角色是辅助性的，它们用于构建关于未知变量的条件概率表达，而不是自身需要被解决的问题。</p></li><li><p><strong>减少求解复杂度</strong>：如果将测量值也视为变量，那么问题的复杂度会显著增加，因为这样不仅需要推断未知的状态变量，还要同时解决这些测量值的准确性和可靠性问题。将测量值作为参数，可以直接使用这些数据来形成对未知变量的概率描述，从而简化了模型和计算。</p></li></ol><p><strong>直接关联到优化问题本身</strong></p><ol type="1"><li><p><strong>更加聚焦核心任务</strong>：在SLAM等应用中，核心任务是基于测量数据推断或更新未知的状态变量。将测量数据视为参数，可以使模型更加集中于如何利用这些数据来改善对未知变量的估计，而非分散注意力于处理测量数据本身的不确定性。</p></li><li><p><strong>提高算法效率</strong>：当模型聚焦于核心变量时，优化算法可以更有效地调整和优化这些变量的值以达到最佳估计。这通常会导致更快的计算速度和更好的优化性能，因为算法可以直接利用固定的、已知的测量数据来逐步改进状态估计。</p></li></ol><p>总之，将测量值作为已知参数处理，有助于因子图更加高效和直接地应对复杂的优化问题，如SLAM，这样做能够减轻计算负担，同时提高问题求解的准确性和效率。这种方法使得模型设计和算法实现都更加直接和实用，特别是在实时或资源受限的应用场景中。</p></j}\psi_{ij}(\theta_i,\theta_j)>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 因子图理论 </tag>
            
            <tag> SAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>因子图优化相关问题</title>
      <link href="/2024/05/04/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/04/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="因子图优化相关问题">因子图优化相关问题</h1><blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>这篇blog主要是记录毕设一些因子图相关的问题不太好手动理解的点 主要途径就是通过看论文 还有gpt搜集到的一些理解的东西记录一下</p></blockquote><h2 id="为什么用联合概率密度来描述导航问题">为什么用联合概率密度来描述导航问题</h2><h3 id="解释1">解释1</h3><p>在导航和其他机器人感知系统中，状态估计问题经常涉及位置X，地图L和观测数据Z的不确定性。<strong>利用联合概率密度函数来表示这些变量，可以系统地包含所有相关的不确定性和依赖关系，从而使得可以进行精确的推断和决策。</strong>以下是详细解释为什么采用这种表示方法：</p><p>在导航问题中：</p><ul><li><strong>X</strong>表示机器人的位置状态序列，即在不同时间点的位置状态。</li><li><strong>L</strong> 表示环境的地图，包括可能的地标或其他特征。</li><li><strong>Z</strong>表示机器人的观测数据序列，即机器人通过其传感器相对于环境特征的观测。</li></ul><p><strong>概率模型表示</strong></p><ol type="1"><li><strong>初始状态的概率</strong> <span class="math inline">\(P(x_0)\)</span>：这是机器人在开始导航前的位置状态的初始概率分布。这通常是基于先验知识或初始观测所给定的。</li><li><strong>状态转移概率</strong> <span class="math inline">\(\prod_{i=1}^M P(x_i|x_{i-1}, u_i)\)</span>：这一部分表示机器人位置的演化，其中每个状态 <span class="math inline">\(x_i\)</span> 取决于前一个状态 <span class="math inline">\(x_{i-1}\)</span> 和执行的控制指令 <span class="math inline">\(u_i\)</span>。<strong>状态转移概率捕捉了系统动态和可能的过程噪声</strong>。</li><li><strong>观测模型</strong> <span class="math inline">\(\prod_{k=1}^KP(z_k|x_{i_k}, l_{j_k})\)</span>：每个观测 <span class="math inline">\(z_k\)</span> 都依赖于特定时刻 <span class="math inline">\(i_k\)</span>的位置 $x_{i_k} $ 和相关联的地图特征<span class="math inline">\(l_{j_k}\)</span>。<strong>观测模型描述了如何根据机器人的当前位置和周围环境的地标特征产生观测数据，包括观测噪声。</strong></li></ol><p><strong>联合概率密度函数的优势</strong></p><p>使用联合概率密度函数 $P(X, L, Z) $ 的优势在于：</p><ul><li><strong>全面性</strong>：通过整合所有可能的不确定性来源（控制输入的不确定性、位置的不确定性和观测的不确定性），这种方法提供了一个全面的系统描述。</li><li><strong>条件依赖性的显式表达</strong>：明确表达了各状态和观测之间的条件依赖关系，这对于理解和实现滤波器和估计算法至关重要。</li><li><strong>灵活性</strong>：这种表示允许使用各种概率推断技术，如卡尔曼滤波、粒子滤波或图优化，来估计位置和地图。</li><li><strong>信息整合</strong>：可以有效地整合多时刻和多来源的信息，优化状态估计和地图构建。</li></ul><p>总之，联合概率密度函数通过对所有变量的依赖关系进行建模，为解决导航中的状态估计问题提供了一个强大的数学框架，使得可以利用概率方法处理不确定性和推导最优解。这种方法是解决SLAM问题的基石，也是现代自动驾驶和机器人导航系统中不可或缺的一部分。</p><p><strong>一个具体的例子</strong></p><p>再尝试用一个更简单和直观的方式来理解为什么在导航中的状态估计问题可以通过一个联合概率密度函数来表示。我们可以通过具体的例子和逐步解析来帮助理解。</p><p>假设我们有一个机器人在一个未知的环境中导航。机器人的任务是理解自己的位置（状态X），探索并绘制周围的地图（L），同时根据自己的传感器收集信息（观测Z）。</p><ol type="1"><li><strong>初始状态<span class="math inline">\(P(x_0)\)</span></strong>:<ul><li>在一开始，我们只知道机器人可能在一个初始位置，比如我们可以假设它以某个概率分布（如高斯分布）位于起点附近。</li></ul></li><li><strong>状态转移<span class="math inline">\(P(x_i|x_{i-1},u_i)\)</span></strong>:<ul><li>每次机器人移动，它的新位置<span class="math inline">\(x_i\)</span>将基于前一个位置 <span class="math inline">\(x_{i-1}\)</span>和其执行的移动指令<span class="math inline">\(u_i\)</span>（比如向前移动一米）。这个过程不是完全准确的，因此我们使用概率模型（如另一个高斯分布）来表示可能的新位置。</li></ul></li><li><strong>观测模型 <span class="math inline">\(P(z_k|x_{i_k},l_{j_k})\)</span></strong>:<ul><li>同时，机器人会使用传感器（如摄像头或激光雷达）观测周围环境。这些观测<span class="math inline">\(z_k\)</span>取决于机器人的当前位置 <span class="math inline">\(x\)</span>和它所观测到的环境特征<span class="math inline">\(l_{j_k}\)</span>（比如附近的一个门或窗户）。观测也不是完全精确的，同样用概率模型来描述。</li></ul></li></ol><h3 id="解释2"><strong>解释2</strong></h3><p>当我们想要同时考虑所有这些因素来估计机器人的最可能的位置、绘制地图和解释观测数据时，我们可以构造一个联合概率模型<span class="math inline">\(P(X, L, Z)\)</span>：</p><ul><li><strong>综合所有信息</strong>：这个<strong>联合模型把所有关于机器人位置的不确定性、地图的不确定性和观测数据的不确定性都整合在一起</strong>。我们通过<strong>计算这个联合概率来寻找最有可能解释所有观测数据和已知信息的位置和地图配置</strong>。</li><li><strong>条件依赖关系</strong>：这个模型同时还能清晰地表达各种条件依赖关系，例如观测依赖于位置和地图的某些特定特征，位置的更新依赖于先前的位置和移动指令。</li><li><strong>灵活的推断和优化</strong>：有了这个联合模型，我们可以利用不同的数学工具和算法（如贝叶斯滤波器、粒子滤波、最大似然估计等）来推断未知的状态和地图。</li></ul><p>总结来说，这个<strong>联合概率密度函数提供了一种全面并且系统的方法来考虑和处理导航问题中的所有不确定性和依赖性</strong>。这种方法使得可以更有效地进行状态估计和环境映射，帮助机器人更好地理解和操作在其所处的环境中。</p><h2 id="如何根据联合概率密度分布-求解">如何根据联合概率密度分布求解</h2><p>在解决导航和地图构建的问题中，目标通常是找到一组变量（机器人的位置和地图配置）的配置，<strong>这些配置最能解释观测数据和已知信息。</strong>这里的“解释”通常是指在给定模型下，找到最大化联合概率<span class="math inline">\(P(X, L, Z)\)</span> 的 <span class="math inline">\(X\)</span>（位置）和<span class="math inline">\(L\)</span>（地图）的配置。这种方法是基于最大似然估计或最大后验估计的原理。</p><p><strong>最大似然估计和最大后验估计</strong></p><ul><li><p><strong>最大似然估计（MLE）</strong>:在这种情况下，我们寻找的是最大化观测数据 (Z) 出现概率的位置<span class="math inline">\(X\)</span> 和地图<span class="math inline">\(L\)</span>配置，不考虑位置和地图的先验概率。数学上表达为 <span class="math inline">\(\arg\max_{X, L} P(Z|X, L)\)</span>。</p></li><li><p><strong>最大后验估计（MAP）</strong>:更常见的是，我们寻找能够最大化后验概率<span class="math inline">\(P(X, L| Z)\)</span>的 <span class="math inline">\(X\)</span> 和<span class="math inline">\(L\)</span>。由于根据贝叶斯公式，<span class="math inline">\(P(X, L | Z) \propto P(Z | X, L) P(X,L)\)</span>，这不仅考虑了观测数据的似然度，还包括了关于位置和地图的先验知识。</p></li></ul><p><strong>计算过程</strong></p><ol type="1"><li><strong>定义概率模型</strong>:<ul><li>状态转移概率 <span class="math inline">\(P(x_i | x_{i-1},u_i)\)</span>描述了给定前一状态和控制输入后，当前状态的概率。</li><li>观测模型 <span class="math inline">\(P(z_k | x_{i_k},l_{j_k})\)</span>描述了给定当前状态和地图配置时，观测数据出现的概率。</li><li>先验<span class="math inline">\(P(X,L)\)</span>可能基于以前的知识或假设（如位置的均匀分布，或地图的某些特征）。</li></ul></li><li><strong>优化过程</strong>:<ul><li>在实践中，最大化<span class="math inline">\(P(X, L | Z)\)</span>通常涉及到优化算法，如梯度上升、期望最大化（EM）算法或其他非线性优化技术。</li><li>在机器人技术中，常见的优化工具包括粒子滤波（用于非线性/非高斯问题）和卡尔曼滤波（用于线性/高斯问题）。</li></ul></li><li><strong>联合概率和解释</strong>:<ul><li>我们不是寻找最小的联合概率，而是寻找最大化后验概率的 <span class="math inline">\(X,L\)</span>配置，因为后验概率高意味着给定观测数据和先验知识下，该配置更可能是正确的。</li></ul></li></ol><p>通过最大化后验概率<span class="math inline">\(P(X, L |Z)\)</span>，我<strong>们找到一组X和L，使得在已有的观测Z和可能的先验知识下，这组配置是最有可能的</strong>。这就是<strong>如何使用联合概率模型来优化并解释机器人的导航和地图构建问题</strong>。这种方法使得可以在不确定的环境中做出最好的估计和决策。</p><h2 id="关于概率推导">关于概率推导</h2><p>导航定位系统状态量的最大后验估计问题可以转换为在已知系统观测信息的前提下，求解最大化系统的状态信息的概率密度。如式所示: <span class="math display">\[X^{MAP}=\arg\max_Xp(X_m\mid Z_j)=\arg\max_X\frac{p(Z_j\midX_m)p(X_m)}{p(Z_j)}\]</span> 由于观测的数据<span class="math inline">\(Z_j\)</span>是已知的，且与待估计的状态是独立的，于是有：​<span class="math display">\[p(X_m\mid Z_j)\propto p(Z_j\mid X_m)p(X_m)\\X^{MAP}=\arg\max_Xp(Z_j\midX_m)p(X_m)\]</span></p><h3 id="在给定系统状态的情况下每个观测数据是独立的-为什么观测模型还依赖于系统状态">在给定系统状态的情况下，每个观测数据是独立的。为什么观测模型还依赖于系统状态？</h3><h4 id="解释1-1">解释1</h4><p>在给定系统状态的情况下，每个观测数据是独立的，这意味着每个观测数据<span class="math inline">\(z_k\)</span>的生成不受其他观测数据的影响。但是，观测数据和系统状态之间仍然可能存在依赖关系，这种依赖关系通常由观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>来描述。</p><p>观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>表示系统状态<span class="math inline">\(x_{i_k}\)</span>到观测数据<span class="math inline">\(z_k\)</span>之间的映射关系。即使在给定系统状态的情况下，不同的系统状态可能会导致不同的观测数据。这种依赖关系可以是物理上的，也可以是统计上的。例如，在一个移动机器人的定位问题中，机器人的位置状态会影响传感器测量值的期望值，即观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>。即使在给定机器人位置的情况下，由于传感器的测量误差，不同的位置状态也会导致不同的观测数据。</p><p>因此，虽然在给定系统状态的情况下，每个观测数据是独立的，但观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>仍然依赖于系统状态，因为观测数据的生成过程与系统状态之间可能存在依赖关系。</p><h4 id="解释2-1">解释2</h4><p>在给定观测数据<span class="math inline">\(z\)</span>的情况下，观测模型的确不应该直接依赖于系统状态<span class="math inline">\(x\)</span>，因为观测数据<span class="math inline">\(z\)</span>已经被视为已知值，与系统状态无关。</p><p>在导航定位系统中，观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>通常描述了系统状态<span class="math inline">\(x_{i_k}\)</span>到观测数据<span class="math inline">\(z_k\)</span>之间的映射关系。这个映射关系可以是物理上的，例如，通过测量信号强度来估计距离，或者是统计上的，例如，通过回归模型来预测观测数据的期望值。</p><p>然而，当我们使用高斯分布来表示观测数据<span class="math inline">\(z_k\)</span>在给定状态<span class="math inline">\(x_{i_k}\)</span>下的条件概率时，我们需要考虑观测模型和观测噪声。这里的高斯分布是一个常用的假设，用于表示观测数据的不确定性，其中噪声项<span class="math inline">\(\nu_k\)</span>通常被假设为零均值的高斯分布。</p><p>因此，虽然在给定观测数据<span class="math inline">\(z\)</span>的情况下，观测模型不应该直接依赖于系统状态<span class="math inline">\(x\)</span>，但在贝叶斯推断中，我们可能仍然需要考虑观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>的形式，以便通过高斯分布来表示观测数据的条件概率分布。然而，需要注意的是，高斯分布中的参数应该是与系统状态无关的，因为在给定观测数据的情况下，观测模型不应该依赖于系统状态。</p><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>具体的例子</p><p>当处理导航定位系统时，一个常见的观测是通过GPS接收器收集到的位置数据。在这种情况下，我们可以将观测模型视为将系统状态（例如，实际位置）映射到观测数据（例如，GPS接收器报告的位置）的函数。</p><p>假设我们想要估计一个移动机器人的位置。机器人当前的真实位置是系统的状态，我们用<span class="math inline">\(x_i\)</span>表示。而机器人所收集到的GPS数据就是观测数据，用<span class="math inline">\(z_i\)</span>表示。GPS数据可能会受到多种因素的影响，例如大气干扰、多径效应等，因此我们会有一个观测噪声的模型。</p><p>假设我们的观测模型是一个简单的线性模型，即：</p><p><span class="math display">\[z_i = x_i + \nu_i\]</span></p><p>其中，<span class="math inline">\(\nu_i\)</span>是观测噪声，表示GPS测量的误差。</p><p>在这个例子中，观测模型<span class="math inline">\(h(x_i)\)</span>是直接将系统状态<span class="math inline">\(x_i\)</span>映射到观测数据<span class="math inline">\(z_i\)</span>上，这是一个物理上的映射关系。但是，为了考虑观测噪声的影响，我们可能会假设<span class="math inline">\(\nu_i\)</span>是一个零均值的高斯随机变量。</p><p>因此，我们可以使用高斯分布来描述观测数据<span class="math inline">\(z_i\)</span>在给定状态<span class="math inline">\(x_i\)</span>下的条件概率分布，即：</p><p><span class="math display">\[p(z_i \mid x_i) \propto \exp \left(-\frac{1}{2\sigma^2} \|z_i - x_i\|^2 \right)\]</span></p><p>其中，<span class="math inline">\(\sigma^2\)</span>是观测噪声的方差，<span class="math inline">\(\|.\|\)</span>表示向量的范数。</p><p>需要注意的是，在这个例子中，虽然我们使用了一个与系统状态<span class="math inline">\(x_i\)</span>相关的观测模型<span class="math inline">\(h(x_i)\)</span>，但是在贝叶斯推断中，我们最终要估计的是系统状态<span class="math inline">\(x_i\)</span>的后验分布<span class="math inline">\(p(x_i \mid z_i)\)</span>，而不是观测模型<span class="math inline">\(h(x_i)\)</span>本身。因此，我们仍然可以利用贝叶斯定理来计算后验分布，如前面提到的那样。</p><h2 id="关于残差">关于残差</h2><p>残差不仅仅反映了异常值的存在，它还反映了模型预测值与实际观测值之间的差异，包括了模型未能完全解释的部分以及数据中的随机噪声。</p><p>在统计学和机器学习中，<strong>残差通常被定义为观测值与模型的预测值之间的差异</strong>。如果我们的模型能够很好地拟合数据，那么残差应该是很小的。然而，<strong>当数据中存在异常值或者模型不够准确时，残差可能会变得较大，因为观测值与模型的预测值之间的差异会增大。</strong></p><p>因此，残差不仅反映了异常值的存在，还反映了其他因素导致的预测误差。但是，由于异常值往往会导致较大的残差，因此在一定程度上残差可以用来间接地检测异常值的存在。</p><p>当我们使用鲁棒核函数时，对于较大的残差会施加较小的权重，使得异常值的影响降低，从而更有可能得到更好的优化结果。因此，虽然残差不仅仅反映了异常值的存在，但异常值对于残差的贡献往往是较大的，因此对异常值施加较小的权重可以减小它们对优化过程的影响。</p><h2 id="关于鲁棒核函数">关于鲁棒核函数</h2><p>对于常规的最小二乘法，异常值的存在会对优化结果产生较大的影响，因为它们对残差的贡献很大，导致最小二乘法过度拟合这些异常值。这<strong>是因为最小二乘法对所有的残差都施加相同的惩罚，而对于异常值来说，它们的残差通常会比较大。</strong></p><p>相比之下，鲁棒核函数（如Huber损失函数）会在残差较小的时候施加较小的惩罚，而在残差较大的时候施加较大的惩罚。这使得鲁棒核函数能够更好地适应数据中的异常值，并且对异常值的影响较小。因此，当使用鲁棒核函数进行优化时，异常值不会对优化过程产生过大的影响，从而使得优化结果更加稳健。</p><p>总的来说，使用鲁棒核函数能够减少异常值对优化过程的影响，使得优化结果更具有鲁棒性，更能反映数据的真实情况。</p><h3 id="为什么残差可以体现异常值">为什么残差可以体现异常值</h3><p>残差对于异常值的影响在于它们对误差的贡献程度。在最小二乘法中，所有残差都会以相同的权重参与到优化过程中，这意味着即使存在异常值，它们也会对最终拟合结果产生显著影响，因为异常值通常会导致较大的残差。</p><p>然而，当使用鲁棒核函数（如Huber损失函数）时，对于较小的残差，它们只会受到较小的惩罚，而对于较大的残差，它们会受到更大的惩罚。这样的设计使得鲁棒核函数能够更好地适应异常值的存在，因为异常值通常会导致较大的残差。因此，使用鲁棒核函数时，异常值的影响会被减弱，从而使得优化过程更加稳健，并且更能够反映数据的真实情况。</p><p>总的来说，鲁棒核函数通过调整对残差的惩罚来减少异常值对优化过程的影响，从而使得优化结果更具有鲁棒性。</p><p>残差是指观测值与拟合值之间的差异，它们在统计学和优化问题中经常被使用。在回归或拟合问题中，残差可以看作是模型未能解释的部分，包括了模型无法捕捉到的数据的波动性或噪声。当数据中存在异常值时，这些异常值往往会导致较大的残差，因为它们与模型的预期值相差较大。</p><p>因此，残差的大小和分布可以在一定程度上反映数据中的异常值。当数据中存在异常值时，通常会观察到较大的残差值，因为异常值与其他数据点的差异较大。这使得残差成为了一种检测异常值的方式，因为异常值通常会导致残差的偏离。</p><p>在统计建模和优化问题中，我们通常会对残差进行分析和处理，以便更好地理解数据的特征并提高模型的拟合效果。例如，在回归分析中，我们可以检查残差的分布是否满足模型假设，并根据需要调整模型。在优化问题中，我们可以使用残差来评估优化算法的效果，并进一步改进算法，以使残差逐渐减小。</p><p>因此，残差在一定程度上可以反映异常值的存在和影响，它们是在统计建模和优化问题中常用的工具，用于识别和处理数据中的异常情况。</p><h3 id="什么是残差较大的时候-施加较大的惩罚">什么是残差较大的时候施加较大的惩罚</h3><p>当我们说在残差较大的时候施加较大的惩罚时，意味着在优化过程中对于较大的残差值，我们会给予更大的权重或惩罚，以使得这些较大的残差不会对优化结果产生过大的影响。这样的做法可以减少异常值对优化过程的影响，使得优化结果更加鲁棒。</p><p>让我们通过一个简单的线性回归的例子来说明这个概念。假设我们有一组数据<span class="math inline">\((x_i, y_i)\)</span>，我们想要用线性模型<span class="math inline">\(y = mx + b\)</span>来拟合这些数据。然而，数据中存在一些异常值，这些异常值可能会导致较大的残差。在普通的最小二乘法中，我们会平方残差并求和，以最小化这些残差的平方和，即最小化目标函数：</p><p><span class="math display">\[\text{minimize } \sum_i (y_i - (mx_i +b))^2\]</span></p><p>然而，当存在异常值时，它们会导致较大的残差，从而对最小二乘法产生较大的影响。为了降低异常值的影响，我们可以使用Huber损失函数来代替平方损失，它在残差较小的情况下类似于平方损失，而在残差较大的情况下则类似于绝对值损失。这样的损失函数将对较大的残差施加较大的惩罚，从而减小了异常值对优化结果的影响。</p><p>Huber损失函数的形式如下：</p><p><span class="math display">\[L(r) =\begin{cases}\frac{1}{2} r^2, &amp; \text{if } |r| \leq \delta \\\delta (|r| - \frac{1}{2}\delta), &amp; \text{if } |r| &gt; \delta\end{cases}\]</span></p><p>其中，<span class="math inline">\(r\)</span>表示残差，<span class="math inline">\(\delta\)</span>是一个阈值参数，用于控制在何种范围内将损失函数视为二次型。当残差小于等于<span class="math inline">\(\delta\)</span>时，损失函数是一个平方函数，而当残差大于<span class="math inline">\(\delta\)</span>时，损失函数是一个线性函数。这样的设计使得在优化过程中对于较大的残差会施加较大的惩罚，从而减少了异常值对优化结果的影响。</p><h3 id="什么是较大的惩罚">什么是较大的惩罚</h3><p>让我进一步解释一下“受到较大的惩罚”是什么意思。</p><p>在优化问题中，我们通常会定义一个损失函数，用于衡量模型的拟合程度。这个损失函数越小，表示模型对数据的拟合越好。当我们使用不同的损失函数时，对于相同的残差，损失函数可能会对其赋予不同的重要性或权重。</p><p>举个简单的例子，假设我们使用平方损失函数：</p><p><span class="math display">\[L(r) = r^2\]</span> 在这种情况下，不论残差<span class="math inline">\(r\)</span>的大小如何，损失函数都会将其平方作为损失。因此，对于较大的残差，损失函数会将其平方的值作为较大的损失，而对于较小的残差，损失函数会将其平方的值作为较小的损失。</p><p>而当我们使用Huber损失函数时，对于较小的残差，损失函数是一个二次函数，因此对其赋予较小的权重；而对于较大的残差，损失函数是一个线性函数，因此对其赋予较大的权重。换句话说，Huber损失函数对于较大的残差会施加较大的惩罚，而对于较小的残差则施加较小的惩罚。</p><p>所以，当我们说“受到较大的惩罚”时，意味着对于那些导致较大残差的数据点，它们在优化过程中会被赋予较大的权重，以使得模型更加关注这些异常值，并尽可能减少它们对模型参数的影响。</p><hr><h3 id="herb比较好的例子"><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>比较好的例子​！！</h3><p>理解这个问题的关键在于理解异常值对于损失函数的影响。在传统的最小二乘法中，异常值的存在可能会导致较大的残差，从而对整个损失函数产生较大的影响。这意味着优化过程会受到异常值的干扰，可能会导致无法收敛到最优解，或者收敛到一个不够准确的解。</p><p>而使用鲁棒核函数时，对于较大的残差，它们会受到较小的权重，即较小的惩罚。这意味着异常值的存在不会对损失函数产生过大的影响，因为它们对于整体损失函数的贡献较小。相比之下，对于传统的最小二乘法来说，异常值的残差较大，导致损失函数的值被显著地增加。</p><p>通过减少异常值的影响，优化过程更有可能收敛到更好的解。<strong>这是因为优化过程可以更专注于拟合那些正常的、代表性的数据点，而不会被少数异常值所主导。</strong>这种机制使得优化过程更加稳健，能够更可靠地找到对数据拟合更好的解。</p><p>总的来说，通过对异常值施加较小的权重，可以减小它们对损失函数的影响，从而使得优化过程更有可能收敛到更好的解。</p><h3 id="具体数值的例子">具体数值的例子</h3><p>当我们使用最小二乘法时，我们通常会最小化残差的平方和，即： <span class="math display">\[\sum_{k=1}^n \|h_k(x_{i_k}) - z_k\|^2\]</span> 在这个公式中，<span class="math inline">\(h_k(x_{i_k})\)</span> 是模型对观测数据 <span class="math inline">\(z_k\)</span> 的预测值，<span class="math inline">\(x_{i_k}\)</span>是系统状态。这个公式中的每个残差都会被平方，并等权重地加总起来。</p><p>假设我们有一组观测数据和模型如下：</p><ul><li>观测数据：<span class="math inline">\(z_1 = 10\)</span>, <span class="math inline">\(z_2 = 12\)</span>, <span class="math inline">\(z_3= 8\)</span></li><li>模型预测值：<span class="math inline">\(h(x) = x\)</span></li></ul><p>如果我们使用最小二乘法，那么我们的优化目标就是最小化残差的平方和：</p><p><span class="math display">\[\text{目标：} \min_{x} \left( (x - 10)^2 + (x - 12)^2 + (x - 8)^2\right)\]</span> 假设我们初始时取 <span class="math inline">\(x =0\)</span>。计算残差的平方和为： <span class="math display">\[(0 - 10)^2 + (0 - 12)^2 + (0 - 8)^2 = 100 + 144 + 64 = 308\]</span> 然后我们使用优化算法来尝试减小这个值。</p><p>但如果我们知道在数据中有一些异常值，比如一个 <span class="math inline">\(z_2 =100\)</span>，这个数远远超出了其他数据的范围。在这种情况下，传统的最小二乘法会对这个异常值产生较大的影响。</p><p>现在我们尝试使用Huber损失函数，它对较大的残差施加较小的权重。Huber损失函数的形式如下：</p><p><span class="math display">\[L(r) =\begin{cases}\frac{1}{2} r^2, &amp; \text{if } |r| \leq \delta \\\delta (|r| - \frac{1}{2}\delta), &amp; \text{if } |r| &gt; \delta\end{cases}\]</span> 假设我们选择 <span class="math inline">\(\delta =2\)</span>。那么在计算损失函数时，对于较小的残差，我们会使用残差的平方，而对于较大的残差，我们会使用一个线性函数。所以，对于较大的残差，Huber损失函数的惩罚相对较小。</p><p>我们再次尝试用 <span class="math inline">\(x = 0\)</span>开始优化。计算Huber损失函数的值：</p><p><span class="math display">\[\text{目标：} \min_{x} \left( \frac{1}{2}(x - 10)^2 + \frac{1}{2}(x -12)^2 + \frac{1}{2}(x - 8)^2 \right)\]</span> 计算后的损失函数值为： <span class="math display">\[\frac{1}{2}(0 - 10)^2 + \frac{1}{2}(0 - 12)^2 + \frac{1}{2}(0 - 8)^2 =25 + 36 + 16 = 77\]</span>可以看出，相比于传统的最小二乘法，Huber损失函数对异常值的影响要小得多。因此，优化算法更有可能收敛到一个更接近于真实值的解。</p><h2 id="因子图为什么处理导航相关问题">因子图为什么处理导航相关问题</h2><ol type="1"><li><p><strong>局部测量与全局状态的关系</strong>：在GNSS/PDR系统中，我们需要整合来自GNSS的卫星信号数据和PDR系统（如加速度计、陀螺仪等）提供的内部传感器数据。<strong>这些数据与用户的全局位置和运动状态有直接关系</strong>。因子图允许我们将这些关系表达为局部函数，这些函数仅与某些变量相关联。</p></li><li><p><strong>联乘积形式的模型表示</strong>：在因子图中，全局函数（如位置和姿态的估计）可以被表示为多个局部函数的乘积。每个局部函数对应于一个特定的测量或状态变量的影响。例如，一个局部函数可能代表来自GNSS的位置测量，另一个局部函数可能代表来自步行检测算法的位移估计。这些局部函数的联乘积可以有效地融合来自不同源的数据，以优化全局状态的估计。</p></li></ol><h2 id="在因子图中各个因子对于执行如图搜索优化和推断等操作是非常有效的">在因子图中，各个因子对于执行如图搜索、优化和推断等操作是非常有效的？</h2><blockquote><p>在因子图中，各个因子直接关联到一组变量，并定义这些变量间的局部关系，这对于执行如图搜索、优化和推断等操作是非常有效的？</p></blockquote><p>这段话描述了因子图的核心特性：因子图是一种图形模型，用于表示变量之间的依赖关系。<strong>在因子图中，各个因子直接与一组变量相连，并且定义了这些变量之间的具体关系</strong>。这种结构对于图搜索、优化和推断等操作非常有效。以下是几个关键点来帮助理解这个概念：</p><h3 id="因子图的结构"><strong>因子图的结构</strong></h3><ol type="1"><li><strong>变量节点</strong>：表示问题中的各种变量（例如，在SLAM中的机器人位置或地图特征点）。</li><li><strong>因子节点</strong>：表示变量之间的具体关系或依赖，通常体现为概率函数或约束。这些因子定义了变量如何相互作用，例如，一个因子可能表示在给定机器人的某个位置时，预期的传感器测量与实际观察之间的关系。</li></ol><h3 id="执行图搜索优化和推断的效果"><strong>执行图搜索、优化和推断的效果</strong></h3><ol type="1"><li><p><strong>图搜索</strong>：因子图的结构使得可以有效地进行图搜索操作，例如寻找最可能的变量配置。<strong>因子图中的连接告诉搜索算法哪些变量是直接相互关联的，从而可以系统地探索这些变量的组合，寻找满足所有因子约束的最优解。</strong></p></li><li><p><strong>优化</strong>：在因子图中，优化通常涉及调整变量的值以最大化（或最小化）整体系统的某个性能指标（如概率总和或误差平方和）。因为<strong>因子直接定义了变量间的关系，优化算法可以直接利用这些局部关系，集中处理影响最大的部分，从而高效地改进解决方案。</strong></p></li><li><p><strong>推断</strong>：在概率模型中，推断通常意味着基于给定的数据和模型结构推测某些变量的状态。<strong>因子图提供了一种清晰的方式来利用局部信息（因子定义的局部概率关系）对全局状态（整个变量集的状态）进行推断。</strong>例如，给定某些变量的测量值，可以通过因子图推断其他未知变量的最可能值。</p></li></ol><h3 id="效率的原因"><strong>效率的原因</strong></h3><p>因子图将复杂的全局问题分解为多个简单的局部问题，每个局部问题都集中在一小组变量上。<strong>这种分解使得可以并行处理这些局部问题，或者专注于最关键的部分，从而大大提高了计算的效率</strong>。此外，因为因子定义了变量之间的确切关系，算法可以避免处理无关变量间的不必要计算，进一步优化性能。</p><p>因此，因子图是处理具有复杂依赖关系的优化和推断问题的一个非常强大和灵活的工具。</p><h2 id="因子图通过将测量值作为已知的参数而不是变量来简化问题表示">因子图通过将测量值作为已知的参数而不是变量来简化问题表示？</h2><p>因子图通过将测量值作为已知的参数而不是变量来简化问题表示，使得模型更直接地关联到优化问题本身，这对于高效解决SLAM等复杂问题至关重要。这段话怎么理解？通过将测量值作为已知的参数而不是变量来简化问题表示？</p><p>这段话指出因子图在处理如SLAM这样的问题时的一个关键特性：将测量数据视为已知参数，而不是作为需要求解的变量。这种处理方式在建模和求解复杂系统时有几个重要的好处：</p><p><strong>简化问题表示</strong></p><ol type="1"><li><p><strong>明确角色分配</strong>：在SLAM等问题中，我们的主要目标是推断或优化未知的状态变量（如机器人的位置、地图的特征点等），而测量数据（如来自传感器的读数）是用来帮助确定这些未知变量的。<strong>将测量值视为已知参数，意味着这些数据在模型中的角色是辅助性的，它们用于构建关于未知变量的条件概率表达，而不是自身需要被解决的问题</strong>。</p></li><li><p><strong>减少求解复杂度</strong>：如果将测量值也视为变量，那么问题的复杂度会显著增加，因为这样不仅需要推断未知的状态变量，还要同时解决这些测量值的准确性和可靠性问题。将测量值作为参数，可以直接使用这些数据来形成对未知变量的概率描述，从而简化了模型和计算。</p></li></ol><p><strong>直接关联到优化问题本身</strong></p><ol type="1"><li><p><strong>更加聚焦核心任务</strong>：在SLAM等应用中，核心任务是基于测量数据推断或更新未知的状态变量。<strong>将测量数据视为参数，可以使模型更加集中于如何利用这些数据来改善对未知变量的估计，而非分散注意力于处理测量数据本身的不确定性。</strong></p></li><li><p><strong>提高算法效率</strong>：当模型聚焦于核心变量时，优化算法可以更有效地调整和优化这些变量的值以达到最佳估计。这通常会导致更快的计算速度和更好的优化性能，因为算法可以直接利用固定的、已知的测量数据来逐步改进状态估计。</p></li></ol><p>总之，将测量值作为已知参数处理，有助于因子图更加高效和直接地应对复杂的优化问题，如SLAM，这样做能够减轻计算负担，同时提高问题求解的准确性和效率。这种方法使得模型设计和算法实现都更加直接和实用，特别是在实时或资源受限的应用场景中。</p><h2 id="因子图优化如何更新节点状态"><strong>因子图优化如何更新节点状态</strong></h2><p>让我们逐一探讨这两个问题：</p><p><strong>1. 根据导数信息计算状态更新量的例子</strong></p><p>考虑一个简单的SLAM问题，其中机器人需要确定它的位置x和地图上一个地标的位置l。假设有一个观测z与机器人的位置和地标之间的距离相关。</p><p><strong>步骤</strong></p><ul><li><p><strong>误差函数</strong>：设<span class="math inline">\(h(x,l)\)</span>是从机器人位置 <span class="math inline">\(x\)</span> 到地标<span class="math inline">\(l\)</span> 的预测测量，误差函数$ e$可表示为<span class="math inline">\(e = z - h(x, l)\)</span>。</p></li><li><p><strong>雅可比矩阵</strong>：计算误差<span class="math inline">\(e\)</span>关于状态 <span class="math inline">\(x\)</span> 和地标位置 <span class="math inline">\(l\)</span> 的雅可比矩阵<span class="math inline">\(J_x\)</span> 和 <span class="math inline">\(J_l\)</span>。</p></li><li><p><strong>更新公式</strong>：使用高斯牛顿法，更新公式可以写作：</p></li></ul><p><span class="math display">\[\begin{pmatrix} \Delta x \\ \Delta l \end{pmatrix} = -(J^T J + \lambdaI)^{-1} J^T e\]</span></p><p>其中 ( J ) 是组合了<span class="math inline">\(J_x\)</span> 和$ J_l$的雅可比矩阵，$$是为了提高数值稳定性而添加的阻尼因子（Levenberg-Marquardt算法中使用）,I是单位矩阵。</p><ul><li><strong>状态更新</strong>：计算得到的$ x $ 和$l$用来更新当前状态和地标位置。</li></ul><p><strong>2. 增量式图优化方法的实际操作</strong></p><p>在实时系统如自动驾驶车辆中，<strong>增量图优化</strong>主要关注最近的观测和状态，以减少每次更新所需的计算资源。</p><p><strong>步骤</strong></p><ul><li><strong>局部图更新</strong>：每当接收到新的观测数据时，只更新与这些新数据直接相关的节点和边，这些通常是最近的机器人状态和相关地标。</li><li><strong>窗口优化</strong>：一种常见的策略是<strong>固定滑动窗口方法，即仅在固定大小的最近状态窗口内进行优化</strong>。较旧的状态和地标，一旦它们超出窗口，<strong>可以被边缘化（从优化问题中移除但考虑其对现有状态的统计影响）或锁定。</strong></li><li><strong>增量求解器</strong>：使用专门设计的<strong>增量求解器</strong>，如iSAM 或 g2o，这些工具能够有效地更新信息矩阵和求解增量更新问题。</li><li><strong>实时反馈</strong>：通过快速更新仅涉及局部改动的解决方案，系统能够快速地对新数据做出响应。</li></ul><p>这种增量更新方法能够显著降低因每个新观测而进行全局优化的计算成本，使系统更适合实时应用场景，如自动驾驶或动态环境中的机器人导航。</p><h2 id="因子图的迭代优化算法">因子图的迭代优化算法</h2><p>图优化的迭代优化通常涉及到通过逐步优化来调整和改进图中的节点估计（即状态变量），以最小化整个图中所有误差函数（因子）的总和。这个过程通常使用类似于高斯-牛顿或者LM算法的优化方法。</p><p><strong>图优化迭代过程</strong></p><ol type="1"><li><strong>初始化</strong>：<ul><li>节点的初始估计通常基于传感器的原始数据或某些先验知识。</li></ul></li><li><strong>构建误差函数</strong>：<ul><li>对于图中的每一个因子，构建一个误差函数，该函数衡量当前节点状态估计与观测数据之间的差异。</li></ul></li><li><strong>线性化误差函数</strong>：<ul><li>在当前估计点附近对误差函数进行线性化，通常是通过计算误差函数相对于每个节点状态的雅可比矩阵。</li></ul></li><li><strong>构建正规方程</strong>：<ul><li>将所有线性化的误差函数组合成一个大的系统方程。这通常表现为一个大的稀疏线性系统，可以写成<span class="math display">\[ H\delta = b \]</span> 的形式，其中 ( H )是信息矩阵（或海森矩阵），而 ( b ) 是基于误差的向量。</li></ul></li><li><strong>求解线性系统</strong>：<ul><li>使用直接求解器（如Cholesky分解）或迭代求解器（如共轭梯度法）来解决上述线性系统，以找到状态更新<span class="math inline">\(\delta\)</span>。</li></ul></li><li><strong>更新状态估计</strong>：<ul><li>将解得的<span class="math inline">\(\delta\)</span>应用到当前的状态估计中，更新所有节点的状态。</li></ul></li><li><strong>迭代和收敛检查</strong>：<ul><li>检查解的改进程度，如果未达到预设的收敛标准（如状态改变量的大小低于某个阈值或达到最大迭代次数），则重复步骤2-6。</li></ul></li><li><strong>最终优化结果</strong>：<ul><li>当迭代收敛时，当前的状态估计被认为是优化的解，即图中所有节点的最优估计。</li></ul></li></ol><p><strong>使用Levenberg-Marquardt方法的特别说明</strong></p><p>Levenberg-Marquardt算法是高斯-牛顿算法的一个变种，通过引入一个调整参数（阻尼因子）来平衡算法的迭代速度与稳定性。这个阻尼因子可以动态调整，以在必要时约束更新步长，从而提高收敛性和算法的鲁棒性。</p><h2 id="关于因子图的误差函数">关于因子图的误差函数</h2><h3 id="一个具体的例子">一个具体的例子</h3><p>在因子图中使用的每个因子都可以被看作是一个误差函数，它描述了给定状态变量下预期观测值与实际观测值之间的差异。雅可比矩阵是这些误差函数对于状态变量的一阶导数，用于在非线性优化过程中进行线性化。</p><h4 id="模型和误差函数">模型和误差函数</h4><p>以GNSS和PDR为例，我们可以具体定义状态变量和误差函数。</p><p>假设状态变量 <span class="math inline">\(\mathbf{x}_k\)</span> 在第<span class="math inline">\(k\)</span>时刻是一个包括位置和朝向的位姿，可以表示为一个二维平面上的姿态（位置<span class="math inline">\((x, y)\)</span> 和朝向 <span class="math inline">\(\theta\)</span>）： <span class="math display">\[\mathbf{x}_k = \begin{bmatrix} x_k \\ y_k \\ \theta_k \end{bmatrix}\]</span> GNSS观测模型</p><p>假设GNSS提供了位姿的绝对观测： <span class="math display">\[\mathbf{z}^{\text{GNSS}}_k = \begin{bmatrix} x^{\text{meas}}_k \\y^{\text{meas}}_k \\ \theta^{\text{meas}}_k \end{bmatrix}\]</span> 误差函数（GNSS因子）可以定义为： <span class="math display">\[\mathbf{e}^{\text{GNSS}}_k = \mathbf{z}^{\text{GNSS}}_k - \mathbf{x}_k\]</span></p><h4 id="pdr观测模型">PDR观测模型</h4><p>PDR通常提供相对于上一状态的位移和方向改变，假设步行产生的位移 <span class="math inline">\(\Delta d\)</span> 和方向变化 <span class="math inline">\(\Delta \theta\)</span>： <span class="math display">\[\mathbf{z}^{\text{PDR}}_k = \begin{bmatrix} \Delta d_k \\ \Delta\theta_k \end{bmatrix}\]</span> 相应的误差函数（PDR因子）可能是： <span class="math display">\[\mathbf{e}^{\text{PDR}}_k = \mathbf{x}_k - \left( \mathbf{x}_{k-1} +\begin{bmatrix} \Delta d_k \cos(\theta_{k-1}) \\ \Delta d_k\sin(\theta_{k-1}) \\ \Delta \theta_k \end{bmatrix} \right)\]</span></p><h4 id="雅可比矩阵计算">雅可比矩阵计算</h4><p>雅可比矩阵是误差函数相对于状态变量的偏导数。以PDR误差函数为例，其雅可比矩阵相对于状态<span class="math inline">\(\mathbf{x}_k\)</span> 的导数为：</p><p><span class="math display">\[J_{\mathbf{x}_k}^{\text{PDR}} = \frac{\partial\mathbf{e}^{\text{PDR}}_k}{\partial \mathbf{x}_k} = \begin{bmatrix}1 &amp; 0 &amp; -\Delta d_k \sin(\theta_{k-1}) \\0 &amp; 1 &amp; \Delta d_k \cos(\theta_{k-1}) \\0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>这里，偏导数是通过微分 <span class="math inline">\(\mathbf{x}_k\)</span> 和 <span class="math inline">\(\mathbf{x}_{k-1}\)</span> 相关的表达式得到的。</p><h4 id="gtsam中的实现">GTSAM中的实现</h4><p>在GTSAM这样的库中，用户只需定义状态变量、误差函数和噪声模型。库内部负责计算雅可比矩阵并进行优化。在每次迭代中，基于当前的估计值，库会自动对误差函数进行线性化，计算雅可比矩阵，并更新状态估计。</p><p>在GTSAM中，可以通过自定义因子类来将状态转移函数 ( f )纳入因子图中，并通过优化来估计状态变量。以下是一个示例，演示了如何在PDR/GNSS联合定位中使用状态转移函数作为因子的一部分。</p><p>假设我们有一个PDR传感器和一个GNSS传感器，我们希望使用PDR的状态转移函数来更新我们的位置估计。这里我们将假设PDR传感器的状态转移函数为( f(x_t, u_t) )，其中 ( x_t ) 是时刻 ( t ) 的位置状态， ( u_t ) 是时刻 (t ) 的PDR测量值。</p><h5 id="其中一种">其中一种</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/base/numericalDerivative.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/geometry/Pose2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/inference/Symbol.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/ExpressionFactorGraph.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/Expression.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/LevenbergMarquardtOptimizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> gtsam;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义PDR状态转移函数</span></span><br><span class="line"><span class="function">Pose2 <span class="title">pdrStateTransition</span><span class="params">(<span class="type">const</span> Pose2&amp; xt, <span class="type">const</span> Pose2&amp; ut)</span> </span>{</span><br><span class="line">    <span class="comment">// 这里简单假设PDR每一步都是直线运动</span></span><br><span class="line">    <span class="keyword">return</span> xt.<span class="built_in">compose</span>(ut);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建优化器</span></span><br><span class="line">    LevenbergMarquardtOptimizer optimizer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建符号变量</span></span><br><span class="line">    <span class="function">Symbol <span class="title">x1</span><span class="params">(<span class="string">'x'</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 时刻1的位置状态</span></span><br><span class="line">    <span class="function">Symbol <span class="title">u1</span><span class="params">(<span class="string">'u'</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 时刻1的PDR测量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始估计值</span></span><br><span class="line">    Values initial;</span><br><span class="line">    initial.<span class="built_in">insert</span>(x1, <span class="built_in">Pose2</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 初始位置状态</span></span><br><span class="line">    initial.<span class="built_in">insert</span>(u1, <span class="built_in">Pose2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 初始PDR测量值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建因子图</span></span><br><span class="line">    ExpressionFactorGraph graph;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加PDR状态转移因子</span></span><br><span class="line">    <span class="comment">// 创建表达式表示PDR状态转移函数</span></span><br><span class="line">    Expression&lt;Pose2&gt; f_expr = <span class="built_in">pdrStateTransition</span>(<span class="built_in">Expression</span>&lt;Pose2&gt;(x1), <span class="built_in">Expression</span>&lt;Pose2&gt;(u1));</span><br><span class="line">    <span class="comment">// 添加因子</span></span><br><span class="line">    graph.<span class="built_in">addExpressionFactor</span>(f_expr, <span class="built_in">Pose2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), noiseModel::Isotropic::<span class="built_in">Sigma</span>(<span class="number">3</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行优化</span></span><br><span class="line">    Values result = optimizer.<span class="built_in">optimize</span>(graph, initial);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终估计结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Final Result:\n"</span>;</span><br><span class="line">    result.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在这个示例中，我们通过 <code>ExpressionFactorGraph</code>来创建因子图，并使用 <code>Expression</code>表示状态转移函数。然后，我们将这个表达式因子添加到因子图中，并执行优化以估计最终的状态。</p><p>这个示例中的 <code>pdrStateTransition</code>函数是一个简单的状态转移函数示例，实际应用中可能需要根据具体的PDR传感器和系统模型来定义更复杂的状态转移函数。</p><h5 id="另一种">另一种</h5><p>在GTSAM中，如果要将状态转移函数 ( f )作为实现因子的一部分，你需要定义自定义的因子类。这个类应当能够处理状态的更新并计算误差向量，同时能够自动计算雅可比矩阵。下面是一个例子，展示如何为一个简单的PDR/GNSS系统创建一个自定义的因子类。</p><p>以下是GTSAM中一个自定义因子的简单实现，用于处理PDR和GNSS数据：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/NonlinearFactor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/geometry/Pose2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> gtsam;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设系统的状态由位置 (x, y) 和方向 (theta) 组成，使用 Pose2 表示</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDRGNSSFactor</span> : <span class="keyword">public</span> NoiseModelFactor1&lt;Pose2&gt; {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 测量值</span></span><br><span class="line">  Point2 measuredGNSS;  <span class="comment">// GNSS测量的位置</span></span><br><span class="line">  <span class="type">double</span> measuredSteps; <span class="comment">// PDR测量的步数</span></span><br><span class="line">  <span class="type">double</span> stepLength;    <span class="comment">// 步长</span></span><br><span class="line">  <span class="type">double</span> measuredHeading; <span class="comment">// 步行方向</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造函数</span></span><br><span class="line"><span class="comment">   * key - 对应变量的键</span></span><br><span class="line"><span class="comment">   * measuredGNSS - GNSS测量值</span></span><br><span class="line"><span class="comment">   * measuredSteps - PDR测量的步数</span></span><br><span class="line"><span class="comment">   * stepLength - 单步步长</span></span><br><span class="line"><span class="comment">   * measuredHeading - 测量的步行方向</span></span><br><span class="line"><span class="comment">   * noiseModel - 噪声模型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">PDRGNSSFactor</span>(Key key, <span class="type">const</span> Point2&amp; gnssMeasurement, <span class="type">double</span> steps, <span class="type">double</span> length, <span class="type">double</span> heading, <span class="type">const</span> SharedNoiseModel&amp; noiseModel)</span><br><span class="line">    : <span class="built_in">NoiseModelFactor1</span>&lt;Pose2&gt;(noiseModel, key), <span class="built_in">measuredGNSS</span>(gnssMeasurement), <span class="built_in">measuredSteps</span>(steps), <span class="built_in">stepLength</span>(length), <span class="built_in">measuredHeading</span>(heading) {}</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算误差向量的函数</span></span><br><span class="line">  <span class="function">Vector <span class="title">evaluateError</span><span class="params">(<span class="type">const</span> Pose2&amp; pose, boost::optional&lt;Matrix&amp;&gt; H = boost::none)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">    <span class="comment">// 使用当前姿势来预测下一位置</span></span><br><span class="line">    <span class="type">double</span> dx = stepLength * measuredSteps * <span class="built_in">cos</span>(measuredHeading);</span><br><span class="line">    <span class="type">double</span> dy = stepLength * measuredSteps * <span class="built_in">sin</span>(measuredHeading);</span><br><span class="line">    <span class="function">Point2 <span class="title">predictedPosition</span><span class="params">(pose.x() + dx, pose.y() + dy)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要雅可比矩阵</span></span><br><span class="line">    <span class="keyword">if</span> (H) {</span><br><span class="line">      *H = (<span class="built_in">Matrix</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">cos</span>(measuredHeading), -<span class="built_in">sin</span>(measuredHeading), <span class="number">0</span>,</span><br><span class="line">                            <span class="built_in">sin</span>(measuredHeading),  <span class="built_in">cos</span>(measuredHeading), <span class="number">0</span>).<span class="built_in">finished</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回GNSS测量值和预测位置之间的差异</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Vector</span>(<span class="number">2</span>) &lt;&lt; measuredGNSS.<span class="built_in">x</span>() - predictedPosition.<span class="built_in">x</span>(), measuredGNSS.<span class="built_in">y</span>() - predictedPosition.<span class="built_in">y</span>()).<span class="built_in">finished</span>();</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>使用此因子</strong></p><p>在你的SLAM系统或状态估计框架中，你可以像添加任何其他因子一样添加这个自定义因子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NonlinearFactorGraph graph;</span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">PDRGNSSFactor</span>(<span class="number">1</span>, <span class="built_in">Point2</span>(<span class="number">34.052</span>, <span class="number">-118.243</span>), <span class="number">20</span>, <span class="number">0.5</span>, <span class="number">0.785</span>, noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>))));</span><br></pre></td></tr></tbody></table></figure><p>这里，我们假设了步长为0.5米，测量的步行方向为0.785弧度（大约45度）。</p><ul><li>确保你的噪声模型和其他系统参数与你的具体应用场景匹配。</li><li>如果你的状态模型或动态更复杂，你可能需要扩展 <code>Pose2</code>到更高维度的表示，或者使用 <code>Pose3</code>如果是三维空间的应用。</li></ul><p>这个示例为如何将PDR和GNSS数据融合到单一的因子中提供了一个框架，展示了如何结合两种不同类型的测量更新机器人或移动设备的位置估计。</p><h2 id="为什么是因子图不是卡尔曼">为什么是因子图不是卡尔曼</h2><p>（1）<strong>处理非线性问题</strong>：EKF在处理行人轨迹的不确定性和GNSS信号的非线性特性时存在性能限制。由于行人轨迹的不确定性本质上属于状态非线性过程，EKF通过线性化系统模型来处理非线性问题，但这种方法是局部的，仅在当前估计点附近有效。FGO则是通过构建一个包含所有测量和状态变量的全局图模型，然后应用非线性最优化技术在整个状态空间中寻找最优解来解决整个问题，而不是局限于在每个时间步的局部线性化。</p><blockquote><p>由于非线性问题的复杂性，这种全局优化通常是迭代进行的。每一次迭代都会重新计算整个状态的最优估计，更新的估计会反过来影响下一次迭代的起始条件。这个过程一直重复，直到达到一个收敛条件，比如改进非常小或达到预设的迭代次数。</p></blockquote><p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>但是这个非线性的函数是需要自己手动添加的。那么问题来了，非线性函数都是自己手动给设置好的，怎么就直接参入因子图里面去了。就是编程里面？</p><blockquote><p>后续需要编程学习！需要定义误差因子</p></blockquote><ol start="2" type="1"><li>处理连续轨迹跟踪：EKF的一阶马尔可夫假设限制了其对历史数据的再评估能力，影响行人轨迹连续跟踪性能。FGO则在新数据到来时重新评估整个状态历史，进行全局优化，提供更准确的状态估计，尤其适用于需要频繁更新和修正轨迹估计的室外行人导航。</li></ol><blockquote><p>在因子图优化中，通常会使用全局优化算法（例如梯度下降、高斯牛顿、或勒文贝格-马夸尔特方法等）来找到最小化所有因子误差的整体解。<strong>这种优化会考虑到新的数据点以及它们与已有数据点之间的关系，</strong>从而可能会影响到整个状态历史的估计</p></blockquote><ol start="3" type="1"><li>异步数据处理：EKF在实时处理不同传感器数据更新频率不一致时面临挑战。FGO允许传感器数据以即插即用的方式整合，通过贝叶斯推理对因子进行综合分析，有效解决异步数据问题。</li></ol><blockquote><p>具体见后文因子图的即插即用</p></blockquote><p>(4)解算效率：EKF在处理大规模或复杂系统时，由于需要操作稠密的协方差矩阵而效率较低。相比之下，FGO通过仅在因子间建立显式连接，自然地体现了系统的稀疏性。这种特性使得FGO适合处理那些局部相互作用的大型系统，从而提高了效率。</p><p>综上所述，FGO为解决行人导航中的非线性问题、提高位置估计准确性、异步数据的处理和解算效率上提供了一种新的解决方案。</p><h2 id="因子图的增量更新">因子图的增量更新</h2><p>在因子图优化中，确实可以采用一种增量更新的方法，但这并不意味着每来一个新数据就单独优化一次。因子图优化通常包括两种主要的更新策略：批量优化和增量优化，这取决于应用的需求和系统设计。</p><h3 id="批量优化">批量优化</h3><p>在批量优化策略中，因子图会收集一定量的数据后，进行一次全局优化。这种方法可以确保考虑到所有可用的信息来优化整个图的配置。批量处理通常在数据集完整或更新频率不高的情况下使用，例如在某些离线处理或数据分析任务中。</p><h3 id="增量优化">增量优化</h3><p>增量优化策略则更加动态，它允许系统在接收到新数据时即时更新和优化图的一部分。这并不意味着每接收到一个新的数据点就执行一次完整的全局优化，<strong>而是指更新影响到的部分节点和边，从而局部调整图的结构。</strong>这样的方法适用于需要实时或近实时处理的应用，如移动机器人的导航或在线地图构建。</p><h3 id="如何处理新增数据">如何处理新增数据</h3><p>当新数据到达时，在因子图中，通常采用以下步骤处理：</p><ol type="1"><li><strong>新增因子</strong>：将新的观测数据转化为因子，并将其连接到图中对应的变量节点上。</li><li><strong>局部优化</strong>：对受新因子影响的节点进行局部优化，更新这些节点的状态估计。这种方法称为增量或局部优化。</li><li><strong>全局优化</strong>：在某些情况下，为了保证整体性能，可能定期进行一次全局优化，以整合所有信息并纠正潜在的误差积累。</li></ol><p>这种灵活性和即插即用的特性使因子图非常适合于动态环境下的应用，如动态传感器网络、实时导航系统等，它们需要不断地接受新信息并快速反应。因子图的这些特性也使得它能够在不重新启动系统的情况下适应新的配置或数据源的变化。</p><h2 id="因子图的即插即用">因子图的即插即用</h2><p>因子图对于处理传感器更新频率不一致问题提供了一种灵活且有效的方式，特别是在复杂的多传感器融合系统中。这主要得益于因子图在处理多源信息与维持全局状态估计方面的灵活性。</p><p>在因子图中，每个传感器的输入可以被视为一个因子，它只与图中的某些变量（例如机器人的某个位置）相关联。<strong>当新的传感器数据到来时，可以简单地将相应的新因子添加到图中，而无需重新配置整个系统。</strong>这使得因子图非常适合于处理具有不同更新频率的传感器数据。</p><p>假设一个机器人装备了一个高频率的IMU（惯性测量单元）和一个低频率的GPS。IMU能够提供高频率但低精度的位置和方向更新，而GPS提供低频率但高精度的位置测量。</p><ol type="1"><li><strong>构建因子图</strong>：机器人的每个状态（位置和姿态）都是图中的一个节点。IMU和GPS的每次读数分别产生一个新的因子，这些因子与特定的状态节点相连接。</li><li><strong>IMU因子</strong>：IMU的数据频繁更新，为图中相邻的状态节点间提供动态的约束（如速度和方向）。</li><li><strong>GPS因子</strong>：GPS数据不频繁，但每当数据到来时，会在因子图中创建一个新的因子，这个因子直接将GPS测量的位置与最近的状态节点相关联。</li><li><strong>因子更新</strong>：<strong>无论何时收到新的传感器数据，都只需将对应的新因子添加到图中并重新优化，而不必修改或重处理整个图。</strong></li></ol><h3 id="与卡尔曼滤波的比较"><strong>与卡尔曼滤波的比较</strong></h3><p>卡尔曼滤波器（包括其扩展和无迹变体）通常需要处理所有传感器数据的固定结构和预设的处理流程<strong>。每个传感器都需要在每个时间步被处理，即使某些传感器的数据并未更新。</strong></p><ul><li><strong>即插即用</strong>：卡尔曼滤波处理新传感器集成<strong>通常需要重新设计滤波过程和状态协方差的计算，而因子图可以更容易地通过添加新的因子来整合新传感器，无需重新设计或重新初始化整个系统。</strong></li><li><strong>处理非同步数据</strong>：卡尔曼滤波器<strong>对于非同步传感器数据处理通常需要额外的插值或同步机制，而因子图可以更自然地通过在适当的时间点插入因子来处理这种数据。</strong></li></ul><p>卡尔曼滤波器（KF）是一种适用于线性系统（或近似线性）的递推滤波方法，它依赖于数据输入的同步和连续性。在实际应用中，如自动驾驶车辆、机器人导航或多传感器融合系统中，传感器可能无法以同一频率或同步的方式产生数据。这会给基于卡尔曼滤波的系统设计带来挑战。</p><p><strong>卡尔曼滤波器和非同步数据处理</strong></p><p>当使用卡尔曼滤波器处理来自不同传感器的数据时，若这些传感器的更新频率不一致或数据非同步接收，可能需要进行额外处理以保证数据的时序一致性。这主要是因为卡尔曼滤波器在每个时间步更新状态估计时都假定接收到的数据是当前时刻的准确反映。</p><p><strong>举例说明</strong></p><p>假设有一个移动机器人使用两种传感器：一个激光雷达（LIDAR）和一个轮速计。激光雷达每100毫秒更新一次位置信息，而轮速计每30毫秒更新一次速度信息。如果直接将这些数据输入到一个卡尔曼滤波器，可能会出现问题，因为两种数据的时间戳不匹配。</p><p>为了同步这些传感器数据，一个常见的方法是使用插值：</p><ul><li><strong>插值</strong>：例如，可以使用线性插值或更复杂的插值方法（如样条插值）来估计激光雷达测量间隙中的位置数据，或者在轮速计测量间隙中估计速度，以便在非测量时刻提供数据估计。</li><li><strong>数据缓冲</strong>：另一种方法是对快速更新的传感器（轮速计）数据进行缓冲，直到慢速传感器（激光雷达）的下一次数据到来，然后一起处理这些数据。</li></ul><p>卡尔曼滤波器（KF）处理的核心在于<strong>它按照严格的时序顺序处理观测数据来更新状态估计</strong>。这个处理过程基于两个关键假设：<strong>系统的动态是已知的，并且观测数据是同步到特定的时间点的。</strong>当观测数据来自频率不同或非同步的多个传感器时，这些假设可能不再成立，直接接受数据而不进行任何处理可能会导致以下问题：</p><p><strong>1. 误差累积</strong></p><p>卡尔曼滤波器在每个时间步更新其状态估计时，假设最新的观测数据反映了当前的系统状态。<strong>如果直接使用非同步的观测数据，滤波器可能无法准确地关联观测数据与其对应的状态，从而导致误差累积</strong>。例如，如果一个传感器的数据延迟或提前了，而滤波器误以为这些数据是最新的，那么更新的状态估计可能会基于错误的信息。</p><p><strong>2. 时间戳不匹配</strong></p><p>在处理来自不同传感器的数据时，<strong>每个传感器的输出通常带有时间戳。如果这些时间戳不一致，直接接受数据意味着滤波器可能会在错误的时间点应用观测数据，导致状态更新不准确</strong>。这对于那些高度依赖精确时间信息的应用（如导航和跟踪系统）尤为重要。</p><p><strong>3. 数据丢失或重叠</strong></p><p>非同步数据可能导致数据在时间轴上出现重叠或缺口。例如<strong>，一个传感器可能在另一个传感器的两次读数之间多次更新，或者在长时间内没有更新。这种情况下，直接处理可能导致某些观测数据被忽略或重复计算，影响滤波器的性能</strong>。</p><h3 id="卡尔曼滤波的结构和限制">卡尔曼滤波的结构和限制</h3><ol type="1"><li><p><strong>模型依赖性</strong>：卡尔曼滤波依赖于一个预先定义好的线性模型（或在扩展卡尔曼滤波和无迹卡尔曼滤波中的非线性模型近似）。这个模型包括状态转移矩阵和观测矩阵，它们必须在滤波器初始化时就确定下来。如果系统的动态特性改变（例如，添加了新的传感器或系统的运动模型改变），可能需要重新定义这些模型矩阵。</p></li><li><p><strong>系统维度</strong>：卡尔曼滤波在设计时需要确定状态向量的维度。如果需要加入新的状态变量（比如从新传感器获得的额外数据），通常需要重新设计整个状态向量和相关的处理矩阵，这可能涉及到重新设计状态转移和观测矩阵，以及相应的噪声协方差矩阵。</p></li><li><p><strong>实时性和适应性</strong>：卡尔曼滤波器是为了连续、实时的数据流设计的，其强大的实时更新能力在许多应用中非常有用。然而，对于动态变化的系统配置或异步数据源的适应性则不如因子图灵活。</p></li></ol><p>虽然卡尔曼滤波在处理线性系统、实时跟踪等方面有其固有优势，但在系统动态变化较大、数据源频繁变动或需要处理高度非线性系统时，因子图提供了更高的灵活性和扩展性。因子图的结构使其能够更容易地适应系统配置的变化，而不需要进行大规模的系统重设计。这使得因子图在多传感器融合、复杂环境导航等领域尤为适用。</p><h4 id="解决方法插值和数据缓冲"><strong>解决方法：插值和数据缓冲</strong></h4><p>为了解决这些问题，卡尔曼滤波器通常采用以下策略：</p><ul><li><p><strong>插值</strong>：通过插值方法（如线性插值、样条插值等）创建虚拟的观测数据，填补时间上的缺口，使得每个时间步都有相应的数据输入。这有助于保持滤波器的连续性和准确性。</p></li><li><p><strong>数据缓冲</strong>：将来自不同传感器的数据存储在缓冲区中，直到收集到所有相关传感器的数据为止。然后，根据这些数据的时间戳一起处理它们。这样可以保证数据在时间上的一致性，减少由于时间错配引起的误差。</p></li></ul><p>这两种方法使得卡尔曼滤波器能够更加稳定和准确地处理来自多源的非同步数据，从而提高系统的整体性能。</p><h3 id="因子图的优势"><strong>因子图的优势</strong></h3><p>相比之下，因子图提供了一个更灵活的框架来处理非同步数据。因子图是一种图形模型，它以图的形式表示变量之间的条件依赖关系。在因子图中，每个传感器的读数可以作为一个因子被添加到图中，这些因子与它们影响的状态变量相关联。如果传感器数据是非同步的，可以：</p><ul><li><strong>动态添加因子</strong>：根据每个传感器的时间戳动态地向图中添加新的因子。这意味着每个传感器更新只影响相关的状态变量，不需要人为地同步所有数据。</li><li><strong>时间标记</strong>：每个因子可以携带时间信息，因此状态更新可以在正确的时间点进行，与数据实际测量的时间相匹配。</li></ul><p>因此，因子图模型通过在合适的时间点添加因子来自然地处理非同步的传感器数据，从而避免了在卡尔曼滤波器中必须进行的数据插值或同步。这样不仅简化了处理过程，而且可能提高了系统的整体性能和精度。</p><p>因子图的结构允许在不中断现有系统的情况下动态地添加新的节点和边。这在处理如下情况时特别有用：</p><ul><li><strong>新增数据源</strong>：可以将新传感器数据直接作为新因子加入图中，与相关的状态节点连接，无需改变现有的其他因子或节点。</li><li><strong>系统扩展</strong>：在因子图中，系统的扩展通常只涉及向图中添加更多的节点和边，而不需要重新配置整个系统的基本结构。</li></ul><h3 id="因子图处理和识别不同的传感器">因子图处理和识别不同的传感器</h3><p>要在代码层面正确地处理和区分不同类型的传感器数据（如IMU和GNSS），你通常需要依赖于数据本身的元数据，这些元数据包括数据类型、时间戳等信息。让我们从这两个方面（实际实现和理论理解）来探讨你的问题：</p><h4 id="代码层面如何识别和处理不同的传感器数据">代码层面：如何识别和处理不同的传感器数据</h4><p>在现实世界的应用中，每个传感器的输出通常会被标记有其类型，可能还包括精确的时间戳。这允许你在接收数据时进行适当的处理。以下是一个简化的例子，展示如何在接收数据时识别和处理IMU与GNSS数据：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IMUData</span> {</span><br><span class="line">    <span class="type">double</span> acceleration[<span class="number">3</span>];  <span class="comment">// 加速度数据</span></span><br><span class="line">    <span class="type">double</span> gyro[<span class="number">3</span>];          <span class="comment">// 陀螺仪数据</span></span><br><span class="line">    <span class="type">double</span> timestamp;        <span class="comment">// 时间戳</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GNSSData</span> {</span><br><span class="line">    <span class="type">double</span> latitude;</span><br><span class="line">    <span class="type">double</span> longitude;</span><br><span class="line">    <span class="type">double</span> altitude;</span><br><span class="line">    <span class="type">double</span> timestamp;        <span class="comment">// 时间戳</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::variant&lt;IMUData, GNSSData&gt; SensorData; <span class="comment">// 使用C++17标准的std::variant来处理不同类型的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理IMU数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processIMUData</span><span class="params">(<span class="type">const</span> IMUData&amp; data)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Processing IMU Data at timestamp: "</span> &lt;&lt; data.timestamp &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 添加IMU因子到因子图等</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理GNSS数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processGNSSData</span><span class="params">(<span class="type">const</span> GNSSData&amp; data)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Processing GNSS Data at timestamp: "</span> &lt;&lt; data.timestamp &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 添加GNSS因子到因子图等</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理传感器数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> SensorData&amp; sensorData)</span> </span>{</span><br><span class="line">    std::<span class="built_in">visit</span>([&amp;](<span class="keyword">auto</span>&amp;&amp; data) {</span><br><span class="line">        <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(data)&gt;;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, IMUData&gt;) {</span><br><span class="line">            <span class="built_in">processIMUData</span>(data);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, GNSSData&gt;) {</span><br><span class="line">            <span class="built_in">processGNSSData</span>(data);</span><br><span class="line">        }</span><br><span class="line">    }, sensorData);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    IMUData imuData = {{<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>}, {<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>}, <span class="number">0.1</span>};</span><br><span class="line">    GNSSData gnssData = {<span class="number">34.05</span>, <span class="number">-118.25</span>, <span class="number">100</span>, <span class="number">0.2</span>};</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processData</span>(imuData);</span><br><span class="line">    <span class="built_in">processData</span>(gnssData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="理论层面为什么因子图能实现即插即用">理论层面：为什么因子图能实现即插即用</h4><p>因子图的设计非常适合于处理复杂的多源信息融合问题，主要有以下几个理由：</p><ol type="1"><li><p><strong>模块化</strong>：因子图通过因子来定义变量间的关系。每个传感器的数据可以被视为一个因子，这些因子可以独立地被添加到图中。因此，不同类型和不同时间的传感器数据可以作为独立的因子插入，而不会影响图中的其他部分。</p></li><li><p><strong>灵活性</strong>：由于因子图中各个因子的独立性，新的数据可以在任何时点加入图中，而不需要按照特定的顺序。这对于处理具有不同采样率和可能不同步到达的传感器数据尤其有用。</p></li><li><p><strong>扩展性</strong>：因子图可以容易地扩展以包含新的变量和因子，使得它非常适合于动态环境和在线更新的场景。</p></li></ol><p>因子图允许在不重新整个系统的情况下，根据新接收到的数据进行局部更新，这使得它非常适合于需要实时或近实时性能的应用，如动态的机器人导航和车辆定位系统。</p><h2 id="为什么要引进g_ii-i_dtimes-d">为什么要引进<span class="math inline">\(G_i^i=-I_{d\times d}\)</span></h2><blockquote><p>关于这个莫名的公式可以看看isam的公式，这个就是对那个公式的补充点</p></blockquote><p>在因子图和图优化中进行线性化处理时，引入矩阵<span class="math inline">\(G_i^i = -I_{d \timesd}\)</span>是为了便于表达和操作线性化的状态变化量。这里，$ I_{d d} <span class="math inline">\(表示 \( d \)-维的单位矩阵。矩阵 \( G_i^i \)的作用是在数学表达式中简化状态变量\)</span>x_i$的运算，从而使得该线性系统易于使用线性代数技术求解。</p><p>在线性化的SLAM或图优化问题中，我们通常处理的是两类项：</p><ol type="1"><li><strong>过程模型项</strong>：它们涉及从一个状态<span class="math inline">\(x_{i-1}\)</span> 到下一个状态$x_i$的过渡，如机器人的运动模型。</li><li><strong>测量模型项</strong>：涉及从状态变量到测量变量的映射，如从机器人的位置到传感器观测的映射。</li></ol><p><strong>引入 $G_i^i = -I_{d d} $</strong></p><p>在方程 (6) 中，我们考虑了状态变量 <span class="math inline">\(x_i\)</span>和<span class="math inline">\(x_{i-1}\)</span>之间的关系。线性化后的模型需要处理这些状态变量的增量<span class="math inline">\(\delta x_i\)</span>和<span class="math inline">\(\deltax_{i-1}\)</span>。线性化过程后的表达式为：</p><p><span class="math display">\[f_i(x_{i-1}, u_i) - x_i \approx \{ f_i(x_{i-1}^0, u_i) + F_i^{i-1}\delta x_{i-1} \} - \{ x_i^0 + \delta x_i \}\]</span> 要将这个方程转换成标准的线性形式，我们需要确保$ x_i $ 和<span class="math inline">\(\deltax_{i-1}\)</span>在同一方程中有适当的正负号。在这里，引入<span class="math inline">\(G_i^i = -I_{d \times d}\)</span>允许我们将$x_i $项简单地表示为加法形式的负增量，即：</p><p><span class="math display">\[F_i^{i-1} \delta x_{i-1} - \delta x_i = F_i^{i-1} \delta x_{i-1} + G_i^i\delta x_i\]</span> 这样，线性方程更容易处理，因为它将状态变化量<span class="math inline">\(\deltax_i\)</span>直接以线性代数的标准形式表示，允许使用矩阵运算直接进行计算。</p><p><strong>线性最小二乘问题</strong></p><p>通过引入<span class="math inline">\(G_i^i = -I_{d \timesd}\)</span>整个问题可表示为一个标准的线性最小二乘问题：</p><p><span class="math display">\[\delta^* = \underset{\delta}{\operatorname*{argmin}} \left\{\sum_{i=1}^M \| F_i^{i-1} \delta x_{i-1} + G_i^i \delta x_i + a_i\|_{\Lambda_i}^2 + \sum_{k=1}^K \| H_k^{i_k} \delta x_{i_k} + J_k^{j_k}\delta l_{j_k} - c_k \|_{\Sigma_k}^2 \right\}\]</span>这个形式使得应用线性代数和优化方法成为可能，从而可以有效求解大规模SLAM问题。</p><h2 id="信息矩阵i">信息矩阵<span class="math inline">\(I\)</span></h2><p>在机器人定位和地图构建的问题中，通常涉及到估计机器人在环境中的位置轨迹<span class="math inline">\(X\)</span>以及环境本身的结构地图 <span class="math inline">\(L\)</span>。在这种情况下，信息矩阵 <span class="math inline">\(\mathcal{I}\)</span>，也被称为费舍尔信息矩阵，是用来表示这些未知量的不确定性和相互依赖关系的关键工具。</p><p>信息矩阵 <span class="math inline">\(\mathcal{I}\)</span>是由雅可比矩阵 <span class="math inline">\(A\)</span>（或系统的设计矩阵）通过 <span class="math inline">\(A^T A\)</span>计算得到的。这个矩阵可以从以下几个方面描述机器人轨迹和地图内部的信息.</p><ol type="1"><li><strong>量化不确定性:</strong><ul><li>对角线元素：<strong>信息矩阵的对角线元素量化了每个参数（位置或地图特征）的信息量或确信度</strong>。对角线元素的值越大，表示对应参数的不确定性越小，我们对该参数的估计越精确。</li><li>非对角线元素：<strong>非对角线元素描述了参数之间的依赖关系或相关性。</strong>例如，<strong>如果位置<span class="math inline">\(x_i\)</span> 和位置 <span class="math inline">\(x_j\)</span>（或地图特征）在矩阵中的对应元素非零，这表明这两个位置（或特征）的估计值相互依赖</strong>。</li></ul></li><li><strong>编码相关性</strong>:<ul><li>分块 <span class="math inline">\(\mathcal{I}_{XL}\)</span> 和 <span class="math inline">\(\mathcal{I}_{XL}^T\)</span>特别重要，因为它们编码了轨迹 <span class="math inline">\(X\)</span>和地图 <span class="math inline">\(L\)</span>之间的相关性。<strong>这意味着机器人在特定位置的估计如何依赖于地图的特定特征，</strong>反之亦然。这种相关性对于同时定位和地图构建（SLAM）至关重要，因为它帮助系统同时解决导航和地图创建的问题。</li></ul></li><li><strong>优化和解算:</strong><ul><li>在实际应用中，基于信息矩阵的结构，可以采用更有效的数值方法来解决估计问题，<strong>如使用稀疏矩阵技术处理大规模SLAM问题。信息矩阵的稀疏性表明很多参数之间的依赖性较低，这可以大大减少计算量。</strong></li></ul></li></ol><p>信息矩阵 <span class="math inline">\(\mathcal{I}\)</span>不仅提供了对机器人轨迹和地图每一部分的内部信息的详尽描述，而且还通过其结构揭示了不同部分之间的相互作用和依赖性，从而在理论和实践中都是解决SLAM问题的核心部分。</p><p>矩阵 <span class="math inline">\(\mathcal{I}\)</span> 是通过矩阵<span class="math inline">\(A\)</span> 的转置乘以 <span class="math inline">\(A\)</span> 计算得到的，这里 <span class="math inline">\(A\)</span> 被分为两部分：对应于机器人轨迹 <span class="math inline">\(X\)</span> 的 <span class="math inline">\(A_X\)</span> 和对应于地图 <span class="math inline">\(L\)</span> 的 <span class="math inline">\(A_L\)</span>。</p><p>矩阵 <span class="math inline">\(\mathcal{I}\)</span>的结构表明它分为四个部分：</p><ol type="1"><li><span class="math inline">\(A_X^TA_X\)</span>：这是左上角的块，代表轨迹 <span class="math inline">\(X\)</span> 内部的信息。</li><li><span class="math inline">\(A_L^TA_L\)</span>：这是右下角的块，代表地图 <span class="math inline">\(L\)</span> 内部的信息。</li><li><span class="math inline">\(\mathcal{I}_{XL}\)</span> 和 <span class="math inline">\(\mathcal{I}_{XL}^T\)</span>：这两个块分别位于非对角线的位置，<span class="math inline">\(\mathcal{I}_{XL} \triangleq A_X^T A_L\)</span>和其转置表示轨迹 <span class="math inline">\(X\)</span> 和地图 <span class="math inline">\(L\)</span> 之间的相关性。</li></ol><p><span class="math display">\[\mathcal{I}_{XL} \triangleq A_X^T A_L\]</span></p><p>表示的是 <span class="math inline">\(A_X\)</span> 和 <span class="math inline">\(A_L\)</span> 之间的交叉信息，它编码了机器人状态<span class="math inline">\(X\)</span> 和地图 <span class="math inline">\(L\)</span> 之间的相关性。对角线块 <span class="math inline">\(A_X^T A_X\)</span> 和 <span class="math inline">\(A_L^T A_L\)</span>表明它们是“带对角线”的，这通常意味着这些块主要关注各自的内部结构和相互作用，而不是外部的。</p><p>关于信息矩阵和残差</p><p>标准化残差考虑到了模型和观测的不确定性，这种不确定性可以通过残差的协方差矩阵来量化，而这个协方差矩阵的估计依赖于参数的协方差矩阵，即信息矩阵的逆。因此，信息矩阵I通过其逆的形式，直接影响到标准化残差的计算，特别是在决定各残差分量的权重时。</p><h2 id="关于ax-b-中a和b的物理意义">关于AX-b 中A和b的物理意义</h2><p>在SLAM问题中，机器人的动态与环境交互通过一系列的状态转移和观测更新来描述。<strong>矩阵<span class="math inline">\(A\)</span>在这个问题中的作用，是将这些动态和交互的关系转化为数学形式，特别是以线性化的方式来近似非线性系统的行为。</strong></p><p><strong>矩阵 <span class="math inline">\(A\)</span>的意义：</strong></p><ol type="1"><li>物理意义：矩阵 <span class="math inline">\(A\)</span>表示系<strong>统状态变量之间的关系，以及状态变量与观测之间的线性关系。</strong>具体来说：<ul><li>运动模型部分：矩阵<span class="math inline">\(F_i^{i-1}\)</span> 和<span class="math inline">\(G_i^i\)</span> 表示从状态 <span class="math inline">\(x_{i-1}\)</span>到状态 <span class="math inline">\(x_i\)</span>的线性化运动模型。这些块表示了机器人如何从一个位置或方向移动到下一个位置，通常基于机器人的控制指令如转向和前进。描绘了状态之间的转移关系。</li><li>观测模型部分：矩阵 <span class="math inline">\(H_k^{i_k}\)</span>)和<span class="math inline">\(J_k^{j_k}\)</span> 表示状态 <span class="math inline">\(x_{i_k}\)</span>)和地标 <span class="math inline">\(l_{j_k}\)</span>)如何影响第 <span class="math inline">\(k\)</span>次观测。这反映了如何从当前状态和地标位置预测观测值例如，从摄像头或激光雷达。通过<span class="math inline">\(H_k^{i_k}\)</span> 和 <span class="math inline">\(J_k^{j_k}\)</span>描述的块，这些块表明如何从当前的状态和地标位置预测可能的观测结果 <span class="math inline">\(z_k\)</span>。</li></ul></li></ol><p><strong>向量 <span class="math inline">\(b\)</span></strong>：向量<span class="math inline">\(b\)</span>通常<strong>包含观测数据与由模型预测的状态转移或观测的差异</strong>。在SLAM中，<span class="math inline">\(b\)</span> 可能由实际观测值 <span class="math inline">\(z_k\)</span>减去根据当前状态估计和地标估计得到的预测观测值构成。</p><p>计算意义：在最优化问题中，我们通常求解最小化 <span class="math inline">\((|A\delta -b|_2^2)\)</span>，这是一个最小二乘问题，意味着我们在寻找最佳的状态变量更新(<span class="math inline">\(\delta\)</span>)，使得线性化模型的预测尽可能接近实际观测和运动指令的结果。</p><p><strong>为什么 <span class="math inline">\(A\)</span>重要：</strong></p><ul><li>(<span class="math inline">\(A\)</span>)矩阵<strong>捕捉了机器人动态和环境的整体结构，</strong>这是理解和解决SLAM问题的核心。正确构建和更新这个矩阵对于准确地估计机器人的状态和地图至关重要。</li><li>矩阵的稀疏性表明大多数状态变量不直接相互影响，这在数值计算上是有利的。稀疏矩阵技术可以显著提高求解SLAM问题的效率。</li></ul><p>因此，矩阵A通过其块状结构和各个元素，捕捉了机器人如何移动（动态）和如何观察周围环境（观测）的数学描述。这不仅包括了机器人状态的转移关系，还包括了状态与环境地标之间的相互作用。通过优化问题最小化$|A-b|_2^2$，我们实际上是在调整对机器人状态和地图的估计，使得这些线性化的预测尽可能贴近实际观测，从而实现同时定位与地图构建的目的。</p><p>在SLAM问题中，矩阵 <span class="math inline">\(A\)</span> 和向量<span class="math inline">\(b\)</span>的物理意义及其在优化问题中的作用是核心部分，反映了状态估计的数学模型与实际操作间的联系:</p><p><strong>最小化正规方程 <span class="math inline">\(A^T A x = A^Tb\)</span></strong></p><p>在SLAM问题的线性化模型中，我们通常希望找到一个状态变量的更新量 <span class="math inline">\(\delta\)</span>，使得模型预测尽可能贴近实际的观测。具体来说，我们尝试最小化以下目标函数：</p><p><span class="math display">\[\| A \delta - b \|_2^2\]</span></p><ul><li><span class="math inline">\(|\cdot|_2^2\)</span>表示二范数的平方，用于度量误差的大小。</li><li><span class="math inline">\(A \delta\)</span>表示对当前状态估计的改正（或更新）。</li><li><span class="math inline">\(b\)</span>是观测数据与模型预测之间的差异。</li></ul><p>解决这个最小化问题通常涉及到求解正规方程：</p><p><span class="math display">\[A^T A \delta = A^T b\]</span></p><ul><li><span class="math inline">\(A^T A\)</span>是一个方阵，通常更易于处理，尤其是当 <span class="math inline">\(A\)</span>是稀疏或结构化的时，这种方法效率更高。</li><li><span class="math inline">\(A^T b\)</span>是一个向量，表示在当前误差度量下，最佳更新方向的投影。</li></ul><p>通过最小化这个误差，我们在数学上是在寻找一个向量 <span class="math inline">\(\delta\)</span>，使得 <span class="math inline">\(A \delta\)</span> 尽可能接近 <span class="math inline">\(b\)</span>，即尝试对预测的状态和观测进行校正，以逼近真实的观测值。</p><h2 id="滤波器与平滑器">滤波器与平滑器</h2><p>在SLAM（Simultaneous Localization andMapping，即同时定位与建图）问题中，信息矩阵 (I)是一个关键的概念，用于表示机器人的状态（如位置和方向）以及环境中地标的不确定性。信息矩阵是协方差矩阵的逆，其中每个元素反映了状态变量之间的条件依赖性。在SLAM中，主要有两种处理信息的方法：滤波和平滑。</p><h3 id="滤波">滤波</h3><p><strong>滤波</strong>是一种在线处理方式，即它只处理当前和过去的信息，通常用于实时系统中。在滤波过程中，随着新数据的持续加入，为了维持计算的可管理性，旧的数据或状态往往需要被边缘化（移除），这导致信息矩阵趋向于变得密集。</p><ul><li>在滤波过程中，为了保持计算的实时性和可管理性，通常只会保留当前状态的信息，而把旧的状态信息“边缘化”（即从当前考虑的状态集中移除）。<strong>这种边缘化过程会引入额外的非零元素到信息矩阵中，因为边缘化旧状态意味着需要将这些状态的信息“分摊”到剩余的状态上</strong>。结果是信息矩阵变得密集，即使原来很多状态之间是条件独立的。</li><li>为了处理这种密集化，研究者通常会采用各种技术（如稀疏化技术）来移除信息矩阵中的某些链接，以减少计算负担。</li></ul><blockquote><p>解释为什么在SLAM中进行滤波操作时，边缘化过去的状态会导致信息矩阵变得密集。</p></blockquote><h4 id="示例情景"><strong>示例情景</strong></h4><p>假设一个机器人在一个简单的环境中沿直线移动，每移动一段距离记录一次位置，形成状态序列<span class="math inline">\(X_1, X_2, X_3, \ldots,X_t\)</span>。每个状态都与其前后状态有直接的连接（例如通过里程计测量），并可能与环境中的某些地标有关联。</p><p>在开始，信息矩阵 (I)是稀疏的，因为只有时间上相邻的状态或与某个地标直接相关的状态之间存在连接。例如，如果(X_1)和(X_2)通过里程计相关联，那么在信息矩阵中，<span class="math inline">\(I_{1,1}，I_{1,2}，和I_{2,2}\)</span>是非零的。</p><h4 id="边缘化过程"><strong>边缘化过程</strong></h4><p>当机器人继续前进并且需要在滤波器中处理新的状态时（比如(X_{t+1})），为了保持计算的可管理性，较早的状态（比如(X_1))可能会被边缘化掉。边缘化(X_1)意味着我们需要从当前激活的状态集中移除(X_1)的影响。</p><ul><li>原本(X_1)直接影响(X_2)，在边缘化(X_1)后，我们必须将(X_1)对(X_2)的影响“转移”给与(X_2)相关的其他状态，比如(X_3)。这意味着原先(X_1)与(X_3)可能没有直接关系，但在边缘化(X_1)后，(X_2)与(X_3)之间的关系需要加强，以反映从(X_1)到(X_3)的间接影响。</li></ul><p>当我们在状态估计或者滤波问题中进行边缘化时，我们的目标是将某些状态（例如<span class="math display">\[X_1\]</span>）的影响通过与其相关联的其他状态（如<span class="math display">\[X_2\]</span> 和 <span class="math display">\[X_3\]</span>）重新表达，而不是直接包括这些状态。这个过程在信息矩阵（或费舍尔信息矩阵）中的表示可以通过一个具体的数学过程来阐述。</p><p>假设我们的系统的信息矩阵 <span class="math display">\[\mathcal{I}\]</span> 分布如下，其中包含三个状态<span class="math display">\[X_1\]</span>, <span class="math display">\[X_2\]</span>, 和 <span class="math display">\[X_3\]</span>： <span class="math display">\[\mathcal{I} = \begin{bmatrix}\mathcal{I}_{11} &amp; \mathcal{I}_{12} &amp; \mathcal{I}_{13} \\\mathcal{I}_{21} &amp; \mathcal{I}_{22} &amp; \mathcal{I}_{23} \\\mathcal{I}_{31} &amp; \mathcal{I}_{32} &amp; \mathcal{I}_{33}\end{bmatrix}\]</span> 在这里，<span class="math display">\[\mathcal{I}_{ij}\]</span>表示状态 <span class="math display">\[X_i\]</span> 和状态 <span class="math display">\[X_j\]</span> 之间的信息量。</p><p>当我们决定边缘化状态 <span class="math display">\[X_1\]</span>，我们需要消除 <span class="math display">\[X_1\]</span> 的影响，并将其影响“转移”到与 <span class="math display">\[X_1\]</span> 相关的其他状态，比如 <span class="math display">\[X_2\]</span> 和 <span class="math display">\[X_3\]</span>。边缘化 <span class="math display">\[X_1\]</span> 的信息矩阵可以通过 Schur 补数得到：<span class="math display">\[\mathcal{I}_{\text{marginal}} = \mathcal{I}_{22:33} -\mathcal{I}_{21:31}^T \mathcal{I}_{11}^{-1} \mathcal{I}_{21:31}\]</span> 其中：</p><ul><li><span class="math display">\[\mathcal{I}_{22:33}\]</span> 表示除去与<span class="math display">\[X_1\]</span>相关的行和列后剩余的信息矩阵部分。</li><li><span class="math display">\[\mathcal{I}_{21:31}\]</span> 表示与<span class="math display">\[X_1\]</span>相关的其它状态的交叉信息块。</li></ul><p>假设原信息矩阵的块为： <span class="math display">\[\mathcal{I}_{11} = \begin{bmatrix}2\end{bmatrix}, \quad \mathcal{I}_{21:31} = \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix}, \quad \mathcal{I}_{22:33} = \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix}\]</span></p><p>进行计算： <span class="math display">\[\mathcal{I}_{\text{marginal}} = \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix} - \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix} \begin{bmatrix}2\end{bmatrix}^{-1} \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix} = \begin{bmatrix}0 &amp; 0 \\0 &amp; 0\end{bmatrix}\]</span></p><p>这个简化例子说明了如何通过矩阵运算处理边缘化。实际应用中，这个过程将导致<span class="math display">\[\mathcal{I}_{22:33}\]</span>的非对角线元素变得非零，表明 <span class="math display">\[X_2\]</span>和 <span class="math display">\[X_3\]</span>之间的新建立的依赖关系。这反映了从 <span class="math display">\[X_1\]</span> 到 <span class="math display">\[X_3\]</span> 的间接影响，即使在原始矩阵中 <span class="math display">\[X_2\]</span> 和 <span class="math display">\[X_3\]</span>之间没有直接的依赖关系。随着更多状态的边缘化，信息矩阵将变得更加密集，反映出复杂的依赖关系网络。</p><h4 id="结果"><strong>结果</strong></h4><p>这个转移过程在信息矩阵中表现为原先为零的元素变成非零，因为(X_2)和(X_3)现在有了新的依赖关系。随着越来越多状态的边缘化，这种间接依赖会累积，导致信息矩阵逐渐从稀疏变为密集。</p><h4 id="几何直观"><strong>几何直观</strong></h4><p>可以想象，每个状态不仅与其直接的邻居有联系，还因为边缘化而与更多其他状态产生了联系。随着时间的推移，几乎每个状态都以某种方式间接地与其他所有状态连接，从而增加了信息矩阵中的非零元素数量，使矩阵变得密集。</p><p>这种密集化不仅增加了计算的复杂度，还可能影响滤波器的性能，因此在实际应用中，开发者会寻找各种方法（例如使用稀疏近似或选择性地保留关键状态）来尽可能减少这种影响。</p><h3 id="平滑">平滑</h3><p><strong>平滑</strong>则是一种离线处理方式，它考虑全部的数据（包括过去和未来的数据）。在平滑处理中，由于不需要边缘化任何状态（因为所有状态对计算都是可用的），所以关联的信息矩阵维持稀疏性，这是因为不存在需要通过边缘化引入新依赖的需求。</p><ul><li>平滑处理，相比于滤波，不会边缘化任何过去的状态。相反，它保留了所有历史和当前的状态信息，因此可以在整个时间线上提供更精确的状态估计。</li><li>在<strong>平滑方法中，由于不进行边缘化操作，所以不会引入额外的非零元素导致信息矩阵密集化。这意味着信息矩阵能够保持其原始的稀疏结构，其中非零元素主要集中在时间线上相邻状态之间的依赖关系。</strong>这种稀疏性是因为在大多数SLAM场景中，只有时间上相邻的状态或空间上邻近的地标才具有直接的相互依赖。</li></ul><p>因此，在与平滑信息矩阵 (I)关联的MRF中，信息矩阵保持稀疏，<strong>主要是因为平滑处理不涉及边缘化过去的状态</strong>。这样，每个状态只与其直接相关的少数几个其他状态或地标相关联，而不是与整个历史状态集相关联，从而避免了矩阵的密集化。这种方法不仅保持了计算效率，而且通常能提供比滤波更为精确的状态估计。</p><p>用一个具体的数学例子来解释SLAM问题中平滑方法的信息矩阵是如何维持其稀疏性的。在这个例子中，我们考虑一个小规模的机器人轨迹，其中机器人在四个时间点上测量其位置。我们将看到在不进行边缘化的情况下，信息矩阵如何保持其结构。</p><p>假设有四个状态<span class="math inline">\(X_1, X_2, X_3,X_4\)</span>，它们代表机器人在四个连续时间点的位置。在SLAM中，通常只有连续的状态之间存在直接的测量依赖关系。</p><p>在平滑方法中，信息矩阵I初始化时将反映状态之间的这些直接依赖关系。例如，如果我们假设每个状态只与其前后状态有关系，并且每个这样的依赖对信息矩阵贡献(1) 的信息值，那么信息矩阵可能看起来像这样：</p><p><span class="math display">\[I = \begin{bmatrix}1 &amp; -1 &amp; 0 &amp; 0 \\-1 &amp; 2 &amp; -1 &amp; 0 \\0 &amp; -1 &amp; 2 &amp; -1 \\0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\]</span> 这里，对角线上的元素 (2)表示一个状态依赖于其前后状态的信息总和（除了边界条件，即 (X_1) 和(X_4)）。非对角线的 (-1) 表示状态 (X_i) 与 (X_{i+1}) 和 (X_{i-1})之间的信息依赖。</p><p>在平滑方法中，由于不进行边缘化操作，<strong>我们保留所有历史状态的数据。这意味着在任何给定的时刻，我们都可以访问到所有历史和未来的状态信息，而不是只有当前和未来的状态</strong>。因此，信息矩阵的非零结构不会改变——它始终保持与初始时刻相同的稀疏模式。</p><p>这种方法的优点是，信息矩阵维持了其稀疏性，这大大减少了计算的复杂性和内存需求。例如，当使用稀疏矩阵技术处理大型SLAM问题时，这一特性非常重要。每个状态只与直接相邻的状态有关系，没有因边缘化而引入的额外复杂依赖关系。</p><p>这样的稀疏结构是高效处理大规模SLAM问题的关键，因为它减少了必须处理的数据量，并允许使用优化的数值方法来处理信息矩阵。</p><h3 id="为什么在平滑中仍然会有变量消除"><strong>为什么在平滑中仍然会有变量消除</strong></h3><p>尽管在平滑处理中，信息矩阵维持其稀疏性质，我们仍可能需要执行某种形式的变量消除，这主要是为了效率和算法实现上的考虑。例如，在求解线性系统时（如<span class="math display">\[Ax =b\]</span>），通常会采用一些数学技术来简化问题，比如通过Cholesky分解等。在这个过程中，创建弦图和消元树是为了优化这些数学操作：</p><ol type="1"><li><p><strong>弦图的创建</strong>：在进行Cholesky分解等操作前，弦图能帮助我们识别并利用信息矩阵的稀疏结构，以减少计算过程中的填充（非零元素的添加）。</p></li><li><p><strong>消元树的建立</strong>：即便信息矩阵是稀疏的，构建消元树可以进一步提高解线性系统的效率。消元树能够指导计算顺序，确保依赖关系得到正确处理，并优化内存访问模式。</p></li></ol><p>因此，尽管平滑信息矩阵在理论上不需要通过边缘化来维护其稀疏性，但在实际计算和算法实现中，变量消除和相关的图形表示（如弦图和消元树）仍然是优化性能和保证算法效率的重要工具。</p><h3 id="消元树">消元树</h3><p>消元树是一种用来表示消除过程中变量依赖关系的树状结构，它帮助指导了矩阵分解过程中的计算流程，特别是在反向替代阶段。这里用一个具体的例子来说明这一点：</p><p>假设我们有一个系统的矩阵 <span class="math display">\[A\]</span>，我们想要进行Cholesky分解（假设<span class="math display">\[A\]</span>是对称正定的）。我们首先选择一个变量来消除，这通常是基于某种启发式方法，比如最小填充法或最小度法。</p><p>考虑以下矩阵：</p><p><span class="math display">\[A = \begin{bmatrix}4 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 4 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 4 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 3 \\\end{bmatrix}\]</span></p><p><strong>第一步：消除第一个变量</strong></p><p>我们首先消除第一个变量，这会影响与它直接相连的变量（这里是第二个变量）。消除第一个变量后，更新矩阵（做适当的行和列操作）可能会导致非零元素填充原本为零的位置，即产生“填充”。</p><p><strong>弦图的形成</strong></p><p>在这个过程中，如果我们将每个变量和与它相邻的变量视为图的一个节点和边，消除一个变量相当于在图中移除一个节点及其相关的边，并可能在未被消除的相邻节点间添加新的边（如果它们之前不直接相连）。这个操作最终形成了一个弦图，即每个循环都至少有一个弦（非环的边）的图。</p><p><strong>构建消元树</strong></p><p>在构建弦图的基础上，消元树被定义为消除过程中的依赖关系图。例如：</p><ol type="1"><li>将第一个被消除的变量作为树的根节点。</li><li>每次消除一个变量后，将受到影响的变量作为当前消除变量的子节点添加到树中。</li></ol><p>对于上面的矩阵，消元树可能如下：</p><ul><li>根节点为第一个被消除的变量。</li><li>第二个被影响的变量成为第一个节点的子节点。</li><li>依次类推，直到所有变量都被放置在树中。</li></ul><p><strong>在反向替代阶段的作用</strong></p><p>在进行例如Cholesky分解后，求解线性系统 <span class="math display">\[Ax = b\]</span> 需要先进行前代（使用 <span class="math display">\[L\]</span> 矩阵）和后代（使用 <span class="math display">\[L^T\]</span>矩阵）。在后代过程中，消元树指导了计算的顺序：从树的叶子（最先消除的变量）开始，逐步向根节点（最后消除的变量）进行，确保在计算当前变量值之前，所有依赖于它的变量值已经被计算。</p><p>通过这种方式，消元树不仅帮助优化计算过程，还确保了在计算过程中遵循正确的依赖关系，有效地利用了矩阵的稀疏性质。</p><h2 id="qr分解">QR分解</h2><p>QR 分解是将矩阵 <span class="math display">\[A\]</span>分解成一个正交矩阵 <span class="math display">\[Q\]</span>和一个上三角矩阵 <span class="math display">\[R\]</span> 的方法。如果<span class="math display">\[A\]</span> 是一个 <span class="math display">\[m \times n\]</span> 矩阵且 <span class="math display">\[m \geq n\]</span>，那么分解形式通常写为：</p><p><span class="math display">\[A = QR\]</span></p><p>其中，<span class="math display">\[Q\]</span> 是一个 <span class="math display">\[m \times m\]</span> 正交矩阵（<span class="math display">\[Q^T Q = QQ^T = I\]</span>），<span class="math display">\[R\]</span> 是一个 <span class="math display">\[m\times n\]</span> 的上三角矩阵，其中除了前 <span class="math display">\[n\]</span>行可能有非零元素外，其余部分全为零。在许多实际情况中，我们更关心 <span class="math display">\[R\]</span> 的前 <span class="math display">\[n\times n\]</span> 部分，因为它是一个完全的上三角矩阵。</p><p>为什么 <span class="math display">\[R\]</span> 下面有一个0</p><p>在 <span class="math display">\[Q^T A = \left[\begin{array}{c} R \\ 0\end{array}\right]\]</span> 的表达式中，<span class="math display">\[R\]</span> 是 <span class="math display">\[n\times n\]</span> 的上三角矩阵，而下面的0表示在 <span class="math display">\[Q^T\]</span> 作用后，剩下 <span class="math display">\[m-n\]</span> 行都被消减到了零。这是因为 <span class="math display">\[Q\]</span> 通过正交变换将 <span class="math display">\[A\]</span> 的所有向量投影到一个由 <span class="math display">\[A\]</span> 的列空间张成的正交子空间。</p><p>如何进行QR分解</p><p>QR分解可以通过多种方式进行，包括Householder反射、Gram-Schmidt正交化或Givens旋转等。其中，Householder反射是最常用的方法，因为它具有很好的数值稳定性。</p><p>Householder反射:</p><ol type="1"><li>选取一个列向量，构造一个反射矩阵 <span class="math display">\[H\]</span>，使得除了第一项外，该列的其余项变为零。</li><li>重复应用上述过程，每次将 <span class="math display">\[A\]</span>的一个列向量（逐步从左到右）变为期望的上三角形式。</li><li>通过连续左乘不同的Householder矩阵（<span class="math display">\[H_1,H_2, \ldots, H_n\]</span>），我们最终得到 <span class="math display">\[Q^T A = \left[\begin{array}{c} R \\ 0\end{array}\right]\]</span>。</li></ol><p>QR分解在最小二乘中的应用</p><p>在最小二乘问题中，我们通常要最小化 <span class="math display">\[\|A\delta -b\|_2^2\]</span>。通过QR分解，我们可以转化这个问题为：</p><p><span class="math display">\[\|Q^T(A\delta - b)\|_2^2 = \|R\delta -Q^Tb\|_2^2\]</span></p><p>由于 <span class="math display">\[Q\]</span>是正交的，所以转换不会改变二范数。因此，问题简化为最小化 <span class="math display">\[\|R\delta - d\|_2^2\]</span>（其中 <span class="math display">\[d\]</span> 是 <span class="math display">\[Q^Tb\]</span> 的前 <span class="math display">\[n\]</span> 个元素）加上 <span class="math display">\[\|e\|_2^2\]</span>（其中 <span class="math display">\[e\]</span> 是 <span class="math display">\[Q^Tb\]</span> 的剩余 <span class="math display">\[m-n\]</span> 个元素，代表方程的残差）。</p><p>由于 <span class="math display">\[R\]</span>是上三角的，这个问题可以通过反向替换直接求解 <span class="math display">\[R\delta = d\]</span>，从而找到最小二乘解 <span class="math display">\[\delta^*\]</span>。</p><h2 id="为什么用cholesky-分解求解正规方程">为什么用Cholesky分解求解正规方程</h2><p><strong>为什么使用 Cholesky 分解？</strong></p><ol type="1"><li><p><strong>效率和稳定性</strong>：</p><p>​<strong>效率</strong>：Cholesky分解相比于其他方法（如LU分解或QR分解）通常更为高效。它的计算复杂度大约是<span class="math display">\[\frac{1}{3} n^3\]</span> 对于 <span class="math display">\[n \times n\]</span>矩阵，而LU分解和QR分解的计算复杂度分别大约是 <span class="math display">\[\frac{2}{3} n^3\]</span> 和 <span class="math display">\[2n^3\]</span>。这使得Cholesky分解成为求解大型正定线性系统的首选方法。</p><p>​<strong>稳定性</strong>：对于对称正定矩阵，Cholesky分解非常稳定。由于对称性和正定性保证了分解的成功执行，它避免了在数值分解过程中的潜在不稳定性。</p></li><li><p><strong>数值属性</strong>：</p><p>​在数值线性代数中，Cholesky分解对于对称正定矩阵来说是一种数值上稳定的方法，特别是当矩阵<span class="math display">\[A^T A\]</span>的条件数相对较低时。这是因为它直接利用了矩阵的对称性和正定性。</p></li><li><p><strong>简化求解过程</strong>：</p><p>​ 通过Cholesky分解，矩阵 <span class="math display">\[A^T A\]</span>被分解为一个下三角矩阵 <span class="math display">\[L\]</span>和其转置的上三角矩阵 <span class="math display">\[L^T\]</span>的乘积，即 <span class="math display">\[A^T A = LL^T\]</span>。这种分解简化了线性系统的求解，因为只需先解下三角系统 <span class="math display">\[L \mathbf{y} = A^T \mathbf{b}\]</span>获得临时向量 <span class="math display">\[\mathbf{y}\]</span>，然后解上三角系统 <span class="math display">\[L^T \mathbf{x} = \mathbf{y}\]</span> 获取最终解<span class="math display">\[\mathbf{x}\]</span>。</p><p>​这种分步求解的过程比直接求解原方程更易于处理，并且可以有效地利用现代计算机体系结构。</p></li></ol><p><strong>总结</strong></p><p>由于上述优点，Cholesky分解成为解决正定线性系统（特别是在涉及正规方程时）的理想选择，提供了一种高效、稳定的方法来求解最小二乘问题中的线性系统。这在实际应用中，如图优化、信号处理、统计数据分析等领域，具有广泛的应用。</p><h2 id="一些相关链接-不定时更新">一些相关链接 不定时更新</h2><h3 id="可以关注的blog-多源融合">可以关注的blog 多源融合</h3><p><a href="https://www.zhihu.com/people/Welson-WEN/posts">Welson WEN -知乎 (zhihu.com)</a></p><h3 id="理论学习">理论学习</h3><h4 id="滤波优化算法">滤波优化算法</h4><p><a href="https://zhuanlan.zhihu.com/p/85865058">卡尔曼滤波：究竟滤了谁？</a></p><p><a href="https://www.zhihu.com/question/23971601/answer/770830003">关于卡尔曼滤波如何通俗并尽可能详细地解释卡尔曼滤波？ - 司南牧(李韬)的回答 -知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/76659512">SLAM找工作1.6因子图优化（蜘蛛） - 知乎 (zhihu.com)</a></p><p><a href="https://chargerkong.github.io/2021/05/26/%E5%9B%BE%E4%BC%98%E5%8C%96%EF%BC%88Graph-based%EF%BC%89/">个人github的blog估计是大学生 写得还不错</a></p><p><a href="https://zhuanlan.zhihu.com/p/404893786">GraphGNSSLib:基于因子图技术的GNSS定位和GNSS RTK定位算法</a></p><p><a href="https://www.guyuehome.com/18321">SLAM14讲学习笔记（七）后端（BA与图优化，PoseGraph优化的理论与公式详解、因子图优化）</a></p><p><a href="https://longaspire.github.io/blog/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BB%8B%E7%BB%8D/#1-%E5%9B%A0%E5%AD%90%E5%9B%BE%E5%AE%9A%E4%B9%89">因子图介绍YOLO</a></p><p><a href="https://ieeexplore.ieee.org/abstract/document/910572">因子图和求和乘积算法|IEEE期刊和杂志 |IEEE Xplore（IEEE的Xplore）</a></p><p><a href="https://blog.csdn.net/shyjhyp11/article/details/126938728">SLAM算法-因子图建模</a></p><p><a href="https://blog.csdn.net/tfb760/article/details/127118096">学习随笔：机器人感知-因子图在SLAM中的应用</a></p><p><a href="https://zhuanlan.zhihu.com/p/616060837">SLAM中后端优化的技术细节</a></p><p><a href="https://zhuanlan.zhihu.com/p/128720019">干货：因子图优化的资源合集算法发展脉络</a></p><p><a href="https://blog.51cto.com/u_16213565/7964103">计算机视觉教材</a></p><p><a href="https://zhuanlan.zhihu.com/p/30139208">概率图模型之贝叶斯网络</a></p><p><a href="https://blog.csdn.net/ljtx200888/article/details/114164685">csdn：SLAM后端：因子图优化</a></p><p><a href="https://zhuanlan.zhihu.com/p/455851874">知乎：三.因子图优化学习---董靖博士在泡泡实验室的公开课学习</a></p><p><a href="https://zhuanlan.zhihu.com/p/451555685">知乎：一.因子图优化学习---董靖博士在深蓝学院的公开课学习（1）</a></p><p><a href="https://www.bilibili.com/video/BV16p4y1U7gW/?spm_id_from=333.999.0.0&amp;vd_source=3cd19ffad1cc348f3d6969346e07e84c">贝叶斯派的概率图模型讲解概述</a></p><h3 id="代码编程">代码编程</h3><h4 id="gtsam库">GTSAM库</h4><p><a href="https://xiaotaoguo.com/">自动驾驶 C++相关</a></p><p>[<a href="https://xiaotaoguo.com/p/gtsam-usage-2/">[代码实践] GTSAM学习记录（二）]</a></p><p><a href="https://www.helywin.com/posts/20220321115224/#:~:text=%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%E7%9A%84%E5%9B%A0%E5%AD%90%E5%9B%BE%E5%A6%82%E5%9B%BE3%E6%89%80%E7%A4%BA%E3%80%82%20%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F%24x_1%24%EF%BC%8C%24x_2%24%E5%92%8C%24x_3%24%E4%BB%A3%E8%A1%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%9A%8F%E6%97%B6%E9%97%B4%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E5%9C%A8%E5%9B%BE%E4%B8%AD%E7%94%B1%E5%BC%80%E5%9C%86%E7%9A%84%E5%8F%98%E9%87%8F%E8%8A%82%E7%82%B9%E5%91%88%E7%8E%B0%E3%80%82%20%E5%9C%A8%E8%AF%A5%E4%BE%8B%E5%AD%90%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A7%BF%E6%80%81%24x_1%24%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%E4%B8%80%E5%85%83%E5%9B%A0%E5%AD%90%24f_0%20%28x_1%29%24%EF%BC%8C%E7%BC%96%E7%A0%81%E6%88%91%E4%BB%AC%E5%85%B3%E4%BA%8E%24x_1%24%E7%9A%84%E5%85%88%E9%AA%8C%E7%9F%A5%E8%AF%86%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%BA%8C%E5%85%83%E5%9B%A0%E5%AD%90%E5%B0%86%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%A7%BF%E6%80%81%E8%81%94%E7%B3%BB%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%24f_1%20%28x_1%2C%20x_2%20%3B%20o_1%29%24%E5%92%8C%24f_2,x_3%20%3B%20o_2%29%24%EF%BC%8C%E5%85%B6%E4%B8%AD%24o_1%24%E5%92%8C%24o_2%24%E4%BB%A3%E8%A1%A8%E9%87%8C%E7%A8%8B%E6%B5%8B%E9%87%8F%E5%80%BC%E3%80%82%20%E4%B8%8B%E9%9D%A2%E7%9A%84C%2B%2B%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8C%85%E5%90%AB%E5%9C%A8GTSAM%E4%B8%AD%E4%BD%9C%E4%B8%BA%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%BA%86%E5%9B%BE3%E4%B8%AD%E7%9A%84%E5%9B%A0%E5%AD%90%E5%9B%BE%EF%BC%9A%20%E4%B8%8A%E9%9D%A2%EF%BC%8C%E7%AC%AC2%E8%A1%8C%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84%E5%9B%A0%E5%AD%90%E5%9B%BE%E3%80%82%20%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E7%AC%AC5-8%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%9B%A0%E5%AD%90%24f_0%20%28x_1%29%24%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%9C%A8slam%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%2A%2A%20%E3%80%82">因子图和GTSAM--实践介绍—个人blog含代码讲解</a></p><p><a href="https://zhuanlan.zhihu.com/p/543465483">Factor Graphs andGTSAM</a></p><p><a href="https://zhuanlan.zhihu.com/c_1025765837919113216">因子图优化slam找工作</a></p><h4 id="代码能力">代码能力</h4><p><a href="https://xiaotaoguo.com/">自动驾驶 C++相关</a></p><p><a href="https://zhuanlan.zhihu.com/c_1025765837919113216">因子图优化slam找工作</a></p><p>https://www.zhihu.com/people/mach999/posts</p>]]></content>
      
      
      <categories>
          
          <category> 导航学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 因子图 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
