<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta name="referrer" content="no-referrer"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>因子图优化相关问题 | 汐汐的成长之路</title><meta name="author" content="汐汐"><meta name="copyright" content="汐汐"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="因子图优化相关问题  🌞这篇blog主要是记录毕设一些因子图相关的问题 不太好手动理解的点 主要途径就是通过看论文 还有gpt搜集到的一些理解的东西 记录一下  为什么用联合概率密度来描述导航问题 解释1 在导航和其他机器人感知系统中，状态估计问题经常涉及位置X，地图L和观测数据Z的不确定性。利用联合概率密度函数来表示这些变量，可以系统地包含所有相关的不确定性和依赖关系，从而使得可以进行精确的推">
<meta property="og:type" content="article">
<meta property="og:title" content="因子图优化相关问题">
<meta property="og:url" content="https://www.lling.online/2024/05/04/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="汐汐的成长之路">
<meta property="og:description" content="因子图优化相关问题  🌞这篇blog主要是记录毕设一些因子图相关的问题 不太好手动理解的点 主要途径就是通过看论文 还有gpt搜集到的一些理解的东西 记录一下  为什么用联合概率密度来描述导航问题 解释1 在导航和其他机器人感知系统中，状态估计问题经常涉及位置X，地图L和观测数据Z的不确定性。利用联合概率密度函数来表示这些变量，可以系统地包含所有相关的不确定性和依赖关系，从而使得可以进行精确的推">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.lling.online/img/top-img/001%20FGO%20question.png">
<meta property="article:published_time" content="2024-05-04T09:04:56.580Z">
<meta property="article:modified_time" content="2024-05-25T13:48:57.967Z">
<meta property="article:author" content="汐汐">
<meta property="article:tag" content="因子图">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.lling.online/img/top-img/001%20FGO%20question.png"><link rel="shortcut icon" href="/img/xix.png"><link rel="canonical" href="https://www.lling.online/2024/05/04/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e588f3c6266a7f7c4936775cbf8be029";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="/styles/font.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '因子图优化相关问题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-25 21:48:57'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/styles/main.css"><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><link rel="stylesheet" href="/styles/icon.css"><link rel="stylesheet" href="/styles/font.css"><meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/miao.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top-img/001%20FGO%20question.png')"><nav id="nav"><span id="blog-info"><a href="/" title="汐汐的成长之路"><img class="site-icon" src="/img/miao.png"/><span class="site-name">汐汐的成长之路</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">因子图优化相关问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-04T09:04:56.580Z" title="发表于 2024-05-04 17:04:56">2024-05-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-25T13:48:57.967Z" title="更新于 2024-05-25 21:48:57">2024-05-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AF%BC%E8%88%AA%E5%AD%A6%E4%B9%A0/">导航学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>77分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="因子图优化相关问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="因子图优化相关问题">因子图优化相关问题</h1>
<blockquote>
<p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>这篇blog主要是记录毕设一些因子图相关的问题
不太好手动理解的点 主要途径就是通过看论文 还有gpt搜集到的一些理解的东西
记录一下</p>
</blockquote>
<h2 id="为什么用联合概率密度来描述导航问题">为什么用联合概率密度来描述导航问题</h2>
<h3 id="解释1">解释1</h3>
<p>在导航和其他机器人感知系统中，状态估计问题经常涉及位置X，地图L和观测数据Z的不确定性。<strong>利用联合概率密度函数来表示这些变量，可以系统地包含所有相关的不确定性和依赖关系，从而使得可以进行精确的推断和决策。</strong>以下是详细解释为什么采用这种表示方法：</p>
<p>在导航问题中：</p>
<ul>
<li><strong>X</strong>
表示机器人的位置状态序列，即在不同时间点的位置状态。</li>
<li><strong>L</strong> 表示环境的地图，包括可能的地标或其他特征。</li>
<li><strong>Z</strong>
表示机器人的观测数据序列，即机器人通过其传感器相对于环境特征的观测。</li>
</ul>
<p><strong>概率模型表示</strong></p>
<ol type="1">
<li><strong>初始状态的概率</strong> <span class="math inline">\(P(x_0)\)</span>：这是机器人在开始导航前的位置状态的初始概率分布。这通常是基于先验知识或初始观测所给定的。</li>
<li><strong>状态转移概率</strong> <span class="math inline">\(\prod_{i=1}^M P(x_i|x_{i-1}, u_i)\)</span>
：这一部分表示机器人位置的演化，其中每个状态 <span class="math inline">\(x_i\)</span> 取决于前一个状态 <span class="math inline">\(x_{i-1}\)</span> 和执行的控制指令 <span class="math inline">\(u_i\)</span>。<strong>状态转移概率捕捉了系统动态和可能的过程噪声</strong>。</li>
<li><strong>观测模型</strong> <span class="math inline">\(\prod_{k=1}^K
P(z_k|x_{i_k}, l_{j_k})\)</span>：每个观测 <span class="math inline">\(z_k\)</span> 都依赖于特定时刻 <span class="math inline">\(i_k\)</span>的位置 $x_{i_k} $ 和相关联的地图特征
<span class="math inline">\(l_{j_k}\)</span>。<strong>观测模型描述了如何根据机器人的当前位置和周围环境的地标特征产生观测数据，包括观测噪声。</strong></li>
</ol>
<p><strong>联合概率密度函数的优势</strong></p>
<p>使用联合概率密度函数 $P(X, L, Z) $ 的优势在于：</p>
<ul>
<li><strong>全面性</strong>：通过整合所有可能的不确定性来源（控制输入的不确定性、位置的不确定性和观测的不确定性），这种方法提供了一个全面的系统描述。</li>
<li><strong>条件依赖性的显式表达</strong>：明确表达了各状态和观测之间的条件依赖关系，这对于理解和实现滤波器和估计算法至关重要。</li>
<li><strong>灵活性</strong>：这种表示允许使用各种概率推断技术，如卡尔曼滤波、粒子滤波或图优化，来估计位置和地图。</li>
<li><strong>信息整合</strong>：可以有效地整合多时刻和多来源的信息，优化状态估计和地图构建。</li>
</ul>
<p>总之，联合概率密度函数通过对所有变量的依赖关系进行建模，为解决导航中的状态估计问题提供了一个强大的数学框架，使得可以利用概率方法处理不确定性和推导最优解。这种方法是解决SLAM问题的基石，也是现代自动驾驶和机器人导航系统中不可或缺的一部分。</p>
<p><strong>一个具体的例子</strong></p>
<p>再尝试用一个更简单和直观的方式来理解为什么在导航中的状态估计问题可以通过一个联合概率密度函数来表示。我们可以通过具体的例子和逐步解析来帮助理解。</p>
<p>假设我们有一个机器人在一个未知的环境中导航。机器人的任务是理解自己的位置（状态X），探索并绘制周围的地图（L），同时根据自己的传感器收集信息（观测Z）。</p>
<ol type="1">
<li><strong>初始状态<span class="math inline">\(P(x_0)\)</span></strong>:
<ul>
<li>在一开始，我们只知道机器人可能在一个初始位置，比如我们可以假设它以某个概率分布（如高斯分布）位于起点附近。</li>
</ul></li>
<li><strong>状态转移<span class="math inline">\(P(x_i|x_{i-1},
u_i)\)</span></strong>:
<ul>
<li>每次机器人移动，它的新位置<span class="math inline">\(x_i\)</span>
将基于前一个位置 <span class="math inline">\(x_{i-1}\)</span>和其执行的移动指令<span class="math inline">\(u_i\)</span>（比如向前移动一米）。这个过程不是完全准确的，因此我们使用概率模型（如另一个高斯分布）来表示可能的新位置。</li>
</ul></li>
<li><strong>观测模型 <span class="math inline">\(P(z_k|x_{i_k},
l_{j_k})\)</span></strong>:
<ul>
<li>同时，机器人会使用传感器（如摄像头或激光雷达）观测周围环境。这些观测<span class="math inline">\(z_k\)</span>取决于机器人的当前位置 <span class="math inline">\(x\)</span>和它所观测到的环境特征<span class="math inline">\(l_{j_k}\)</span>（比如附近的一个门或窗户）。观测也不是完全精确的，同样用概率模型来描述。</li>
</ul></li>
</ol>
<h3 id="解释2"><strong>解释2</strong></h3>
<p>当我们想要同时考虑所有这些因素来估计机器人的最可能的位置、绘制地图和解释观测数据时，我们可以构造一个联合概率模型
<span class="math inline">\(P(X, L, Z)\)</span>：</p>
<ul>
<li><strong>综合所有信息</strong>：这个<strong>联合模型把所有关于机器人位置的不确定性、地图的不确定性和观测数据的不确定性都整合在一起</strong>。我们通过<strong>计算这个联合概率来寻找最有可能解释所有观测数据和已知信息的位置和地图配置</strong>。</li>
<li><strong>条件依赖关系</strong>：这个模型同时还能清晰地表达各种条件依赖关系，例如观测依赖于位置和地图的某些特定特征，位置的更新依赖于先前的位置和移动指令。</li>
<li><strong>灵活的推断和优化</strong>：有了这个联合模型，我们可以利用不同的数学工具和算法（如贝叶斯滤波器、粒子滤波、最大似然估计等）来推断未知的状态和地图。</li>
</ul>
<p>总结来说，这个<strong>联合概率密度函数提供了一种全面并且系统的方法来考虑和处理导航问题中的所有不确定性和依赖性</strong>。这种方法使得可以更有效地进行状态估计和环境映射，帮助机器人更好地理解和操作在其所处的环境中。</p>
<h2 id="如何根据联合概率密度分布-求解">如何根据联合概率密度分布
求解</h2>
<p>在解决导航和地图构建的问题中，目标通常是找到一组变量（机器人的位置和地图配置）的配置，<strong>这些配置最能解释观测数据和已知信息。</strong>这里的“解释”通常是指在给定模型下，找到最大化联合概率
<span class="math inline">\(P(X, L, Z)\)</span> 的 <span class="math inline">\(X\)</span>（位置）和<span class="math inline">\(L\)</span>（地图）的配置。这种方法是基于最大似然估计或最大后验估计的原理。</p>
<p><strong>最大似然估计和最大后验估计</strong></p>
<ul>
<li><p><strong>最大似然估计（MLE）</strong>:
在这种情况下，我们寻找的是最大化观测数据 (Z) 出现概率的位置<span class="math inline">\(X\)</span> 和地图<span class="math inline">\(L\)</span>
配置，不考虑位置和地图的先验概率。数学上表达为 <span class="math inline">\(\arg\max_{X, L} P(Z|X, L)\)</span>。</p></li>
<li><p><strong>最大后验估计（MAP）</strong>:
更常见的是，我们寻找能够最大化后验概率<span class="math inline">\(P(X, L
| Z)\)</span>的 <span class="math inline">\(X\)</span> 和<span class="math inline">\(L\)</span>。由于根据贝叶斯公式，<span class="math inline">\(P(X, L | Z) \propto P(Z | X, L) P(X,
L)\)</span>，这不仅考虑了观测数据的似然度，还包括了关于位置和地图的先验知识。</p></li>
</ul>
<p><strong>计算过程</strong></p>
<ol type="1">
<li><strong>定义概率模型</strong>:
<ul>
<li>状态转移概率 <span class="math inline">\(P(x_i | x_{i-1},
u_i)\)</span>描述了给定前一状态和控制输入后，当前状态的概率。</li>
<li>观测模型 <span class="math inline">\(P(z_k | x_{i_k},
l_{j_k})\)</span>
描述了给定当前状态和地图配置时，观测数据出现的概率。</li>
<li>先验<span class="math inline">\(P(X,
L)\)</span>可能基于以前的知识或假设（如位置的均匀分布，或地图的某些特征）。</li>
</ul></li>
<li><strong>优化过程</strong>:
<ul>
<li>在实践中，最大化<span class="math inline">\(P(X, L | Z)\)</span>
通常涉及到优化算法，如梯度上升、期望最大化（EM）算法或其他非线性优化技术。</li>
<li>在机器人技术中，常见的优化工具包括粒子滤波（用于非线性/非高斯问题）和卡尔曼滤波（用于线性/高斯问题）。</li>
</ul></li>
<li><strong>联合概率和解释</strong>:
<ul>
<li>我们不是寻找最小的联合概率，而是寻找最大化后验概率的 <span class="math inline">\(X,
L\)</span>配置，因为后验概率高意味着给定观测数据和先验知识下，该配置更可能是正确的。</li>
</ul></li>
</ol>
<p>通过最大化后验概率<span class="math inline">\(P(X, L |
Z)\)</span>，我<strong>们找到一组X
和L，使得在已有的观测Z和可能的先验知识下，这组配置是最有可能的</strong>。这就是<strong>如何使用联合概率模型来优化并解释机器人的导航和地图构建问题</strong>。这种方法使得可以在不确定的环境中做出最好的估计和决策。</p>
<h2 id="关于概率推导">关于概率推导</h2>
<p>导航定位系统状态量的最大后验估计问题可以转换为在已知系统观测信息的前提下，求解最大化系统的状态信息的概率密度。如式
所示: <span class="math display">\[
X^{MAP}=\arg\max_Xp(X_m\mid Z_j)=\arg\max_X\frac{p(Z_j\mid
X_m)p(X_m)}{p(Z_j)}
\]</span> 由于观测的数据<span class="math inline">\(Z_j\)</span>是已知的，且与待估计的状态是独立的，于是有：
​<span class="math display">\[
p(X_m\mid Z_j)\propto p(Z_j\mid X_m)p(X_m)\\X^{MAP}=\arg\max_Xp(Z_j\mid
X_m)p(X_m)
\]</span></p>
<h3 id="在给定系统状态的情况下每个观测数据是独立的-为什么观测模型还依赖于系统状态">在给定系统状态的情况下，每个观测数据是独立的。
为什么观测模型还依赖于系统状态？</h3>
<h4 id="解释1-1">解释1</h4>
<p>在给定系统状态的情况下，每个观测数据是独立的，这意味着每个观测数据<span class="math inline">\(z_k\)</span>的生成不受其他观测数据的影响。但是，观测数据和系统状态之间仍然可能存在依赖关系，这种依赖关系通常由观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>来描述。</p>
<p>观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>表示系统状态<span class="math inline">\(x_{i_k}\)</span>到观测数据<span class="math inline">\(z_k\)</span>之间的映射关系。即使在给定系统状态的情况下，不同的系统状态可能会导致不同的观测数据。这种依赖关系可以是物理上的，也可以是统计上的。例如，在一个移动机器人的定位问题中，机器人的位置状态会影响传感器测量值的期望值，即观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>。即使在给定机器人位置的情况下，由于传感器的测量误差，不同的位置状态也会导致不同的观测数据。</p>
<p>因此，虽然在给定系统状态的情况下，每个观测数据是独立的，但观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>仍然依赖于系统状态，因为观测数据的生成过程与系统状态之间可能存在依赖关系。</p>
<h4 id="解释2-1">解释2</h4>
<p>在给定观测数据<span class="math inline">\(z\)</span>的情况下，观测模型的确不应该直接依赖于系统状态<span class="math inline">\(x\)</span>，因为观测数据<span class="math inline">\(z\)</span>已经被视为已知值，与系统状态无关。</p>
<p>在导航定位系统中，观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>通常描述了系统状态<span class="math inline">\(x_{i_k}\)</span>到观测数据<span class="math inline">\(z_k\)</span>之间的映射关系。这个映射关系可以是物理上的，例如，通过测量信号强度来估计距离，或者是统计上的，例如，通过回归模型来预测观测数据的期望值。</p>
<p>然而，当我们使用高斯分布来表示观测数据<span class="math inline">\(z_k\)</span>在给定状态<span class="math inline">\(x_{i_k}\)</span>下的条件概率时，我们需要考虑观测模型和观测噪声。这里的高斯分布是一个常用的假设，用于表示观测数据的不确定性，其中噪声项<span class="math inline">\(\nu_k\)</span>通常被假设为零均值的高斯分布。</p>
<p>因此，虽然在给定观测数据<span class="math inline">\(z\)</span>的情况下，观测模型不应该直接依赖于系统状态<span class="math inline">\(x\)</span>，但在贝叶斯推断中，我们可能仍然需要考虑观测模型<span class="math inline">\(h_k(x_{i_k})\)</span>的形式，以便通过高斯分布来表示观测数据的条件概率分布。然而，需要注意的是，高斯分布中的参数应该是与系统状态无关的，因为在给定观测数据的情况下，观测模型不应该依赖于系统状态。</p>
<p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f330.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>具体的例子</p>
<p>当处理导航定位系统时，一个常见的观测是通过GPS接收器收集到的位置数据。在这种情况下，我们可以将观测模型视为将系统状态（例如，实际位置）映射到观测数据（例如，GPS接收器报告的位置）的函数。</p>
<p>假设我们想要估计一个移动机器人的位置。机器人当前的真实位置是系统的状态，我们用<span class="math inline">\(x_i\)</span>表示。而机器人所收集到的GPS数据就是观测数据，用<span class="math inline">\(z_i\)</span>表示。GPS数据可能会受到多种因素的影响，例如大气干扰、多径效应等，因此我们会有一个观测噪声的模型。</p>
<p>假设我们的观测模型是一个简单的线性模型，即：</p>
<p><span class="math display">\[z_i = x_i + \nu_i\]</span></p>
<p>其中，<span class="math inline">\(\nu_i\)</span>是观测噪声，表示GPS测量的误差。</p>
<p>在这个例子中，观测模型<span class="math inline">\(h(x_i)\)</span>是直接将系统状态<span class="math inline">\(x_i\)</span>映射到观测数据<span class="math inline">\(z_i\)</span>上，这是一个物理上的映射关系。但是，为了考虑观测噪声的影响，我们可能会假设<span class="math inline">\(\nu_i\)</span>是一个零均值的高斯随机变量。</p>
<p>因此，我们可以使用高斯分布来描述观测数据<span class="math inline">\(z_i\)</span>在给定状态<span class="math inline">\(x_i\)</span>下的条件概率分布，即：</p>
<p><span class="math display">\[p(z_i \mid x_i) \propto \exp \left(
-\frac{1}{2\sigma^2} \|z_i - x_i\|^2 \right)\]</span></p>
<p>其中，<span class="math inline">\(\sigma^2\)</span>是观测噪声的方差，<span class="math inline">\(\|.\|\)</span>表示向量的范数。</p>
<p>需要注意的是，在这个例子中，虽然我们使用了一个与系统状态<span class="math inline">\(x_i\)</span>相关的观测模型<span class="math inline">\(h(x_i)\)</span>，但是在贝叶斯推断中，我们最终要估计的是系统状态<span class="math inline">\(x_i\)</span>的后验分布<span class="math inline">\(p(x_i \mid z_i)\)</span>，而不是观测模型<span class="math inline">\(h(x_i)\)</span>本身。因此，我们仍然可以利用贝叶斯定理来计算后验分布，如前面提到的那样。</p>
<h2 id="关于残差">关于残差</h2>
<p>残差不仅仅反映了异常值的存在，它还反映了模型预测值与实际观测值之间的差异，包括了模型未能完全解释的部分以及数据中的随机噪声。</p>
<p>在统计学和机器学习中，<strong>残差通常被定义为观测值与模型的预测值之间的差异</strong>。如果我们的模型能够很好地拟合数据，那么残差应该是很小的。然而，<strong>当数据中存在异常值或者模型不够准确时，残差可能会变得较大，因为观测值与模型的预测值之间的差异会增大。</strong></p>
<p>因此，残差不仅反映了异常值的存在，还反映了其他因素导致的预测误差。但是，由于异常值往往会导致较大的残差，因此在一定程度上残差可以用来间接地检测异常值的存在。</p>
<p>当我们使用鲁棒核函数时，对于较大的残差会施加较小的权重，使得异常值的影响降低，从而更有可能得到更好的优化结果。因此，虽然残差不仅仅反映了异常值的存在，但异常值对于残差的贡献往往是较大的，因此对异常值施加较小的权重可以减小它们对优化过程的影响。</p>
<h2 id="关于鲁棒核函数">关于鲁棒核函数</h2>
<p>对于常规的最小二乘法，异常值的存在会对优化结果产生较大的影响，因为它们对残差的贡献很大，导致最小二乘法过度拟合这些异常值。这<strong>是因为最小二乘法对所有的残差都施加相同的惩罚，而对于异常值来说，它们的残差通常会比较大。</strong></p>
<p>相比之下，鲁棒核函数（如Huber损失函数）会在残差较小的时候施加较小的惩罚，而在残差较大的时候施加较大的惩罚。这使得鲁棒核函数能够更好地适应数据中的异常值，并且对异常值的影响较小。因此，当使用鲁棒核函数进行优化时，异常值不会对优化过程产生过大的影响，从而使得优化结果更加稳健。</p>
<p>总的来说，使用鲁棒核函数能够减少异常值对优化过程的影响，使得优化结果更具有鲁棒性，更能反映数据的真实情况。</p>
<h3 id="为什么残差可以体现异常值">为什么残差可以体现异常值</h3>
<p>残差对于异常值的影响在于它们对误差的贡献程度。在最小二乘法中，所有残差都会以相同的权重参与到优化过程中，这意味着即使存在异常值，它们也会对最终拟合结果产生显著影响，因为异常值通常会导致较大的残差。</p>
<p>然而，当使用鲁棒核函数（如Huber损失函数）时，对于较小的残差，它们只会受到较小的惩罚，而对于较大的残差，它们会受到更大的惩罚。这样的设计使得鲁棒核函数能够更好地适应异常值的存在，因为异常值通常会导致较大的残差。因此，使用鲁棒核函数时，异常值的影响会被减弱，从而使得优化过程更加稳健，并且更能够反映数据的真实情况。</p>
<p>总的来说，鲁棒核函数通过调整对残差的惩罚来减少异常值对优化过程的影响，从而使得优化结果更具有鲁棒性。</p>
<p>残差是指观测值与拟合值之间的差异，它们在统计学和优化问题中经常被使用。在回归或拟合问题中，残差可以看作是模型未能解释的部分，包括了模型无法捕捉到的数据的波动性或噪声。当数据中存在异常值时，这些异常值往往会导致较大的残差，因为它们与模型的预期值相差较大。</p>
<p>因此，残差的大小和分布可以在一定程度上反映数据中的异常值。当数据中存在异常值时，通常会观察到较大的残差值，因为异常值与其他数据点的差异较大。这使得残差成为了一种检测异常值的方式，因为异常值通常会导致残差的偏离。</p>
<p>在统计建模和优化问题中，我们通常会对残差进行分析和处理，以便更好地理解数据的特征并提高模型的拟合效果。例如，在回归分析中，我们可以检查残差的分布是否满足模型假设，并根据需要调整模型。在优化问题中，我们可以使用残差来评估优化算法的效果，并进一步改进算法，以使残差逐渐减小。</p>
<p>因此，残差在一定程度上可以反映异常值的存在和影响，它们是在统计建模和优化问题中常用的工具，用于识别和处理数据中的异常情况。</p>
<h3 id="什么是残差较大的时候-施加较大的惩罚">什么是残差较大的时候
施加较大的惩罚</h3>
<p>当我们说在残差较大的时候施加较大的惩罚时，意味着在优化过程中对于较大的残差值，我们会给予更大的权重或惩罚，以使得这些较大的残差不会对优化结果产生过大的影响。这样的做法可以减少异常值对优化过程的影响，使得优化结果更加鲁棒。</p>
<p>让我们通过一个简单的线性回归的例子来说明这个概念。假设我们有一组数据<span class="math inline">\((x_i, y_i)\)</span>，我们想要用线性模型<span class="math inline">\(y = mx + b\)</span>
来拟合这些数据。然而，数据中存在一些异常值，这些异常值可能会导致较大的残差。在普通的最小二乘法中，我们会平方残差并求和，以最小化这些残差的平方和，即最小化目标函数：</p>
<p><span class="math display">\[\text{minimize } \sum_i (y_i - (mx_i +
b))^2\]</span></p>
<p>然而，当存在异常值时，它们会导致较大的残差，从而对最小二乘法产生较大的影响。为了降低异常值的影响，我们可以使用Huber损失函数来代替平方损失，它在残差较小的情况下类似于平方损失，而在残差较大的情况下则类似于绝对值损失。这样的损失函数将对较大的残差施加较大的惩罚，从而减小了异常值对优化结果的影响。</p>
<p>Huber损失函数的形式如下：</p>
<p><span class="math display">\[L(r) =
\begin{cases}
\frac{1}{2} r^2, &amp; \text{if } |r| \leq \delta \\
\delta (|r| - \frac{1}{2}\delta), &amp; \text{if } |r| &gt; \delta
\end{cases}\]</span></p>
<p>其中，<span class="math inline">\(r\)</span>表示残差，<span class="math inline">\(\delta\)</span>是一个阈值参数，用于控制在何种范围内将损失函数视为二次型。当残差小于等于<span class="math inline">\(\delta\)</span>时，损失函数是一个平方函数，而当残差大于<span class="math inline">\(\delta\)</span>时，损失函数是一个线性函数。这样的设计使得在优化过程中对于较大的残差会施加较大的惩罚，从而减少了异常值对优化结果的影响。</p>
<h3 id="什么是较大的惩罚">什么是较大的惩罚</h3>
<p>让我进一步解释一下“受到较大的惩罚”是什么意思。</p>
<p>在优化问题中，我们通常会定义一个损失函数，用于衡量模型的拟合程度。这个损失函数越小，表示模型对数据的拟合越好。当我们使用不同的损失函数时，对于相同的残差，损失函数可能会对其赋予不同的重要性或权重。</p>
<p>举个简单的例子，假设我们使用平方损失函数：</p>
<p><span class="math display">\[
L(r) = r^2
\]</span> 在这种情况下，不论残差<span class="math inline">\(r\)</span>的大小如何，损失函数都会将其平方作为损失。因此，对于较大的残差，损失函数会将其平方的值作为较大的损失，而对于较小的残差，损失函数会将其平方的值作为较小的损失。</p>
<p>而当我们使用Huber损失函数时，对于较小的残差，损失函数是一个二次函数，因此对其赋予较小的权重；而对于较大的残差，损失函数是一个线性函数，因此对其赋予较大的权重。换句话说，Huber损失函数对于较大的残差会施加较大的惩罚，而对于较小的残差则施加较小的惩罚。</p>
<p>所以，当我们说“受到较大的惩罚”时，意味着对于那些导致较大残差的数据点，它们在优化过程中会被赋予较大的权重，以使得模型更加关注这些异常值，并尽可能减少它们对模型参数的影响。</p>
<hr>
<h3 id="herb比较好的例子"><span class="github-emoji" style="display:inline;vertical-align:middle"><span>🌿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f33f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>比较好的例子​！！</h3>
<p>理解这个问题的关键在于理解异常值对于损失函数的影响。在传统的最小二乘法中，异常值的存在可能会导致较大的残差，从而对整个损失函数产生较大的影响。这意味着优化过程会受到异常值的干扰，可能会导致无法收敛到最优解，或者收敛到一个不够准确的解。</p>
<p>而使用鲁棒核函数时，对于较大的残差，它们会受到较小的权重，即较小的惩罚。这意味着异常值的存在不会对损失函数产生过大的影响，因为它们对于整体损失函数的贡献较小。相比之下，对于传统的最小二乘法来说，异常值的残差较大，导致损失函数的值被显著地增加。</p>
<p>通过减少异常值的影响，优化过程更有可能收敛到更好的解。<strong>这是因为优化过程可以更专注于拟合那些正常的、代表性的数据点，而不会被少数异常值所主导。</strong>这种机制使得优化过程更加稳健，能够更可靠地找到对数据拟合更好的解。</p>
<p>总的来说，通过对异常值施加较小的权重，可以减小它们对损失函数的影响，从而使得优化过程更有可能收敛到更好的解。</p>
<h3 id="具体数值的例子">具体数值的例子</h3>
<p>当我们使用最小二乘法时，我们通常会最小化残差的平方和，即： <span class="math display">\[
\sum_{k=1}^n \|h_k(x_{i_k}) - z_k\|^2
\]</span> 在这个公式中，<span class="math inline">\(h_k(x_{i_k})\)</span> 是模型对观测数据 <span class="math inline">\(z_k\)</span> 的预测值，<span class="math inline">\(x_{i_k}\)</span>
是系统状态。这个公式中的每个残差都会被平方，并等权重地加总起来。</p>
<p>假设我们有一组观测数据和模型如下：</p>
<ul>
<li>观测数据：<span class="math inline">\(z_1 = 10\)</span>, <span class="math inline">\(z_2 = 12\)</span>, <span class="math inline">\(z_3
= 8\)</span></li>
<li>模型预测值：<span class="math inline">\(h(x) = x\)</span></li>
</ul>
<p>如果我们使用最小二乘法，那么我们的优化目标就是最小化残差的平方和：</p>
<p><span class="math display">\[
\text{目标：} \min_{x} \left( (x - 10)^2 + (x - 12)^2 + (x - 8)^2
\right)
\]</span> 假设我们初始时取 <span class="math inline">\(x =
0\)</span>。计算残差的平方和为： <span class="math display">\[
(0 - 10)^2 + (0 - 12)^2 + (0 - 8)^2 = 100 + 144 + 64 = 308
\]</span> 然后我们使用优化算法来尝试减小这个值。</p>
<p>但如果我们知道在数据中有一些异常值，比如一个 <span class="math inline">\(z_2 =
100\)</span>，这个数远远超出了其他数据的范围。在这种情况下，传统的最小二乘法会对这个异常值产生较大的影响。</p>
<p>现在我们尝试使用Huber损失函数，它对较大的残差施加较小的权重。Huber损失函数的形式如下：</p>
<p><span class="math display">\[
L(r) =
\begin{cases}
\frac{1}{2} r^2, &amp; \text{if } |r| \leq \delta \\
\delta (|r| - \frac{1}{2}\delta), &amp; \text{if } |r| &gt; \delta
\end{cases}
\]</span> 假设我们选择 <span class="math inline">\(\delta =
2\)</span>。那么在计算损失函数时，对于较小的残差，我们会使用残差的平方，而对于较大的残差，我们会使用一个线性函数。所以，对于较大的残差，Huber损失函数的惩罚相对较小。</p>
<p>我们再次尝试用 <span class="math inline">\(x = 0\)</span>
开始优化。计算Huber损失函数的值：</p>
<p><span class="math display">\[
\text{目标：} \min_{x} \left( \frac{1}{2}(x - 10)^2 + \frac{1}{2}(x -
12)^2 + \frac{1}{2}(x - 8)^2 \right)
\]</span> 计算后的损失函数值为： <span class="math display">\[
\frac{1}{2}(0 - 10)^2 + \frac{1}{2}(0 - 12)^2 + \frac{1}{2}(0 - 8)^2 =
25 + 36 + 16 = 77
\]</span>
可以看出，相比于传统的最小二乘法，Huber损失函数对异常值的影响要小得多。因此，优化算法更有可能收敛到一个更接近于真实值的解。</p>
<h2 id="因子图为什么处理导航相关问题">因子图为什么处理导航相关问题</h2>
<ol type="1">
<li><p><strong>局部测量与全局状态的关系</strong>：在GNSS/PDR系统中，我们需要整合来自GNSS的卫星信号数据和PDR系统（如加速度计、陀螺仪等）提供的内部传感器数据。<strong>这些数据与用户的全局位置和运动状态有直接关系</strong>。因子图允许我们将这些关系表达为局部函数，这些函数仅与某些变量相关联。</p></li>
<li><p><strong>联乘积形式的模型表示</strong>：在因子图中，全局函数（如位置和姿态的估计）可以被表示为多个局部函数的乘积。每个局部函数对应于一个特定的测量或状态变量的影响。例如，一个局部函数可能代表来自GNSS的位置测量，另一个局部函数可能代表来自步行检测算法的位移估计。这些局部函数的联乘积可以有效地融合来自不同源的数据，以优化全局状态的估计。</p></li>
</ol>
<h2 id="在因子图中各个因子对于执行如图搜索优化和推断等操作是非常有效的">在因子图中，各个因子对于执行如图搜索、优化和推断等操作是非常有效的？</h2>
<blockquote>
<p>在因子图中，各个因子直接关联到一组变量，并定义这些变量间的局部关系，这对于执行如图搜索、优化和推断等操作是非常有效的？</p>
</blockquote>
<p>这段话描述了因子图的核心特性：因子图是一种图形模型，用于表示变量之间的依赖关系。<strong>在因子图中，各个因子直接与一组变量相连，并且定义了这些变量之间的具体关系</strong>。这种结构对于图搜索、优化和推断等操作非常有效。以下是几个关键点来帮助理解这个概念：</p>
<h3 id="因子图的结构"><strong>因子图的结构</strong></h3>
<ol type="1">
<li><strong>变量节点</strong>：表示问题中的各种变量（例如，在SLAM中的机器人位置或地图特征点）。</li>
<li><strong>因子节点</strong>：表示变量之间的具体关系或依赖，通常体现为概率函数或约束。这些因子定义了变量如何相互作用，例如，一个因子可能表示在给定机器人的某个位置时，预期的传感器测量与实际观察之间的关系。</li>
</ol>
<h3 id="执行图搜索优化和推断的效果"><strong>执行图搜索、优化和推断的效果</strong></h3>
<ol type="1">
<li><p><strong>图搜索</strong>：因子图的结构使得可以有效地进行图搜索操作，例如寻找最可能的变量配置。<strong>因子图中的连接告诉搜索算法哪些变量是直接相互关联的，从而可以系统地探索这些变量的组合，寻找满足所有因子约束的最优解。</strong></p></li>
<li><p><strong>优化</strong>：在因子图中，优化通常涉及调整变量的值以最大化（或最小化）整体系统的某个性能指标（如概率总和或误差平方和）。因为<strong>因子直接定义了变量间的关系，优化算法可以直接利用这些局部关系，集中处理影响最大的部分，从而高效地改进解决方案。</strong></p></li>
<li><p><strong>推断</strong>：在概率模型中，推断通常意味着基于给定的数据和模型结构推测某些变量的状态。<strong>因子图提供了一种清晰的方式来利用局部信息（因子定义的局部概率关系）对全局状态（整个变量集的状态）进行推断。</strong>例如，给定某些变量的测量值，可以通过因子图推断其他未知变量的最可能值。</p></li>
</ol>
<h3 id="效率的原因"><strong>效率的原因</strong></h3>
<p>因子图将复杂的全局问题分解为多个简单的局部问题，每个局部问题都集中在一小组变量上。<strong>这种分解使得可以并行处理这些局部问题，或者专注于最关键的部分，从而大大提高了计算的效率</strong>。此外，因为因子定义了变量之间的确切关系，算法可以避免处理无关变量间的不必要计算，进一步优化性能。</p>
<p>因此，因子图是处理具有复杂依赖关系的优化和推断问题的一个非常强大和灵活的工具。</p>
<h2 id="因子图通过将测量值作为已知的参数而不是变量来简化问题表示">因子图通过将测量值作为已知的参数而不是变量来简化问题表示？</h2>
<p>因子图通过将测量值作为已知的参数而不是变量来简化问题表示，使得模型更直接地关联到优化问题本身，这对于高效解决SLAM等复杂问题至关重要。
这段话怎么理解？通过将测量值作为已知的参数而不是变量来简化问题表示？</p>
<p>这段话指出因子图在处理如SLAM这样的问题时的一个关键特性：将测量数据视为已知参数，而不是作为需要求解的变量。这种处理方式在建模和求解复杂系统时有几个重要的好处：</p>
<p><strong>简化问题表示</strong></p>
<ol type="1">
<li><p><strong>明确角色分配</strong>：在SLAM等问题中，我们的主要目标是推断或优化未知的状态变量（如机器人的位置、地图的特征点等），而测量数据（如来自传感器的读数）是用来帮助确定这些未知变量的。<strong>将测量值视为已知参数，意味着这些数据在模型中的角色是辅助性的，它们用于构建关于未知变量的条件概率表达，而不是自身需要被解决的问题</strong>。</p></li>
<li><p><strong>减少求解复杂度</strong>：如果将测量值也视为变量，那么问题的复杂度会显著增加，因为这样不仅需要推断未知的状态变量，还要同时解决这些测量值的准确性和可靠性问题。将测量值作为参数，可以直接使用这些数据来形成对未知变量的概率描述，从而简化了模型和计算。</p></li>
</ol>
<p><strong>直接关联到优化问题本身</strong></p>
<ol type="1">
<li><p><strong>更加聚焦核心任务</strong>：在SLAM等应用中，核心任务是基于测量数据推断或更新未知的状态变量。<strong>将测量数据视为参数，可以使模型更加集中于如何利用这些数据来改善对未知变量的估计，而非分散注意力于处理测量数据本身的不确定性。</strong></p></li>
<li><p><strong>提高算法效率</strong>：当模型聚焦于核心变量时，优化算法可以更有效地调整和优化这些变量的值以达到最佳估计。这通常会导致更快的计算速度和更好的优化性能，因为算法可以直接利用固定的、已知的测量数据来逐步改进状态估计。</p></li>
</ol>
<p>总之，将测量值作为已知参数处理，有助于因子图更加高效和直接地应对复杂的优化问题，如SLAM，这样做能够减轻计算负担，同时提高问题求解的准确性和效率。这种方法使得模型设计和算法实现都更加直接和实用，特别是在实时或资源受限的应用场景中。</p>
<h2 id="因子图优化如何更新节点状态"><strong>因子图优化如何更新节点状态</strong></h2>
<p>让我们逐一探讨这两个问题：</p>
<p><strong>1. 根据导数信息计算状态更新量的例子</strong></p>
<p>考虑一个简单的SLAM问题，其中机器人需要确定它的位置x和地图上一个地标的位置
l。假设有一个观测z与机器人的位置和地标之间的距离相关。</p>
<p><strong>步骤</strong></p>
<ul>
<li><p><strong>误差函数</strong>：设<span class="math inline">\(h(x,
l)\)</span>是从机器人位置 <span class="math inline">\(x\)</span> 到地标
<span class="math inline">\(l\)</span> 的预测测量，误差函数$ e$可表示为
<span class="math inline">\(e = z - h(x, l)\)</span>。</p></li>
<li><p><strong>雅可比矩阵</strong>：计算误差<span class="math inline">\(e\)</span>关于状态 <span class="math inline">\(x\)</span> 和地标位置 <span class="math inline">\(l\)</span> 的雅可比矩阵<span class="math inline">\(J_x\)</span> 和 <span class="math inline">\(J_l\)</span>。</p></li>
<li><p><strong>更新公式</strong>：使用高斯牛顿法，更新公式可以写作：</p></li>
</ul>
<p><span class="math display">\[
\begin{pmatrix} \Delta x \\ \Delta l \end{pmatrix} = -(J^T J + \lambda
I)^{-1} J^T e
\]</span></p>
<p>其中 ( J ) 是组合了<span class="math inline">\(J_x\)</span> 和$ J_l$
的雅可比矩阵，$
$是为了提高数值稳定性而添加的阻尼因子（Levenberg-Marquardt算法中使用）,I是单位矩阵。</p>
<ul>
<li><strong>状态更新</strong>：计算得到的$ x $ 和$l
$用来更新当前状态和地标位置。</li>
</ul>
<p><strong>2. 增量式图优化方法的实际操作</strong></p>
<p>在实时系统如自动驾驶车辆中，<strong>增量图优化</strong>主要关注最近的观测和状态，以减少每次更新所需的计算资源。</p>
<p><strong>步骤</strong></p>
<ul>
<li><strong>局部图更新</strong>：每当接收到新的观测数据时，只更新与这些新数据直接相关的节点和边，这些通常是最近的机器人状态和相关地标。</li>
<li><strong>窗口优化</strong>：一种常见的策略是<strong>固定滑动窗口方法，即仅在固定大小的最近状态窗口内进行优化</strong>。较旧的状态和地标，一旦它们超出窗口，<strong>可以被边缘化（从优化问题中移除但考虑其对现有状态的统计影响）或锁定。</strong></li>
<li><strong>增量求解器</strong>：使用专门设计的<strong>增量求解器</strong>，如
iSAM 或 g2o，这些工具能够有效地更新信息矩阵和求解增量更新问题。</li>
<li><strong>实时反馈</strong>：通过快速更新仅涉及局部改动的解决方案，系统能够快速地对新数据做出响应。</li>
</ul>
<p>这种增量更新方法能够显著降低因每个新观测而进行全局优化的计算成本，使系统更适合实时应用场景，如自动驾驶或动态环境中的机器人导航。</p>
<h2 id="因子图的迭代优化算法">因子图的迭代优化算法</h2>
<p>图优化的迭代优化通常涉及到通过逐步优化来调整和改进图中的节点估计（即状态变量），以最小化整个图中所有误差函数（因子）的总和。这个过程通常使用类似于高斯-牛顿或者LM算法的优化方法。</p>
<p><strong>图优化迭代过程</strong></p>
<ol type="1">
<li><strong>初始化</strong>：
<ul>
<li>节点的初始估计通常基于传感器的原始数据或某些先验知识。</li>
</ul></li>
<li><strong>构建误差函数</strong>：
<ul>
<li>对于图中的每一个因子，构建一个误差函数，该函数衡量当前节点状态估计与观测数据之间的差异。</li>
</ul></li>
<li><strong>线性化误差函数</strong>：
<ul>
<li>在当前估计点附近对误差函数进行线性化，通常是通过计算误差函数相对于每个节点状态的雅可比矩阵。</li>
</ul></li>
<li><strong>构建正规方程</strong>：
<ul>
<li>将所有线性化的误差函数组合成一个大的系统方程。这通常表现为一个大的稀疏线性系统，可以写成
<span class="math display">\[ H\delta = b \]</span> 的形式，其中 ( H )
是信息矩阵（或海森矩阵），而 ( b ) 是基于误差的向量。</li>
</ul></li>
<li><strong>求解线性系统</strong>：
<ul>
<li>使用直接求解器（如Cholesky分解）或迭代求解器（如共轭梯度法）来解决上述线性系统，以找到状态更新
<span class="math inline">\(\delta\)</span>。</li>
</ul></li>
<li><strong>更新状态估计</strong>：
<ul>
<li>将解得的<span class="math inline">\(\delta\)</span>应用到当前的状态估计中，更新所有节点的状态。</li>
</ul></li>
<li><strong>迭代和收敛检查</strong>：
<ul>
<li>检查解的改进程度，如果未达到预设的收敛标准（如状态改变量的大小低于某个阈值或达到最大迭代次数），则重复步骤
2-6。</li>
</ul></li>
<li><strong>最终优化结果</strong>：
<ul>
<li>当迭代收敛时，当前的状态估计被认为是优化的解，即图中所有节点的最优估计。</li>
</ul></li>
</ol>
<p><strong>使用Levenberg-Marquardt方法的特别说明</strong></p>
<p>Levenberg-Marquardt算法是高斯-牛顿算法的一个变种，通过引入一个调整参数（阻尼因子）来平衡算法的迭代速度与稳定性。这个阻尼因子可以动态调整，以在必要时约束更新步长，从而提高收敛性和算法的鲁棒性。</p>
<h2 id="关于因子图的误差函数">关于因子图的误差函数</h2>
<h3 id="一个具体的例子">一个具体的例子</h3>
<p>在因子图中使用的每个因子都可以被看作是一个误差函数，它描述了给定状态变量下预期观测值与实际观测值之间的差异。雅可比矩阵是这些误差函数对于状态变量的一阶导数，用于在非线性优化过程中进行线性化。</p>
<h4 id="模型和误差函数">模型和误差函数</h4>
<p>以GNSS和PDR为例，我们可以具体定义状态变量和误差函数。</p>
<p>假设状态变量 <span class="math inline">\(\mathbf{x}_k\)</span> 在第
<span class="math inline">\(k\)</span>
时刻是一个包括位置和朝向的位姿，可以表示为一个二维平面上的姿态（位置
<span class="math inline">\((x, y)\)</span> 和朝向 <span class="math inline">\(\theta\)</span>）： <span class="math display">\[
\mathbf{x}_k = \begin{bmatrix} x_k \\ y_k \\ \theta_k \end{bmatrix}
\]</span> GNSS观测模型</p>
<p>假设GNSS提供了位姿的绝对观测： <span class="math display">\[
\mathbf{z}^{\text{GNSS}}_k = \begin{bmatrix} x^{\text{meas}}_k \\
y^{\text{meas}}_k \\ \theta^{\text{meas}}_k \end{bmatrix}
\]</span> 误差函数（GNSS因子）可以定义为： <span class="math display">\[
\mathbf{e}^{\text{GNSS}}_k = \mathbf{z}^{\text{GNSS}}_k - \mathbf{x}_k
\]</span></p>
<h4 id="pdr观测模型">PDR观测模型</h4>
<p>PDR通常提供相对于上一状态的位移和方向改变，假设步行产生的位移 <span class="math inline">\(\Delta d\)</span> 和方向变化 <span class="math inline">\(\Delta \theta\)</span>： <span class="math display">\[
\mathbf{z}^{\text{PDR}}_k = \begin{bmatrix} \Delta d_k \\ \Delta
\theta_k \end{bmatrix}
\]</span> 相应的误差函数（PDR因子）可能是： <span class="math display">\[
\mathbf{e}^{\text{PDR}}_k = \mathbf{x}_k - \left( \mathbf{x}_{k-1} +
\begin{bmatrix} \Delta d_k \cos(\theta_{k-1}) \\ \Delta d_k
\sin(\theta_{k-1}) \\ \Delta \theta_k \end{bmatrix} \right)
\]</span></p>
<h4 id="雅可比矩阵计算">雅可比矩阵计算</h4>
<p>雅可比矩阵是误差函数相对于状态变量的偏导数。以PDR误差函数为例，其雅可比矩阵相对于状态
<span class="math inline">\(\mathbf{x}_k\)</span> 的导数为：</p>
<p><span class="math display">\[
J_{\mathbf{x}_k}^{\text{PDR}} = \frac{\partial
\mathbf{e}^{\text{PDR}}_k}{\partial \mathbf{x}_k} = \begin{bmatrix}
1 &amp; 0 &amp; -\Delta d_k \sin(\theta_{k-1}) \\
0 &amp; 1 &amp; \Delta d_k \cos(\theta_{k-1}) \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>这里，偏导数是通过微分 <span class="math inline">\(\mathbf{x}_k\)</span> 和 <span class="math inline">\(\mathbf{x}_{k-1}\)</span> 相关的表达式得到的。</p>
<h4 id="gtsam中的实现">GTSAM中的实现</h4>
<p>在GTSAM这样的库中，用户只需定义状态变量、误差函数和噪声模型。库内部负责计算雅可比矩阵并进行优化。在每次迭代中，基于当前的估计值，库会自动对误差函数进行线性化，计算雅可比矩阵，并更新状态估计。</p>
<p>在GTSAM中，可以通过自定义因子类来将状态转移函数 ( f )
纳入因子图中，并通过优化来估计状态变量。以下是一个示例，演示了如何在PDR/GNSS联合定位中使用状态转移函数作为因子的一部分。</p>
<p>假设我们有一个PDR传感器和一个GNSS传感器，我们希望使用PDR的状态转移函数来更新我们的位置估计。这里我们将假设PDR传感器的状态转移函数为
( f(x_t, u_t) )，其中 ( x_t ) 是时刻 ( t ) 的位置状态， ( u_t ) 是时刻 (
t ) 的PDR测量值。</p>
<h5 id="其中一种">其中一种</h5>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/base/numericalDerivative.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/geometry/Pose2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/inference/Symbol.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/ExpressionFactorGraph.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/Expression.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/LevenbergMarquardtOptimizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> gtsam;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义PDR状态转移函数</span></span><br><span class="line"><span class="function">Pose2 <span class="title">pdrStateTransition</span><span class="params">(<span class="type">const</span> Pose2&amp; xt, <span class="type">const</span> Pose2&amp; ut)</span> </span>{</span><br><span class="line">    <span class="comment">// 这里简单假设PDR每一步都是直线运动</span></span><br><span class="line">    <span class="keyword">return</span> xt.<span class="built_in">compose</span>(ut);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建优化器</span></span><br><span class="line">    LevenbergMarquardtOptimizer optimizer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建符号变量</span></span><br><span class="line">    <span class="function">Symbol <span class="title">x1</span><span class="params">(<span class="string">'x'</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 时刻1的位置状态</span></span><br><span class="line">    <span class="function">Symbol <span class="title">u1</span><span class="params">(<span class="string">'u'</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 时刻1的PDR测量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始估计值</span></span><br><span class="line">    Values initial;</span><br><span class="line">    initial.<span class="built_in">insert</span>(x1, <span class="built_in">Pose2</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 初始位置状态</span></span><br><span class="line">    initial.<span class="built_in">insert</span>(u1, <span class="built_in">Pose2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 初始PDR测量值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建因子图</span></span><br><span class="line">    ExpressionFactorGraph graph;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加PDR状态转移因子</span></span><br><span class="line">    <span class="comment">// 创建表达式表示PDR状态转移函数</span></span><br><span class="line">    Expression&lt;Pose2&gt; f_expr = <span class="built_in">pdrStateTransition</span>(<span class="built_in">Expression</span>&lt;Pose2&gt;(x1), <span class="built_in">Expression</span>&lt;Pose2&gt;(u1));</span><br><span class="line">    <span class="comment">// 添加因子</span></span><br><span class="line">    graph.<span class="built_in">addExpressionFactor</span>(f_expr, <span class="built_in">Pose2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), noiseModel::Isotropic::<span class="built_in">Sigma</span>(<span class="number">3</span>, <span class="number">0.1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行优化</span></span><br><span class="line">    Values result = optimizer.<span class="built_in">optimize</span>(graph, initial);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终估计结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Final Result:\n"</span>;</span><br><span class="line">    result.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>在这个示例中，我们通过 <code>ExpressionFactorGraph</code>
来创建因子图，并使用 <code>Expression</code>
表示状态转移函数。然后，我们将这个表达式因子添加到因子图中，并执行优化以估计最终的状态。</p>
<p>这个示例中的 <code>pdrStateTransition</code>
函数是一个简单的状态转移函数示例，实际应用中可能需要根据具体的PDR传感器和系统模型来定义更复杂的状态转移函数。</p>
<h5 id="另一种">另一种</h5>
<p>在GTSAM中，如果要将状态转移函数 ( f )
作为实现因子的一部分，你需要定义自定义的因子类。这个类应当能够处理状态的更新并计算误差向量，同时能够自动计算雅可比矩阵。下面是一个例子，展示如何为一个简单的PDR/GNSS系统创建一个自定义的因子类。</p>
<p>以下是GTSAM中一个自定义因子的简单实现，用于处理PDR和GNSS数据：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/nonlinear/NonlinearFactor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtsam/geometry/Pose2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> gtsam;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设系统的状态由位置 (x, y) 和方向 (theta) 组成，使用 Pose2 表示</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDRGNSSFactor</span> : <span class="keyword">public</span> NoiseModelFactor1&lt;Pose2&gt; {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 测量值</span></span><br><span class="line">  Point2 measuredGNSS;  <span class="comment">// GNSS测量的位置</span></span><br><span class="line">  <span class="type">double</span> measuredSteps; <span class="comment">// PDR测量的步数</span></span><br><span class="line">  <span class="type">double</span> stepLength;    <span class="comment">// 步长</span></span><br><span class="line">  <span class="type">double</span> measuredHeading; <span class="comment">// 步行方向</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造函数</span></span><br><span class="line"><span class="comment">   * key - 对应变量的键</span></span><br><span class="line"><span class="comment">   * measuredGNSS - GNSS测量值</span></span><br><span class="line"><span class="comment">   * measuredSteps - PDR测量的步数</span></span><br><span class="line"><span class="comment">   * stepLength - 单步步长</span></span><br><span class="line"><span class="comment">   * measuredHeading - 测量的步行方向</span></span><br><span class="line"><span class="comment">   * noiseModel - 噪声模型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">PDRGNSSFactor</span>(Key key, <span class="type">const</span> Point2&amp; gnssMeasurement, <span class="type">double</span> steps, <span class="type">double</span> length, <span class="type">double</span> heading, <span class="type">const</span> SharedNoiseModel&amp; noiseModel)</span><br><span class="line">    : <span class="built_in">NoiseModelFactor1</span>&lt;Pose2&gt;(noiseModel, key), <span class="built_in">measuredGNSS</span>(gnssMeasurement), <span class="built_in">measuredSteps</span>(steps), <span class="built_in">stepLength</span>(length), <span class="built_in">measuredHeading</span>(heading) {}</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算误差向量的函数</span></span><br><span class="line">  <span class="function">Vector <span class="title">evaluateError</span><span class="params">(<span class="type">const</span> Pose2&amp; pose, boost::optional&lt;Matrix&amp;&gt; H = boost::none)</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">    <span class="comment">// 使用当前姿势来预测下一位置</span></span><br><span class="line">    <span class="type">double</span> dx = stepLength * measuredSteps * <span class="built_in">cos</span>(measuredHeading);</span><br><span class="line">    <span class="type">double</span> dy = stepLength * measuredSteps * <span class="built_in">sin</span>(measuredHeading);</span><br><span class="line">    <span class="function">Point2 <span class="title">predictedPosition</span><span class="params">(pose.x() + dx, pose.y() + dy)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要雅可比矩阵</span></span><br><span class="line">    <span class="keyword">if</span> (H) {</span><br><span class="line">      *H = (<span class="built_in">Matrix</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">cos</span>(measuredHeading), -<span class="built_in">sin</span>(measuredHeading), <span class="number">0</span>,</span><br><span class="line">                            <span class="built_in">sin</span>(measuredHeading),  <span class="built_in">cos</span>(measuredHeading), <span class="number">0</span>).<span class="built_in">finished</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回GNSS测量值和预测位置之间的差异</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Vector</span>(<span class="number">2</span>) &lt;&lt; measuredGNSS.<span class="built_in">x</span>() - predictedPosition.<span class="built_in">x</span>(), measuredGNSS.<span class="built_in">y</span>() - predictedPosition.<span class="built_in">y</span>()).<span class="built_in">finished</span>();</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>使用此因子</strong></p>
<p>在你的SLAM系统或状态估计框架中，你可以像添加任何其他因子一样添加这个自定义因子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NonlinearFactorGraph graph;</span><br><span class="line">graph.<span class="built_in">add</span>(<span class="built_in">PDRGNSSFactor</span>(<span class="number">1</span>, <span class="built_in">Point2</span>(<span class="number">34.052</span>, <span class="number">-118.243</span>), <span class="number">20</span>, <span class="number">0.5</span>, <span class="number">0.785</span>, noiseModel::Diagonal::<span class="built_in">Sigmas</span>(<span class="built_in">Vector2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>))));</span><br></pre></td></tr></tbody></table></figure>
<p>这里，我们假设了步长为0.5米，测量的步行方向为0.785弧度（大约45度）。</p>
<ul>
<li>确保你的噪声模型和其他系统参数与你的具体应用场景匹配。</li>
<li>如果你的状态模型或动态更复杂，你可能需要扩展 <code>Pose2</code>
到更高维度的表示，或者使用 <code>Pose3</code>
如果是三维空间的应用。</li>
</ul>
<p>这个示例为如何将PDR和GNSS数据融合到单一的因子中提供了一个框架，展示了如何结合两种不同类型的测量更新机器人或移动设备的位置估计。</p>
<h2 id="为什么是因子图不是卡尔曼">为什么是因子图不是卡尔曼</h2>
<p>（1）<strong>处理非线性问题</strong>：EKF在处理行人轨迹的不确定性和GNSS信号的非线性特性时存在性能限制。由于行人轨迹的不确定性本质上属于状态非线性过程，EKF通过线性化系统模型来处理非线性问题，但这种方法是局部的，仅在当前估计点附近有效。FGO则是通过构建一个包含所有测量和状态变量的全局图模型，然后应用非线性最优化技术在整个状态空间中寻找最优解来解决整个问题，而不是局限于在每个时间步的局部线性化。</p>
<blockquote>
<p>由于非线性问题的复杂性，这种全局优化通常是迭代进行的。每一次迭代都会重新计算整个状态的最优估计，更新的估计会反过来影响下一次迭代的起始条件。这个过程一直重复，直到达到一个收敛条件，比如改进非常小或达到预设的迭代次数。</p>
</blockquote>
<p><span class="github-emoji" style="display:inline;vertical-align:middle"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>但是这个非线性的函数是需要自己手动添加的。那么问题来了，非线性函数都是自己手动给设置好的，怎么就直接参入因子图里面去了。就是编程里面？</p>
<blockquote>
<p>后续需要编程学习！需要定义误差因子</p>
</blockquote>
<ol start="2" type="1">
<li>处理连续轨迹跟踪：EKF的一阶马尔可夫假设限制了其对历史数据的再评估能力，影响行人轨迹连续跟踪性能。FGO则在新数据到来时重新评估整个状态历史，进行全局优化，提供更准确的状态估计，尤其适用于需要频繁更新和修正轨迹估计的室外行人导航。</li>
</ol>
<blockquote>
<p>在因子图优化中，通常会使用全局优化算法（例如梯度下降、高斯牛顿、或勒文贝格-马夸尔特方法等）来找到最小化所有因子误差的整体解。<strong>这种优化会考虑到新的数据点以及它们与已有数据点之间的关系，</strong>从而可能会影响到整个状态历史的估计</p>
</blockquote>
<ol start="3" type="1">
<li>异步数据处理：EKF在实时处理不同传感器数据更新频率不一致时面临挑战。FGO允许传感器数据以即插即用的方式整合，通过贝叶斯推理对因子进行综合分析，有效解决异步数据问题。</li>
</ol>
<blockquote>
<p>具体见后文因子图的即插即用</p>
</blockquote>
<p>(4)解算效率：EKF在处理大规模或复杂系统时，由于需要操作稠密的协方差矩阵而效率较低。相比之下，
FGO通过仅在因子间建立显式连接，自然地体现了系统的稀疏性。这种特性使得FGO适合处理那些局部相互作用的大型系统，从而提高了效率。</p>
<p>综上所述，FGO为解决行人导航中的非线性问题、提高位置估计准确性、异步数据的处理和解算效率上提供了一种新的解决方案。</p>
<h2 id="因子图的增量更新">因子图的增量更新</h2>
<p>在因子图优化中，确实可以采用一种增量更新的方法，但这并不意味着每来一个新数据就单独优化一次。因子图优化通常包括两种主要的更新策略：批量优化和增量优化，这取决于应用的需求和系统设计。</p>
<h3 id="批量优化">批量优化</h3>
<p>在批量优化策略中，因子图会收集一定量的数据后，进行一次全局优化。这种方法可以确保考虑到所有可用的信息来优化整个图的配置。批量处理通常在数据集完整或更新频率不高的情况下使用，例如在某些离线处理或数据分析任务中。</p>
<h3 id="增量优化">增量优化</h3>
<p>增量优化策略则更加动态，它允许系统在接收到新数据时即时更新和优化图的一部分。这并不意味着每接收到一个新的数据点就执行一次完整的全局优化，<strong>而是指更新影响到的部分节点和边，从而局部调整图的结构。</strong>这样的方法适用于需要实时或近实时处理的应用，如移动机器人的导航或在线地图构建。</p>
<h3 id="如何处理新增数据">如何处理新增数据</h3>
<p>当新数据到达时，在因子图中，通常采用以下步骤处理：</p>
<ol type="1">
<li><strong>新增因子</strong>：将新的观测数据转化为因子，并将其连接到图中对应的变量节点上。</li>
<li><strong>局部优化</strong>：对受新因子影响的节点进行局部优化，更新这些节点的状态估计。这种方法称为增量或局部优化。</li>
<li><strong>全局优化</strong>：在某些情况下，为了保证整体性能，可能定期进行一次全局优化，以整合所有信息并纠正潜在的误差积累。</li>
</ol>
<p>这种灵活性和即插即用的特性使因子图非常适合于动态环境下的应用，如动态传感器网络、实时导航系统等，它们需要不断地接受新信息并快速反应。因子图的这些特性也使得它能够在不重新启动系统的情况下适应新的配置或数据源的变化。</p>
<h2 id="因子图的即插即用">因子图的即插即用</h2>
<p>因子图对于处理传感器更新频率不一致问题提供了一种灵活且有效的方式，特别是在复杂的多传感器融合系统中。这主要得益于因子图在处理多源信息与维持全局状态估计方面的灵活性。</p>
<p>在因子图中，每个传感器的输入可以被视为一个因子，它只与图中的某些变量（例如机器人的某个位置）相关联。<strong>当新的传感器数据到来时，可以简单地将相应的新因子添加到图中，而无需重新配置整个系统。</strong>
这使得因子图非常适合于处理具有不同更新频率的传感器数据。</p>
<p>假设一个机器人装备了一个高频率的IMU（惯性测量单元）和一个低频率的GPS。IMU能够提供高频率但低精度的位置和方向更新，而GPS提供低频率但高精度的位置测量。</p>
<ol type="1">
<li><strong>构建因子图</strong>：机器人的每个状态（位置和姿态）都是图中的一个节点。IMU和GPS的每次读数分别产生一个新的因子，这些因子与特定的状态节点相连接。</li>
<li><strong>IMU因子</strong>：IMU的数据频繁更新，为图中相邻的状态节点间提供动态的约束（如速度和方向）。</li>
<li><strong>GPS因子</strong>：GPS数据不频繁，但每当数据到来时，会在因子图中创建一个新的因子，这个因子直接将GPS测量的位置与最近的状态节点相关联。</li>
<li><strong>因子更新</strong>：<strong>无论何时收到新的传感器数据，都只需将对应的新因子添加到图中并重新优化，而不必修改或重处理整个图。</strong></li>
</ol>
<h3 id="与卡尔曼滤波的比较"><strong>与卡尔曼滤波的比较</strong></h3>
<p>卡尔曼滤波器（包括其扩展和无迹变体）通常需要处理所有传感器数据的固定结构和预设的处理流程<strong>。每个传感器都需要在每个时间步被处理，即使某些传感器的数据并未更新。</strong></p>
<ul>
<li><strong>即插即用</strong>：卡尔曼滤波处理新传感器集成<strong>通常需要重新设计滤波过程和状态协方差的计算，而因子图可以更容易地通过添加新的因子来整合新传感器，无需重新设计或重新初始化整个系统。</strong></li>
<li><strong>处理非同步数据</strong>：卡尔曼滤波器<strong>对于非同步传感器数据处理通常需要额外的插值或同步机制，而因子图可以更自然地通过在适当的时间点插入因子来处理这种数据。</strong></li>
</ul>
<p>卡尔曼滤波器（KF）是一种适用于线性系统（或近似线性）的递推滤波方法，它依赖于数据输入的同步和连续性。在实际应用中，如自动驾驶车辆、机器人导航或多传感器融合系统中，传感器可能无法以同一频率或同步的方式产生数据。这会给基于卡尔曼滤波的系统设计带来挑战。</p>
<p><strong>卡尔曼滤波器和非同步数据处理</strong></p>
<p>当使用卡尔曼滤波器处理来自不同传感器的数据时，若这些传感器的更新频率不一致或数据非同步接收，可能需要进行额外处理以保证数据的时序一致性。这主要是因为卡尔曼滤波器在每个时间步更新状态估计时都假定接收到的数据是当前时刻的准确反映。</p>
<p><strong>举例说明</strong></p>
<p>假设有一个移动机器人使用两种传感器：一个激光雷达（LIDAR）和一个轮速计。激光雷达每100毫秒更新一次位置信息，而轮速计每30毫秒更新一次速度信息。如果直接将这些数据输入到一个卡尔曼滤波器，可能会出现问题，因为两种数据的时间戳不匹配。</p>
<p>为了同步这些传感器数据，一个常见的方法是使用插值：</p>
<ul>
<li><strong>插值</strong>：例如，可以使用线性插值或更复杂的插值方法（如样条插值）来估计激光雷达测量间隙中的位置数据，或者在轮速计测量间隙中估计速度，以便在非测量时刻提供数据估计。</li>
<li><strong>数据缓冲</strong>：另一种方法是对快速更新的传感器（轮速计）数据进行缓冲，直到慢速传感器（激光雷达）的下一次数据到来，然后一起处理这些数据。</li>
</ul>
<p>卡尔曼滤波器（KF）处理的核心在于<strong>它按照严格的时序顺序处理观测数据来更新状态估计</strong>。这个处理过程基于两个关键假设：<strong>系统的动态是已知的，并且观测数据是同步到特定的时间点的。</strong>
当观测数据来自频率不同或非同步的多个传感器时，这些假设可能不再成立，直接接受数据而不进行任何处理可能会导致以下问题：</p>
<p><strong>1. 误差累积</strong></p>
<p>卡尔曼滤波器在每个时间步更新其状态估计时，假设最新的观测数据反映了当前的系统状态。<strong>如果直接使用非同步的观测数据，滤波器可能无法准确地关联观测数据与其对应的状态，从而导致误差累积</strong>。例如，如果一个传感器的数据延迟或提前了，而滤波器误以为这些数据是最新的，那么更新的状态估计可能会基于错误的信息。</p>
<p><strong>2. 时间戳不匹配</strong></p>
<p>在处理来自不同传感器的数据时，<strong>每个传感器的输出通常带有时间戳。如果这些时间戳不一致，直接接受数据意味着滤波器可能会在错误的时间点应用观测数据，导致状态更新不准确</strong>。
这对于那些高度依赖精确时间信息的应用（如导航和跟踪系统）尤为重要。</p>
<p><strong>3. 数据丢失或重叠</strong></p>
<p>非同步数据可能导致数据在时间轴上出现重叠或缺口。例如<strong>，一个传感器可能在另一个传感器的两次读数之间多次更新，或者在长时间内没有更新。这种情况下，直接处理可能导致某些观测数据被忽略或重复计算，影响滤波器的性能</strong>。</p>
<h3 id="卡尔曼滤波的结构和限制">卡尔曼滤波的结构和限制</h3>
<ol type="1">
<li><p><strong>模型依赖性</strong>：
卡尔曼滤波依赖于一个预先定义好的线性模型（或在扩展卡尔曼滤波和无迹卡尔曼滤波中的非线性模型近似）。这个模型包括状态转移矩阵和观测矩阵，它们必须在滤波器初始化时就确定下来。如果系统的动态特性改变（例如，添加了新的传感器或系统的运动模型改变），可能需要重新定义这些模型矩阵。</p></li>
<li><p><strong>系统维度</strong>：
卡尔曼滤波在设计时需要确定状态向量的维度。如果需要加入新的状态变量（比如从新传感器获得的额外数据），通常需要重新设计整个状态向量和相关的处理矩阵，这可能涉及到重新设计状态转移和观测矩阵，以及相应的噪声协方差矩阵。</p></li>
<li><p><strong>实时性和适应性</strong>：
卡尔曼滤波器是为了连续、实时的数据流设计的，其强大的实时更新能力在许多应用中非常有用。然而，对于动态变化的系统配置或异步数据源的适应性则不如因子图灵活。</p></li>
</ol>
<p>虽然卡尔曼滤波在处理线性系统、实时跟踪等方面有其固有优势，但在系统动态变化较大、数据源频繁变动或需要处理高度非线性系统时，因子图提供了更高的灵活性和扩展性。因子图的结构使其能够更容易地适应系统配置的变化，而不需要进行大规模的系统重设计。这使得因子图在多传感器融合、复杂环境导航等领域尤为适用。</p>
<h4 id="解决方法插值和数据缓冲"><strong>解决方法：插值和数据缓冲</strong></h4>
<p>为了解决这些问题，卡尔曼滤波器通常采用以下策略：</p>
<ul>
<li><p><strong>插值</strong>：通过插值方法（如线性插值、样条插值等）创建虚拟的观测数据，填补时间上的缺口，使得每个时间步都有相应的数据输入。这有助于保持滤波器的连续性和准确性。</p></li>
<li><p><strong>数据缓冲</strong>：将来自不同传感器的数据存储在缓冲区中，直到收集到所有相关传感器的数据为止。然后，根据这些数据的时间戳一起处理它们。这样可以保证数据在时间上的一致性，减少由于时间错配引起的误差。</p></li>
</ul>
<p>这两种方法使得卡尔曼滤波器能够更加稳定和准确地处理来自多源的非同步数据，从而提高系统的整体性能。</p>
<h3 id="因子图的优势"><strong>因子图的优势</strong></h3>
<p>相比之下，因子图提供了一个更灵活的框架来处理非同步数据。因子图是一种图形模型，它以图的形式表示变量之间的条件依赖关系。在因子图中，每个传感器的读数可以作为一个因子被添加到图中，这些因子与它们影响的状态变量相关联。如果传感器数据是非同步的，可以：</p>
<ul>
<li><strong>动态添加因子</strong>：根据每个传感器的时间戳动态地向图中添加新的因子。这意味着每个传感器更新只影响相关的状态变量，不需要人为地同步所有数据。</li>
<li><strong>时间标记</strong>：每个因子可以携带时间信息，因此状态更新可以在正确的时间点进行，与数据实际测量的时间相匹配。</li>
</ul>
<p>因此，因子图模型通过在合适的时间点添加因子来自然地处理非同步的传感器数据，从而避免了在卡尔曼滤波器中必须进行的数据插值或同步。这样不仅简化了处理过程，而且可能提高了系统的整体性能和精度。</p>
<p>因子图的结构允许在不中断现有系统的情况下动态地添加新的节点和边。这在处理如下情况时特别有用：</p>
<ul>
<li><strong>新增数据源</strong>：可以将新传感器数据直接作为新因子加入图中，与相关的状态节点连接，无需改变现有的其他因子或节点。</li>
<li><strong>系统扩展</strong>：在因子图中，系统的扩展通常只涉及向图中添加更多的节点和边，而不需要重新配置整个系统的基本结构。</li>
</ul>
<h3 id="因子图处理和识别不同的传感器">因子图处理和识别不同的传感器</h3>
<p>要在代码层面正确地处理和区分不同类型的传感器数据（如IMU和GNSS），你通常需要依赖于数据本身的元数据，这些元数据包括数据类型、时间戳等信息。让我们从这两个方面（实际实现和理论理解）来探讨你的问题：</p>
<h4 id="代码层面如何识别和处理不同的传感器数据">代码层面：如何识别和处理不同的传感器数据</h4>
<p>在现实世界的应用中，每个传感器的输出通常会被标记有其类型，可能还包括精确的时间戳。这允许你在接收数据时进行适当的处理。以下是一个简化的例子，展示如何在接收数据时识别和处理IMU与GNSS数据：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IMUData</span> {</span><br><span class="line">    <span class="type">double</span> acceleration[<span class="number">3</span>];  <span class="comment">// 加速度数据</span></span><br><span class="line">    <span class="type">double</span> gyro[<span class="number">3</span>];          <span class="comment">// 陀螺仪数据</span></span><br><span class="line">    <span class="type">double</span> timestamp;        <span class="comment">// 时间戳</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GNSSData</span> {</span><br><span class="line">    <span class="type">double</span> latitude;</span><br><span class="line">    <span class="type">double</span> longitude;</span><br><span class="line">    <span class="type">double</span> altitude;</span><br><span class="line">    <span class="type">double</span> timestamp;        <span class="comment">// 时间戳</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::variant&lt;IMUData, GNSSData&gt; SensorData; <span class="comment">// 使用C++17标准的std::variant来处理不同类型的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理IMU数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processIMUData</span><span class="params">(<span class="type">const</span> IMUData&amp; data)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Processing IMU Data at timestamp: "</span> &lt;&lt; data.timestamp &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 添加IMU因子到因子图等</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理GNSS数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processGNSSData</span><span class="params">(<span class="type">const</span> GNSSData&amp; data)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Processing GNSS Data at timestamp: "</span> &lt;&lt; data.timestamp &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 添加GNSS因子到因子图等</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理传感器数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> SensorData&amp; sensorData)</span> </span>{</span><br><span class="line">    std::<span class="built_in">visit</span>([&amp;](<span class="keyword">auto</span>&amp;&amp; data) {</span><br><span class="line">        <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(data)&gt;;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, IMUData&gt;) {</span><br><span class="line">            <span class="built_in">processIMUData</span>(data);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, GNSSData&gt;) {</span><br><span class="line">            <span class="built_in">processGNSSData</span>(data);</span><br><span class="line">        }</span><br><span class="line">    }, sensorData);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    IMUData imuData = {{<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>}, {<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>}, <span class="number">0.1</span>};</span><br><span class="line">    GNSSData gnssData = {<span class="number">34.05</span>, <span class="number">-118.25</span>, <span class="number">100</span>, <span class="number">0.2</span>};</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processData</span>(imuData);</span><br><span class="line">    <span class="built_in">processData</span>(gnssData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="理论层面为什么因子图能实现即插即用">理论层面：为什么因子图能实现即插即用</h4>
<p>因子图的设计非常适合于处理复杂的多源信息融合问题，主要有以下几个理由：</p>
<ol type="1">
<li><p><strong>模块化</strong>：因子图通过因子来定义变量间的关系。每个传感器的数据可以被视为一个因子，这些因子可以独立地被添加到图中。因此，不同类型和不同时间的传感器数据可以作为独立的因子插入，而不会影响图中的其他部分。</p></li>
<li><p><strong>灵活性</strong>：由于因子图中各个因子的独立性，新的数据可以在任何时点加入图中，而不需要按照特定的顺序。这对于处理具有不同采样率和可能不同步到达的传感器数据尤其有用。</p></li>
<li><p><strong>扩展性</strong>：因子图可以容易地扩展以包含新的变量和因子，使得它非常适合于动态环境和在线更新的场景。</p></li>
</ol>
<p>因子图允许在不重新整个系统的情况下，根据新接收到的数据进行局部更新，这使得它非常适合于需要实时或近实时性能的应用，如动态的机器人导航和车辆定位系统。</p>
<h2 id="为什么要引进g_ii-i_dtimes-d">为什么要引进<span class="math inline">\(G_i^i=-I_{d\times d}\)</span></h2>
<blockquote>
<p>关于这个莫名的公式可以看看isam的公式，这个就是对那个公式的补充点</p>
</blockquote>
<p>在因子图和图优化中进行线性化处理时，引入矩阵<span class="math inline">\(G_i^i = -I_{d \times
d}\)</span>是为了便于表达和操作线性化的状态变化量。这里，$ I_{d d} <span class="math inline">\(表示 \( d \)-维的单位矩阵。矩阵 \( G_i^i \)
的作用是在数学表达式中简化状态变量\)</span>x_i$的运算，从而使得该线性系统易于使用线性代数技术求解。</p>
<p>在线性化的SLAM或图优化问题中，我们通常处理的是两类项：</p>
<ol type="1">
<li><strong>过程模型项</strong>：它们涉及从一个状态<span class="math inline">\(x_{i-1}\)</span> 到下一个状态$
x_i$的过渡，如机器人的运动模型。</li>
<li><strong>测量模型项</strong>：涉及从状态变量到测量变量的映射，如从机器人的位置到传感器观测的映射。</li>
</ol>
<p><strong>引入 $G_i^i = -I_{d d} $</strong></p>
<p>在方程 (6) 中，我们考虑了状态变量 <span class="math inline">\(x_i\)</span>和<span class="math inline">\(x_{i-1}\)</span>之间的关系。线性化后的模型需要处理这些状态变量的增量<span class="math inline">\(\delta x_i\)</span>和<span class="math inline">\(\delta
x_{i-1}\)</span>。线性化过程后的表达式为：</p>
<p><span class="math display">\[
f_i(x_{i-1}, u_i) - x_i \approx \{ f_i(x_{i-1}^0, u_i) + F_i^{i-1}
\delta x_{i-1} \} - \{ x_i^0 + \delta x_i \}
\]</span> 要将这个方程转换成标准的线性形式，我们需要确保$ x_i $ 和<span class="math inline">\(\delta
x_{i-1}\)</span>在同一方程中有适当的正负号。在这里，引入<span class="math inline">\(G_i^i = -I_{d \times d}\)</span>允许我们将$x_i $
项简单地表示为加法形式的负增量，即：</p>
<p><span class="math display">\[
F_i^{i-1} \delta x_{i-1} - \delta x_i = F_i^{i-1} \delta x_{i-1} + G_i^i
\delta x_i
\]</span> 这样，线性方程更容易处理，因为它将状态变化量<span class="math inline">\(\delta
x_i\)</span>直接以线性代数的标准形式表示，允许使用矩阵运算直接进行计算。</p>
<p><strong>线性最小二乘问题</strong></p>
<p>通过引入<span class="math inline">\(G_i^i = -I_{d \times
d}\)</span>整个问题可表示为一个标准的线性最小二乘问题：</p>
<p><span class="math display">\[
\delta^* = \underset{\delta}{\operatorname*{argmin}} \left\{
\sum_{i=1}^M \| F_i^{i-1} \delta x_{i-1} + G_i^i \delta x_i + a_i
\|_{\Lambda_i}^2 + \sum_{k=1}^K \| H_k^{i_k} \delta x_{i_k} + J_k^{j_k}
\delta l_{j_k} - c_k \|_{\Sigma_k}^2 \right\}
\]</span>
这个形式使得应用线性代数和优化方法成为可能，从而可以有效求解大规模SLAM问题。</p>
<h2 id="信息矩阵i">信息矩阵<span class="math inline">\(I\)</span></h2>
<p>在机器人定位和地图构建的问题中，通常涉及到估计机器人在环境中的位置轨迹
<span class="math inline">\(X\)</span>以及环境本身的结构地图 <span class="math inline">\(L\)</span>。在这种情况下，信息矩阵 <span class="math inline">\(\mathcal{I}\)</span>，也被称为费舍尔信息矩阵，是用来表示这些未知量的不确定性和相互依赖关系的关键工具。</p>
<p>信息矩阵 <span class="math inline">\(\mathcal{I}\)</span>
是由雅可比矩阵 <span class="math inline">\(A\)</span>（或系统的设计矩阵）通过 <span class="math inline">\(A^T A\)</span>
计算得到的。这个矩阵可以从以下几个方面描述机器人轨迹和地图内部的信息.</p>
<ol type="1">
<li><strong>量化不确定性:</strong>
<ul>
<li>对角线元素：<strong>信息矩阵的对角线元素量化了每个参数（位置或地图特征）的信息量或确信度</strong>。对角线元素的值越大，表示对应参数的不确定性越小，我们对该参数的估计越精确。</li>
<li>非对角线元素：<strong>非对角线元素描述了参数之间的依赖关系或相关性。</strong>例如，<strong>如果位置
<span class="math inline">\(x_i\)</span> 和位置 <span class="math inline">\(x_j\)</span>（或地图特征）在矩阵中的对应元素非零，这表明这两个位置（或特征）的估计值相互依赖</strong>。</li>
</ul></li>
<li><strong>编码相关性</strong>:
<ul>
<li>分块 <span class="math inline">\(\mathcal{I}_{XL}\)</span> 和 <span class="math inline">\(\mathcal{I}_{XL}^T\)</span>
特别重要，因为它们编码了轨迹 <span class="math inline">\(X\)</span>
和地图 <span class="math inline">\(L\)</span>
之间的相关性。<strong>这意味着机器人在特定位置的估计如何依赖于地图的特定特征，</strong>
反之亦然。这种相关性对于同时定位和地图构建（SLAM）至关重要，因为它帮助系统同时解决导航和地图创建的问题。</li>
</ul></li>
<li><strong>优化和解算:</strong>
<ul>
<li>在实际应用中，基于信息矩阵的结构，可以采用更有效的数值方法来解决估计问题，<strong>如使用稀疏矩阵技术处理大规模SLAM问题。信息矩阵的稀疏性表明很多参数之间的依赖性较低，这可以大大减少计算量。</strong></li>
</ul></li>
</ol>
<p>信息矩阵 <span class="math inline">\(\mathcal{I}\)</span>
不仅提供了对机器人轨迹和地图每一部分的内部信息的详尽描述，而且还通过其结构揭示了不同部分之间的相互作用和依赖性，从而在理论和实践中都是解决SLAM问题的核心部分。</p>
<p>矩阵 <span class="math inline">\(\mathcal{I}\)</span> 是通过矩阵
<span class="math inline">\(A\)</span> 的转置乘以 <span class="math inline">\(A\)</span> 计算得到的，这里 <span class="math inline">\(A\)</span> 被分为两部分：对应于机器人轨迹 <span class="math inline">\(X\)</span> 的 <span class="math inline">\(A_X\)</span> 和对应于地图 <span class="math inline">\(L\)</span> 的 <span class="math inline">\(A_L\)</span>。</p>
<p>矩阵 <span class="math inline">\(\mathcal{I}\)</span>
的结构表明它分为四个部分：</p>
<ol type="1">
<li><span class="math inline">\(A_X^T
A_X\)</span>：这是左上角的块，代表轨迹 <span class="math inline">\(X\)</span> 内部的信息。</li>
<li><span class="math inline">\(A_L^T
A_L\)</span>：这是右下角的块，代表地图 <span class="math inline">\(L\)</span> 内部的信息。</li>
<li><span class="math inline">\(\mathcal{I}_{XL}\)</span> 和 <span class="math inline">\(\mathcal{I}_{XL}^T\)</span>：这两个块分别位于非对角线的位置，<span class="math inline">\(\mathcal{I}_{XL} \triangleq A_X^T A_L\)</span>
和其转置表示轨迹 <span class="math inline">\(X\)</span> 和地图 <span class="math inline">\(L\)</span> 之间的相关性。</li>
</ol>
<p><span class="math display">\[
\mathcal{I}_{XL} \triangleq A_X^T A_L
\]</span></p>
<p>表示的是 <span class="math inline">\(A_X\)</span> 和 <span class="math inline">\(A_L\)</span> 之间的交叉信息，它编码了机器人状态
<span class="math inline">\(X\)</span> 和地图 <span class="math inline">\(L\)</span> 之间的相关性。对角线块 <span class="math inline">\(A_X^T A_X\)</span> 和 <span class="math inline">\(A_L^T A_L\)</span>
表明它们是“带对角线”的，这通常意味着这些块主要关注各自的内部结构和相互作用，而不是外部的。</p>
<p>关于信息矩阵和残差</p>
<p>标准化残差考虑到了模型和观测的不确定性，这种不确定性可以通过残差的协方差矩阵来量化，而这个协方差矩阵的估计依赖于参数的协方差矩阵，即信息矩阵的逆。因此，信息矩阵
I
通过其逆的形式，直接影响到标准化残差的计算，特别是在决定各残差分量的权重时。</p>
<h2 id="关于ax-b-中a和b的物理意义">关于AX-b 中A和b的物理意义</h2>
<p>在SLAM问题中，机器人的动态与环境交互通过一系列的状态转移和观测更新来描述。<strong>矩阵<span class="math inline">\(A\)</span>
在这个问题中的作用，是将这些动态和交互的关系转化为数学形式，特别是以线性化的方式来近似非线性系统的行为。</strong></p>
<p><strong>矩阵 <span class="math inline">\(A\)</span>
的意义：</strong></p>
<ol type="1">
<li>物理意义：矩阵 <span class="math inline">\(A\)</span>
表示系<strong>统状态变量之间的关系，以及状态变量与观测之间的线性关系。</strong>具体来说：
<ul>
<li>运动模型部分：矩阵<span class="math inline">\(F_i^{i-1}\)</span> 和
<span class="math inline">\(G_i^i\)</span> 表示从状态 <span class="math inline">\(x_{i-1}\)</span>到状态 <span class="math inline">\(x_i\)</span>的线性化运动模型。这些块表示了机器人如何从一个位置或方向移动到下一个位置，通常基于机器人的控制指令如转向和前进。描绘了状态之间的转移关系。</li>
<li>观测模型部分：矩阵 <span class="math inline">\(H_k^{i_k}\)</span>)和
<span class="math inline">\(J_k^{j_k}\)</span> 表示状态 <span class="math inline">\(x_{i_k}\)</span>)和地标 <span class="math inline">\(l_{j_k}\)</span>)如何影响第 <span class="math inline">\(k\)</span>
次观测。这反映了如何从当前状态和地标位置预测观测值例如，从摄像头或激光雷达。通过
<span class="math inline">\(H_k^{i_k}\)</span> 和 <span class="math inline">\(J_k^{j_k}\)</span>
描述的块，这些块表明如何从当前的状态和地标位置预测可能的观测结果 <span class="math inline">\(z_k\)</span>。</li>
</ul></li>
</ol>
<p><strong>向量 <span class="math inline">\(b\)</span></strong>：向量
<span class="math inline">\(b\)</span>
通常<strong>包含观测数据与由模型预测的状态转移或观测的差异</strong>。在SLAM中，<span class="math inline">\(b\)</span> 可能由实际观测值 <span class="math inline">\(z_k\)</span>
减去根据当前状态估计和地标估计得到的预测观测值构成。</p>
<p>计算意义：在最优化问题中，我们通常求解最小化 <span class="math inline">\((|A\delta -
b|_2^2)\)</span>，这是一个最小二乘问题，意味着我们在寻找最佳的状态变量更新
(<span class="math inline">\(\delta\)</span>)，使得线性化模型的预测尽可能接近实际观测和运动指令的结果。</p>
<p><strong>为什么 <span class="math inline">\(A\)</span>重要：</strong></p>
<ul>
<li>(<span class="math inline">\(A\)</span>)
矩阵<strong>捕捉了机器人动态和环境的整体结构，</strong>这是理解和解决SLAM问题的核心。正确构建和更新这个矩阵对于准确地估计机器人的状态和地图至关重要。</li>
<li>矩阵的稀疏性表明大多数状态变量不直接相互影响，这在数值计算上是有利的。稀疏矩阵技术可以显著提高求解SLAM问题的效率。</li>
</ul>
<p>因此，矩阵A
通过其块状结构和各个元素，捕捉了机器人如何移动（动态）和如何观察周围环境（观测）的数学描述。这不仅包括了机器人状态的转移关系，还包括了状态与环境地标之间的相互作用。通过优化问题最小化$|A-
b|_2^2
$，我们实际上是在调整对机器人状态和地图的估计，使得这些线性化的预测尽可能贴近实际观测，从而实现同时定位与地图构建的目的。</p>
<p>在SLAM问题中，矩阵 <span class="math inline">\(A\)</span> 和向量
<span class="math inline">\(b\)</span>
的物理意义及其在优化问题中的作用是核心部分，反映了状态估计的数学模型与实际操作间的联系:</p>
<p><strong>最小化正规方程 <span class="math inline">\(A^T A x = A^T
b\)</span></strong></p>
<p>在SLAM问题的线性化模型中，我们通常希望找到一个状态变量的更新量 <span class="math inline">\(\delta\)</span>，使得模型预测尽可能贴近实际的观测。具体来说，我们尝试最小化以下目标函数：</p>
<p><span class="math display">\[
\| A \delta - b \|_2^2
\]</span></p>
<ul>
<li><span class="math inline">\(|\cdot|_2^2\)</span>
表示二范数的平方，用于度量误差的大小。</li>
<li><span class="math inline">\(A \delta\)</span>
表示对当前状态估计的改正（或更新）。</li>
<li><span class="math inline">\(b\)</span>
是观测数据与模型预测之间的差异。</li>
</ul>
<p>解决这个最小化问题通常涉及到求解正规方程：</p>
<p><span class="math display">\[A^T A \delta = A^T b\]</span></p>
<ul>
<li><span class="math inline">\(A^T A\)</span>
是一个方阵，通常更易于处理，尤其是当 <span class="math inline">\(A\)</span>
是稀疏或结构化的时，这种方法效率更高。</li>
<li><span class="math inline">\(A^T b\)</span>
是一个向量，表示在当前误差度量下，最佳更新方向的投影。</li>
</ul>
<p>通过最小化这个误差，我们在数学上是在寻找一个向量 <span class="math inline">\(\delta\)</span>，使得 <span class="math inline">\(A \delta\)</span> 尽可能接近 <span class="math inline">\(b\)</span>，即尝试对预测的状态和观测进行校正，以逼近真实的观测值。</p>
<h2 id="滤波器与平滑器">滤波器与平滑器</h2>
<p>在SLAM（Simultaneous Localization and
Mapping，即同时定位与建图）问题中，信息矩阵 (I)
是一个关键的概念，用于表示机器人的状态（如位置和方向）以及环境中地标的不确定性。信息矩阵是协方差矩阵的逆，其中每个元素反映了状态变量之间的条件依赖性。在SLAM中，主要有两种处理信息的方法：滤波和平滑。</p>
<h3 id="滤波">滤波</h3>
<p><strong>滤波</strong>是一种在线处理方式，即它只处理当前和过去的信息，通常用于实时系统中。在滤波过程中，随着新数据的持续加入，为了维持计算的可管理性，旧的数据或状态往往需要被边缘化（移除），这导致信息矩阵趋向于变得密集。</p>
<ul>
<li>在滤波过程中，为了保持计算的实时性和可管理性，通常只会保留当前状态的信息，而把旧的状态信息“边缘化”（即从当前考虑的状态集中移除）。<strong>这种边缘化过程会引入额外的非零元素到信息矩阵中，因为边缘化旧状态意味着需要将这些状态的信息“分摊”到剩余的状态上</strong>。结果是信息矩阵变得密集，即使原来很多状态之间是条件独立的。</li>
<li>为了处理这种密集化，研究者通常会采用各种技术（如稀疏化技术）来移除信息矩阵中的某些链接，以减少计算负担。</li>
</ul>
<blockquote>
<p>解释为什么在SLAM中进行滤波操作时，边缘化过去的状态会导致信息矩阵变得密集。</p>
</blockquote>
<h4 id="示例情景"><strong>示例情景</strong></h4>
<p>假设一个机器人在一个简单的环境中沿直线移动，每移动一段距离记录一次位置，形成状态序列
<span class="math inline">\(X_1, X_2, X_3, \ldots,
X_t\)</span>。每个状态都与其前后状态有直接的连接（例如通过里程计测量），并可能与环境中的某些地标有关联。</p>
<p>在开始，信息矩阵 (I)
是稀疏的，因为只有时间上相邻的状态或与某个地标直接相关的状态之间存在连接。例如，如果(X_1)和(X_2)通过里程计相关联，那么在信息矩阵中，<span class="math inline">\(I_{1,1}，I_{1,2}，和I_{2,2}\)</span>是非零的。</p>
<h4 id="边缘化过程"><strong>边缘化过程</strong></h4>
<p>当机器人继续前进并且需要在滤波器中处理新的状态时（比如(X_{t+1})），为了保持计算的可管理性，较早的状态（比如(X_1))
可能会被边缘化掉。边缘化(X_1)意味着我们需要从当前激活的状态集中移除(X_1)的影响。</p>
<ul>
<li>原本(X_1)直接影响(X_2)，在边缘化(X_1)后，我们必须将(X_1)对(X_2)的影响“转移”给与(X_2)相关的其他状态，比如(X_3)。这意味着原先(X_1)与(X_3)可能没有直接关系，但在边缘化(X_1)后，(X_2)与(X_3)之间的关系需要加强，以反映从(X_1)到(X_3)的间接影响。</li>
</ul>
<p>当我们在状态估计或者滤波问题中进行边缘化时，我们的目标是将某些状态（例如
<span class="math display">\[X_1\]</span>）的影响通过与其相关联的其他状态（如
<span class="math display">\[X_2\]</span> 和 <span class="math display">\[X_3\]</span>）重新表达，而不是直接包括这些状态。这个过程在信息矩阵（或费舍尔信息矩阵）中的表示可以通过一个具体的数学过程来阐述。</p>
<p>假设我们的系统的信息矩阵 <span class="math display">\[\mathcal{I}\]</span> 分布如下，其中包含三个状态
<span class="math display">\[X_1\]</span>, <span class="math display">\[X_2\]</span>, 和 <span class="math display">\[X_3\]</span>： <span class="math display">\[
\mathcal{I} = \begin{bmatrix}
\mathcal{I}_{11} &amp; \mathcal{I}_{12} &amp; \mathcal{I}_{13} \\
\mathcal{I}_{21} &amp; \mathcal{I}_{22} &amp; \mathcal{I}_{23} \\
\mathcal{I}_{31} &amp; \mathcal{I}_{32} &amp; \mathcal{I}_{33}
\end{bmatrix}
\]</span> 在这里，<span class="math display">\[\mathcal{I}_{ij}\]</span>
表示状态 <span class="math display">\[X_i\]</span> 和状态 <span class="math display">\[X_j\]</span> 之间的信息量。</p>
<p>当我们决定边缘化状态 <span class="math display">\[X_1\]</span>，我们需要消除 <span class="math display">\[X_1\]</span> 的影响，并将其影响“转移”到与 <span class="math display">\[X_1\]</span> 相关的其他状态，比如 <span class="math display">\[X_2\]</span> 和 <span class="math display">\[X_3\]</span>。边缘化 <span class="math display">\[X_1\]</span> 的信息矩阵可以通过 Schur 补数得到：
<span class="math display">\[
\mathcal{I}_{\text{marginal}} = \mathcal{I}_{22:33} -
\mathcal{I}_{21:31}^T \mathcal{I}_{11}^{-1} \mathcal{I}_{21:31}
\]</span> 其中：</p>
<ul>
<li><span class="math display">\[\mathcal{I}_{22:33}\]</span> 表示除去与
<span class="math display">\[X_1\]</span>
相关的行和列后剩余的信息矩阵部分。</li>
<li><span class="math display">\[\mathcal{I}_{21:31}\]</span> 表示与
<span class="math display">\[X_1\]</span>
相关的其它状态的交叉信息块。</li>
</ul>
<p>假设原信息矩阵的块为： <span class="math display">\[
\mathcal{I}_{11} = \begin{bmatrix}
2
\end{bmatrix}, \quad \mathcal{I}_{21:31} = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}, \quad \mathcal{I}_{22:33} = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>进行计算： <span class="math display">\[
\mathcal{I}_{\text{marginal}} = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix} - \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix} \begin{bmatrix}
2
\end{bmatrix}^{-1} \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix} = \begin{bmatrix}
0 &amp; 0 \\
0 &amp; 0
\end{bmatrix}
\]</span></p>
<p>这个简化例子说明了如何通过矩阵运算处理边缘化。实际应用中，这个过程将导致
<span class="math display">\[\mathcal{I}_{22:33}\]</span>
的非对角线元素变得非零，表明 <span class="math display">\[X_2\]</span>
和 <span class="math display">\[X_3\]</span>
之间的新建立的依赖关系。这反映了从 <span class="math display">\[X_1\]</span> 到 <span class="math display">\[X_3\]</span> 的间接影响，即使在原始矩阵中 <span class="math display">\[X_2\]</span> 和 <span class="math display">\[X_3\]</span>
之间没有直接的依赖关系。随着更多状态的边缘化，信息矩阵将变得更加密集，反映出复杂的依赖关系网络。</p>
<h4 id="结果"><strong>结果</strong></h4>
<p>这个转移过程在信息矩阵中表现为原先为零的元素变成非零，因为(X_2)和(X_3)现在有了新的依赖关系。随着越来越多状态的边缘化，这种间接依赖会累积，导致信息矩阵逐渐从稀疏变为密集。</p>
<h4 id="几何直观"><strong>几何直观</strong></h4>
<p>可以想象，每个状态不仅与其直接的邻居有联系，还因为边缘化而与更多其他状态产生了联系。随着时间的推移，几乎每个状态都以某种方式间接地与其他所有状态连接，从而增加了信息矩阵中的非零元素数量，使矩阵变得密集。</p>
<p>这种密集化不仅增加了计算的复杂度，还可能影响滤波器的性能，因此在实际应用中，开发者会寻找各种方法（例如使用稀疏近似或选择性地保留关键状态）来尽可能减少这种影响。</p>
<h3 id="平滑">平滑</h3>
<p><strong>平滑</strong>则是一种离线处理方式，它考虑全部的数据（包括过去和未来的数据）。在平滑处理中，由于不需要边缘化任何状态（因为所有状态对计算都是可用的），所以关联的信息矩阵维持稀疏性，这是因为不存在需要通过边缘化引入新依赖的需求。</p>
<ul>
<li>平滑处理，相比于滤波，不会边缘化任何过去的状态。相反，它保留了所有历史和当前的状态信息，因此可以在整个时间线上提供更精确的状态估计。</li>
<li>在<strong>平滑方法中，由于不进行边缘化操作，所以不会引入额外的非零元素导致信息矩阵密集化。这意味着信息矩阵能够保持其原始的稀疏结构，其中非零元素主要集中在时间线上相邻状态之间的依赖关系。</strong>这种稀疏性是因为在大多数SLAM场景中，只有时间上相邻的状态或空间上邻近的地标才具有直接的相互依赖。</li>
</ul>
<p>因此，在与平滑信息矩阵 (I)
关联的MRF中，信息矩阵保持稀疏，<strong>主要是因为平滑处理不涉及边缘化过去的状态</strong>。这样，每个状态只与其直接相关的少数几个其他状态或地标相关联，而不是与整个历史状态集相关联，从而避免了矩阵的密集化。这种方法不仅保持了计算效率，而且通常能提供比滤波更为精确的状态估计。</p>
<p>用一个具体的数学例子来解释SLAM问题中平滑方法的信息矩阵是如何维持其稀疏性的。在这个例子中，我们考虑一个小规模的机器人轨迹，其中机器人在四个时间点上测量其位置。我们将看到在不进行边缘化的情况下，信息矩阵如何保持其结构。</p>
<p>假设有四个状态<span class="math inline">\(X_1, X_2, X_3,
X_4\)</span>，它们代表机器人在四个连续时间点的位置。在SLAM中，通常只有连续的状态之间存在直接的测量依赖关系。</p>
<p>在平滑方法中，信息矩阵I初始化时将反映状态之间的这些直接依赖关系。例如，如果我们假设每个状态只与其前后状态有关系，并且每个这样的依赖对信息矩阵贡献
(1) 的信息值，那么信息矩阵可能看起来像这样：</p>
<p><span class="math display">\[
I = \begin{bmatrix}
1 &amp; -1 &amp; 0 &amp; 0 \\
-1 &amp; 2 &amp; -1 &amp; 0 \\
0 &amp; -1 &amp; 2 &amp; -1 \\
0 &amp; 0 &amp; -1 &amp; 1
\end{bmatrix}
\]</span> 这里，对角线上的元素 (2)
表示一个状态依赖于其前后状态的信息总和（除了边界条件，即 (X_1) 和
(X_4)）。非对角线的 (-1) 表示状态 (X_i) 与 (X_{i+1}) 和 (X_{i-1})
之间的信息依赖。</p>
<p>在平滑方法中，由于不进行边缘化操作，<strong>我们保留所有历史状态的数据。这意味着在任何给定的时刻，我们都可以访问到所有历史和未来的状态信息，而不是只有当前和未来的状态</strong>。因此，信息矩阵的非零结构不会改变——它始终保持与初始时刻相同的稀疏模式。</p>
<p>这种方法的优点是，信息矩阵维持了其稀疏性，这大大减少了计算的复杂性和内存需求。例如，当使用稀疏矩阵技术处理大型SLAM问题时，这一特性非常重要。每个状态只与直接相邻的状态有关系，没有因边缘化而引入的额外复杂依赖关系。</p>
<p>这样的稀疏结构是高效处理大规模SLAM问题的关键，因为它减少了必须处理的数据量，并允许使用优化的数值方法来处理信息矩阵。</p>
<h3 id="为什么在平滑中仍然会有变量消除"><strong>为什么在平滑中仍然会有变量消除</strong></h3>
<p>尽管在平滑处理中，信息矩阵维持其稀疏性质，我们仍可能需要执行某种形式的变量消除，这主要是为了效率和算法实现上的考虑。例如，在求解线性系统时（如
<span class="math display">\[Ax =
b\]</span>），通常会采用一些数学技术来简化问题，比如通过Cholesky分解等。在这个过程中，创建弦图和消元树是为了优化这些数学操作：</p>
<ol type="1">
<li><p><strong>弦图的创建</strong>：在进行Cholesky分解等操作前，弦图能帮助我们识别并利用信息矩阵的稀疏结构，以减少计算过程中的填充（非零元素的添加）。</p></li>
<li><p><strong>消元树的建立</strong>：即便信息矩阵是稀疏的，构建消元树可以进一步提高解线性系统的效率。消元树能够指导计算顺序，确保依赖关系得到正确处理，并优化内存访问模式。</p></li>
</ol>
<p>因此，尽管平滑信息矩阵在理论上不需要通过边缘化来维护其稀疏性，但在实际计算和算法实现中，变量消除和相关的图形表示（如弦图和消元树）仍然是优化性能和保证算法效率的重要工具。</p>
<h3 id="消元树">消元树</h3>
<p>消元树是一种用来表示消除过程中变量依赖关系的树状结构，它帮助指导了矩阵分解过程中的计算流程，特别是在反向替代阶段。这里用一个具体的例子来说明这一点：</p>
<p>假设我们有一个系统的矩阵 <span class="math display">\[A\]</span>，我们想要进行Cholesky分解（假设<span class="math display">\[A\]</span>是对称正定的）。我们首先选择一个变量来消除，这通常是基于某种启发式方法，比如最小填充法或最小度法。</p>
<p>考虑以下矩阵：</p>
<p><span class="math display">\[
A = \begin{bmatrix}
4 &amp; 1 &amp; 0 &amp; 0 \\
1 &amp; 4 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 4 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 3 \\
\end{bmatrix}
\]</span></p>
<p><strong>第一步：消除第一个变量</strong></p>
<p>我们首先消除第一个变量，这会影响与它直接相连的变量（这里是第二个变量）。消除第一个变量后，更新矩阵（做适当的行和列操作）可能会导致非零元素填充原本为零的位置，即产生“填充”。</p>
<p><strong>弦图的形成</strong></p>
<p>在这个过程中，如果我们将每个变量和与它相邻的变量视为图的一个节点和边，消除一个变量相当于在图中移除一个节点及其相关的边，并可能在未被消除的相邻节点间添加新的边（如果它们之前不直接相连）。这个操作最终形成了一个弦图，即每个循环都至少有一个弦（非环的边）的图。</p>
<p><strong>构建消元树</strong></p>
<p>在构建弦图的基础上，消元树被定义为消除过程中的依赖关系图。例如：</p>
<ol type="1">
<li>将第一个被消除的变量作为树的根节点。</li>
<li>每次消除一个变量后，将受到影响的变量作为当前消除变量的子节点添加到树中。</li>
</ol>
<p>对于上面的矩阵，消元树可能如下：</p>
<ul>
<li>根节点为第一个被消除的变量。</li>
<li>第二个被影响的变量成为第一个节点的子节点。</li>
<li>依次类推，直到所有变量都被放置在树中。</li>
</ul>
<p><strong>在反向替代阶段的作用</strong></p>
<p>在进行例如Cholesky分解后，求解线性系统 <span class="math display">\[Ax = b\]</span> 需要先进行前代（使用 <span class="math display">\[L\]</span> 矩阵）和后代（使用 <span class="math display">\[L^T\]</span>
矩阵）。在后代过程中，消元树指导了计算的顺序：从树的叶子（最先消除的变量）开始，逐步向根节点（最后消除的变量）进行，确保在计算当前变量值之前，所有依赖于它的变量值已经被计算。</p>
<p>通过这种方式，消元树不仅帮助优化计算过程，还确保了在计算过程中遵循正确的依赖关系，有效地利用了矩阵的稀疏性质。</p>
<h2 id="qr分解">QR分解</h2>
<p>QR 分解是将矩阵 <span class="math display">\[A\]</span>
分解成一个正交矩阵 <span class="math display">\[Q\]</span>
和一个上三角矩阵 <span class="math display">\[R\]</span> 的方法。如果
<span class="math display">\[A\]</span> 是一个 <span class="math display">\[m \times n\]</span> 矩阵且 <span class="math display">\[m \geq n\]</span>，那么分解形式通常写为：</p>
<p><span class="math display">\[A = QR\]</span></p>
<p>其中，<span class="math display">\[Q\]</span> 是一个 <span class="math display">\[m \times m\]</span> 正交矩阵（<span class="math display">\[Q^T Q = QQ^T = I\]</span>），<span class="math display">\[R\]</span> 是一个 <span class="math display">\[m
\times n\]</span> 的上三角矩阵，其中除了前 <span class="math display">\[n\]</span>
行可能有非零元素外，其余部分全为零。在许多实际情况中，我们更关心 <span class="math display">\[R\]</span> 的前 <span class="math display">\[n
\times n\]</span> 部分，因为它是一个完全的上三角矩阵。</p>
<p>为什么 <span class="math display">\[R\]</span> 下面有一个0</p>
<p>在 <span class="math display">\[Q^T A = \left[\begin{array}{c} R \\ 0
\end{array}\right]\]</span> 的表达式中，<span class="math display">\[R\]</span> 是 <span class="math display">\[n
\times n\]</span> 的上三角矩阵，而下面的0表示在 <span class="math display">\[Q^T\]</span> 作用后，剩下 <span class="math display">\[m-n\]</span> 行都被消减到了零。这是因为 <span class="math display">\[Q\]</span> 通过正交变换将 <span class="math display">\[A\]</span> 的所有向量投影到一个由 <span class="math display">\[A\]</span> 的列空间张成的正交子空间。</p>
<p>如何进行QR分解</p>
<p>QR分解可以通过多种方式进行，包括Householder反射、Gram-Schmidt正交化或Givens旋转等。其中，Householder反射是最常用的方法，因为它具有很好的数值稳定性。</p>
<p>Householder反射:</p>
<ol type="1">
<li>选取一个列向量，构造一个反射矩阵 <span class="math display">\[H\]</span>，使得除了第一项外，该列的其余项变为零。</li>
<li>重复应用上述过程，每次将 <span class="math display">\[A\]</span>
的一个列向量（逐步从左到右）变为期望的上三角形式。</li>
<li>通过连续左乘不同的Householder矩阵（<span class="math display">\[H_1,
H_2, \ldots, H_n\]</span>），我们最终得到 <span class="math display">\[Q^T A = \left[\begin{array}{c} R \\ 0
\end{array}\right]\]</span>。</li>
</ol>
<p>QR分解在最小二乘中的应用</p>
<p>在最小二乘问题中，我们通常要最小化 <span class="math display">\[\|A\delta -
b\|_2^2\]</span>。通过QR分解，我们可以转化这个问题为：</p>
<p><span class="math display">\[\|Q^T(A\delta - b)\|_2^2 = \|R\delta -
Q^Tb\|_2^2\]</span></p>
<p>由于 <span class="math display">\[Q\]</span>
是正交的，所以转换不会改变二范数。因此，问题简化为最小化 <span class="math display">\[\|R\delta - d\|_2^2\]</span>（其中 <span class="math display">\[d\]</span> 是 <span class="math display">\[Q^Tb\]</span> 的前 <span class="math display">\[n\]</span> 个元素）加上 <span class="math display">\[\|e\|_2^2\]</span>（其中 <span class="math display">\[e\]</span> 是 <span class="math display">\[Q^Tb\]</span> 的剩余 <span class="math display">\[m-n\]</span> 个元素，代表方程的残差）。</p>
<p>由于 <span class="math display">\[R\]</span>
是上三角的，这个问题可以通过反向替换直接求解 <span class="math display">\[R\delta = d\]</span>，从而找到最小二乘解 <span class="math display">\[\delta^*\]</span>。</p>
<h2 id="为什么用cholesky-分解求解正规方程">为什么用Cholesky
分解求解正规方程</h2>
<p><strong>为什么使用 Cholesky 分解？</strong></p>
<ol type="1">
<li><p><strong>效率和稳定性</strong>：</p>
<p>​
<strong>效率</strong>：Cholesky分解相比于其他方法（如LU分解或QR分解）通常更为高效。它的计算复杂度大约是
<span class="math display">\[\frac{1}{3} n^3\]</span> 对于 <span class="math display">\[n \times n\]</span>
矩阵，而LU分解和QR分解的计算复杂度分别大约是 <span class="math display">\[\frac{2}{3} n^3\]</span> 和 <span class="math display">\[2n^3\]</span>。这使得Cholesky分解成为求解大型正定线性系统的首选方法。</p>
<p>​
<strong>稳定性</strong>：对于对称正定矩阵，Cholesky分解非常稳定。由于对称性和正定性保证了分解的成功执行，它避免了在数值分解过程中的潜在不稳定性。</p></li>
<li><p><strong>数值属性</strong>：</p>
<p>​
在数值线性代数中，Cholesky分解对于对称正定矩阵来说是一种数值上稳定的方法，特别是当矩阵
<span class="math display">\[A^T A\]</span>
的条件数相对较低时。这是因为它直接利用了矩阵的对称性和正定性。</p></li>
<li><p><strong>简化求解过程</strong>：</p>
<p>​ 通过Cholesky分解，矩阵 <span class="math display">\[A^T A\]</span>
被分解为一个下三角矩阵 <span class="math display">\[L\]</span>
和其转置的上三角矩阵 <span class="math display">\[L^T\]</span>
的乘积，即 <span class="math display">\[A^T A = L
L^T\]</span>。这种分解简化了线性系统的求解，因为只需先解下三角系统 <span class="math display">\[L \mathbf{y} = A^T \mathbf{b}\]</span>
获得临时向量 <span class="math display">\[\mathbf{y}\]</span>，然后解上三角系统 <span class="math display">\[L^T \mathbf{x} = \mathbf{y}\]</span> 获取最终解
<span class="math display">\[\mathbf{x}\]</span>。</p>
<p>​
这种分步求解的过程比直接求解原方程更易于处理，并且可以有效地利用现代计算机体系结构。</p></li>
</ol>
<p><strong>总结</strong></p>
<p>由于上述优点，Cholesky分解成为解决正定线性系统（特别是在涉及正规方程时）的理想选择，提供了一种高效、稳定的方法来求解最小二乘问题中的线性系统。这在实际应用中，如图优化、信号处理、统计数据分析等领域，具有广泛的应用。</p>
<h2 id="一些相关链接-不定时更新">一些相关链接 不定时更新</h2>
<h3 id="可以关注的blog-多源融合">可以关注的blog 多源融合</h3>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/Welson-WEN/posts">Welson WEN -
知乎 (zhihu.com)</a></p>
<h3 id="理论学习">理论学习</h3>
<h4 id="滤波优化算法">滤波优化算法</h4>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85865058">卡尔曼滤波：究竟滤了谁？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23971601/answer/770830003">关于卡尔曼滤波
如何通俗并尽可能详细地解释卡尔曼滤波？ - 司南牧(李韬)的回答 -
知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/76659512">SLAM找工作1.6
因子图优化（蜘蛛） - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://chargerkong.github.io/2021/05/26/%E5%9B%BE%E4%BC%98%E5%8C%96%EF%BC%88Graph-based%EF%BC%89/">个人github的blog
估计是大学生 写得还不错</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/404893786">GraphGNSSLib:
基于因子图技术的GNSS定位和GNSS RTK定位算法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.guyuehome.com/18321">SLAM14讲学习笔记（七）后端（BA与图优化，Pose
Graph优化的理论与公式详解、因子图优化）</a></p>
<p><a target="_blank" rel="noopener" href="https://longaspire.github.io/blog/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BB%8B%E7%BB%8D/#1-%E5%9B%A0%E5%AD%90%E5%9B%BE%E5%AE%9A%E4%B9%89">因子图介绍
YOLO</a></p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/910572">因子图和求和乘积算法
|IEEE期刊和杂志 |IEEE Xplore（IEEE的Xplore）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shyjhyp11/article/details/126938728">SLAM算法-因子图建模</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tfb760/article/details/127118096">学习随笔：机器人感知-因子图在SLAM中的应用</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/616060837">SLAM中后端优化的技术细节</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/128720019">干货：因子图优化的资源合集
算法发展脉络</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_16213565/7964103">计算机视觉
教材</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30139208">概率图模型之贝叶斯网络</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ljtx200888/article/details/114164685">csdn：SLAM后端：因子图优化</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/455851874">知乎：三.因子图优化学习---董靖博士在泡泡实验室的公开课学习</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/451555685">知乎：一.因子图优化学习---董靖博士在深蓝学院的公开课学习（1）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16p4y1U7gW/?spm_id_from=333.999.0.0&amp;vd_source=3cd19ffad1cc348f3d6969346e07e84c">贝叶斯派的概率图模型讲解概述</a></p>
<h3 id="代码编程">代码编程</h3>
<h4 id="gtsam库">GTSAM库</h4>
<p><a target="_blank" rel="noopener" href="https://xiaotaoguo.com/">自动驾驶 C++相关</a></p>
<p>[<a target="_blank" rel="noopener" href="https://xiaotaoguo.com/p/gtsam-usage-2/">[代码实践] GTSAM
学习记录（二）]</a></p>
<p><a target="_blank" rel="noopener" href="https://www.helywin.com/posts/20220321115224/#:~:text=%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%E7%9A%84%E5%9B%A0%E5%AD%90%E5%9B%BE%E5%A6%82%E5%9B%BE3%E6%89%80%E7%A4%BA%E3%80%82%20%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%89%E4%B8%AA%E5%8F%98%E9%87%8F%24x_1%24%EF%BC%8C%24x_2%24%E5%92%8C%24x_3%24%E4%BB%A3%E8%A1%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%9A%8F%E6%97%B6%E9%97%B4%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E5%9C%A8%E5%9B%BE%E4%B8%AD%E7%94%B1%E5%BC%80%E5%9C%86%E7%9A%84%E5%8F%98%E9%87%8F%E8%8A%82%E7%82%B9%E5%91%88%E7%8E%B0%E3%80%82%20%E5%9C%A8%E8%AF%A5%E4%BE%8B%E5%AD%90%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A7%BF%E6%80%81%24x_1%24%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%E4%B8%80%E5%85%83%E5%9B%A0%E5%AD%90%24f_0%20%28x_1%29%24%EF%BC%8C%E7%BC%96%E7%A0%81%E6%88%91%E4%BB%AC%E5%85%B3%E4%BA%8E%24x_1%24%E7%9A%84%E5%85%88%E9%AA%8C%E7%9F%A5%E8%AF%86%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%BA%8C%E5%85%83%E5%9B%A0%E5%AD%90%E5%B0%86%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%A7%BF%E6%80%81%E8%81%94%E7%B3%BB%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%24f_1%20%28x_1%2C%20x_2%20%3B%20o_1%29%24%E5%92%8C%24f_2,x_3%20%3B%20o_2%29%24%EF%BC%8C%E5%85%B6%E4%B8%AD%24o_1%24%E5%92%8C%24o_2%24%E4%BB%A3%E8%A1%A8%E9%87%8C%E7%A8%8B%E6%B5%8B%E9%87%8F%E5%80%BC%E3%80%82%20%E4%B8%8B%E9%9D%A2%E7%9A%84C%2B%2B%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8C%85%E5%90%AB%E5%9C%A8GTSAM%E4%B8%AD%E4%BD%9C%E4%B8%BA%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%BA%86%E5%9B%BE3%E4%B8%AD%E7%9A%84%E5%9B%A0%E5%AD%90%E5%9B%BE%EF%BC%9A%20%E4%B8%8A%E9%9D%A2%EF%BC%8C%E7%AC%AC2%E8%A1%8C%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84%E5%9B%A0%E5%AD%90%E5%9B%BE%E3%80%82%20%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E5%9C%A8%E7%AC%AC5-8%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%9B%A0%E5%AD%90%24f_0%20%28x_1%29%24%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%9C%A8slam%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%2A%2A%20%E3%80%82">因子图和GTSAM--实践介绍—个人blog含代码讲解</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/543465483">Factor Graphs and
GTSAM</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/c_1025765837919113216">因子图优化
slam找工作</a></p>
<h4 id="代码能力">代码能力</h4>
<p><a target="_blank" rel="noopener" href="https://xiaotaoguo.com/">自动驾驶 C++相关</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/c_1025765837919113216">因子图优化
slam找工作</a></p>
<p>https://www.zhihu.com/people/mach999/posts</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.lling.online">汐汐</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.lling.online/2024/05/04/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">https://www.lling.online/2024/05/04/%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.lling.online" target="_blank">汐汐的成长之路</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%A0%E5%AD%90%E5%9B%BE/">因子图</a></div><div class="post_share"><div class="social-share" data-image="/img/top-img/001%20FGO%20question.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/05/12/%E8%AE%BA%E6%96%87%E2%80%94%E2%80%94SAM/" title="论文粗略阅读——Sqare Root SAM"><img class="cover" src="/img/top-img/paper%20reading.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">论文粗略阅读——Sqare Root SAM</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/18/%E8%AE%BA%E6%96%87-Review-of-Factor-Graphs-for-Robust-GNSS/" title="论文阅读——Factor Graphs for Robust GNSS"><img class="cover" src="/img/top-img/paper%20reading.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-18</div><div class="title">论文阅读——Factor Graphs for Robust GNSS</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/miao.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">汐汐</div><div class="author-info__description">总有一些坚持，能从一寸冰封的土壤里培育出十万朵怒放的蔷薇❀❀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53131867?type=blog"><i class="fab custom csdn"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xi-song" target="_blank" title="GitHub"><i class="iconfont icon-GitHub" style="color: #24292e;"></i></a><a class="social-icon" href="/%5Cimg%5Cali.jpg" target="_blank" title="Wechat"><i class="iconfont icon-weixin" style="color: #28c445;"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_53131867?type=blog" target="_blank" title="CSDN"><i class="iconfont icon-csdn" style="color: #dd1700;"></i></a><a class="social-icon" href="https://www.zhihu.com/people/shui-meng-tong-hua" target="_blank" title="Zhihu"><i class="iconfont icon-zhihu" style="color: #0066ff;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到汐汐的知识小窝，不定期分享导航定位，编程，科研相关知识，欢迎关注收藏噢~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">因子图优化相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%81%94%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E6%9D%A5%E6%8F%8F%E8%BF%B0%E5%AF%BC%E8%88%AA%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">为什么用联合概率密度来描述导航问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">解释1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A2"><span class="toc-number">1.1.2.</span> <span class="toc-text">解释2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E8%81%94%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%88%86%E5%B8%83-%E6%B1%82%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">如何根据联合概率密度分布
求解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%A6%82%E7%8E%87%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.3.</span> <span class="toc-text">关于概率推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%AF%8F%E4%B8%AA%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE%E6%98%AF%E7%8B%AC%E7%AB%8B%E7%9A%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A7%82%E6%B5%8B%E6%A8%A1%E5%9E%8B%E8%BF%98%E4%BE%9D%E8%B5%96%E4%BA%8E%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">在给定系统状态的情况下，每个观测数据是独立的。
为什么观测模型还依赖于系统状态？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A1-1"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">解释1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A2-1"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">解释2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%AE%8B%E5%B7%AE"><span class="toc-number">1.4.</span> <span class="toc-text">关于残差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%B2%81%E6%A3%92%E6%A0%B8%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">关于鲁棒核函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AE%8B%E5%B7%AE%E5%8F%AF%E4%BB%A5%E4%BD%93%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%80%BC"><span class="toc-number">1.5.1.</span> <span class="toc-text">为什么残差可以体现异常值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AE%8B%E5%B7%AE%E8%BE%83%E5%A4%A7%E7%9A%84%E6%97%B6%E5%80%99-%E6%96%BD%E5%8A%A0%E8%BE%83%E5%A4%A7%E7%9A%84%E6%83%A9%E7%BD%9A"><span class="toc-number">1.5.2.</span> <span class="toc-text">什么是残差较大的时候
施加较大的惩罚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BE%83%E5%A4%A7%E7%9A%84%E6%83%A9%E7%BD%9A"><span class="toc-number">1.5.3.</span> <span class="toc-text">什么是较大的惩罚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#herb%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.5.4.</span> <span class="toc-text">🌿比较好的例子​！！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%95%B0%E5%80%BC%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.5.5.</span> <span class="toc-text">具体数值的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%84%E7%90%86%E5%AF%BC%E8%88%AA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">因子图为什么处理导航相关问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%B8%AD%E5%90%84%E4%B8%AA%E5%9B%A0%E5%AD%90%E5%AF%B9%E4%BA%8E%E6%89%A7%E8%A1%8C%E5%A6%82%E5%9B%BE%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96%E5%92%8C%E6%8E%A8%E6%96%AD%E7%AD%89%E6%93%8D%E4%BD%9C%E6%98%AF%E9%9D%9E%E5%B8%B8%E6%9C%89%E6%95%88%E7%9A%84"><span class="toc-number">1.7.</span> <span class="toc-text">在因子图中，各个因子对于执行如图搜索、优化和推断等操作是非常有效的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">因子图的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%9B%BE%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96%E5%92%8C%E6%8E%A8%E6%96%AD%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">1.7.2.</span> <span class="toc-text">执行图搜索、优化和推断的效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.7.3.</span> <span class="toc-text">效率的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE%E9%80%9A%E8%BF%87%E5%B0%86%E6%B5%8B%E9%87%8F%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%8F%82%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8F%98%E9%87%8F%E6%9D%A5%E7%AE%80%E5%8C%96%E9%97%AE%E9%A2%98%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.8.</span> <span class="toc-text">因子图通过将测量值作为已知的参数而不是变量来简化问题表示？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%BC%98%E5%8C%96%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81"><span class="toc-number">1.9.</span> <span class="toc-text">因子图优化如何更新节点状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE%E7%9A%84%E8%BF%AD%E4%BB%A3%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.</span> <span class="toc-text">因子图的迭代优化算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9B%A0%E5%AD%90%E5%9B%BE%E7%9A%84%E8%AF%AF%E5%B7%AE%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">关于因子图的误差函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.11.1.</span> <span class="toc-text">一个具体的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%92%8C%E8%AF%AF%E5%B7%AE%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">模型和误差函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pdr%E8%A7%82%E6%B5%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">PDR观测模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">雅可比矩阵计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gtsam%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.11.1.4.</span> <span class="toc-text">GTSAM中的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%B8%AD%E4%B8%80%E7%A7%8D"><span class="toc-number">1.11.1.4.1.</span> <span class="toc-text">其中一种</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E7%A7%8D"><span class="toc-number">1.11.1.4.2.</span> <span class="toc-text">另一种</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%A0%E5%AD%90%E5%9B%BE%E4%B8%8D%E6%98%AF%E5%8D%A1%E5%B0%94%E6%9B%BC"><span class="toc-number">1.12.</span> <span class="toc-text">为什么是因子图不是卡尔曼</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE%E7%9A%84%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0"><span class="toc-number">1.13.</span> <span class="toc-text">因子图的增量更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E4%BC%98%E5%8C%96"><span class="toc-number">1.13.1.</span> <span class="toc-text">批量优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E4%BC%98%E5%8C%96"><span class="toc-number">1.13.2.</span> <span class="toc-text">增量优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE"><span class="toc-number">1.13.3.</span> <span class="toc-text">如何处理新增数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE%E7%9A%84%E5%8D%B3%E6%8F%92%E5%8D%B3%E7%94%A8"><span class="toc-number">1.14.</span> <span class="toc-text">因子图的即插即用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.14.1.</span> <span class="toc-text">与卡尔曼滤波的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E9%99%90%E5%88%B6"><span class="toc-number">1.14.2.</span> <span class="toc-text">卡尔曼滤波的结构和限制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%8F%92%E5%80%BC%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">解决方法：插值和数据缓冲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.14.3.</span> <span class="toc-text">因子图的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E5%AD%90%E5%9B%BE%E5%A4%84%E7%90%86%E5%92%8C%E8%AF%86%E5%88%AB%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BC%A0%E6%84%9F%E5%99%A8"><span class="toc-number">1.14.4.</span> <span class="toc-text">因子图处理和识别不同的传感器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%92%8C%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">1.14.4.1.</span> <span class="toc-text">代码层面：如何识别和处理不同的传感器数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%B1%82%E9%9D%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%A0%E5%AD%90%E5%9B%BE%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%8F%92%E5%8D%B3%E7%94%A8"><span class="toc-number">1.14.4.2.</span> <span class="toc-text">理论层面：为什么因子图能实现即插即用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E8%BF%9Bg_ii-i_dtimes-d"><span class="toc-number">1.15.</span> <span class="toc-text">为什么要引进\(G_i^i&#x3D;-I_{d\times d}\)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E7%9F%A9%E9%98%B5i"><span class="toc-number">1.16.</span> <span class="toc-text">信息矩阵\(I\)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Eax-b-%E4%B8%ADa%E5%92%8Cb%E7%9A%84%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89"><span class="toc-number">1.17.</span> <span class="toc-text">关于AX-b 中A和b的物理意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%A4%E6%B3%A2%E5%99%A8%E4%B8%8E%E5%B9%B3%E6%BB%91%E5%99%A8"><span class="toc-number">1.18.</span> <span class="toc-text">滤波器与平滑器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.18.1.</span> <span class="toc-text">滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%83%85%E6%99%AF"><span class="toc-number">1.18.1.1.</span> <span class="toc-text">示例情景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">1.18.1.2.</span> <span class="toc-text">边缘化过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">1.18.1.3.</span> <span class="toc-text">结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E7%9B%B4%E8%A7%82"><span class="toc-number">1.18.1.4.</span> <span class="toc-text">几何直观</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E6%BB%91"><span class="toc-number">1.18.2.</span> <span class="toc-text">平滑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%B9%B3%E6%BB%91%E4%B8%AD%E4%BB%8D%E7%84%B6%E4%BC%9A%E6%9C%89%E5%8F%98%E9%87%8F%E6%B6%88%E9%99%A4"><span class="toc-number">1.18.3.</span> <span class="toc-text">为什么在平滑中仍然会有变量消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E5%85%83%E6%A0%91"><span class="toc-number">1.18.4.</span> <span class="toc-text">消元树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qr%E5%88%86%E8%A7%A3"><span class="toc-number">1.19.</span> <span class="toc-text">QR分解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8cholesky-%E5%88%86%E8%A7%A3%E6%B1%82%E8%A7%A3%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B"><span class="toc-number">1.20.</span> <span class="toc-text">为什么用Cholesky
分解求解正规方程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5-%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0"><span class="toc-number">1.21.</span> <span class="toc-text">一些相关链接 不定时更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%85%B3%E6%B3%A8%E7%9A%84blog-%E5%A4%9A%E6%BA%90%E8%9E%8D%E5%90%88"><span class="toc-number">1.21.1.</span> <span class="toc-text">可以关注的blog 多源融合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.21.2.</span> <span class="toc-text">理论学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A4%E6%B3%A2%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">1.21.2.1.</span> <span class="toc-text">滤波优化算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B"><span class="toc-number">1.21.3.</span> <span class="toc-text">代码编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gtsam%E5%BA%93"><span class="toc-number">1.21.3.1.</span> <span class="toc-text">GTSAM库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%83%BD%E5%8A%9B"><span class="toc-number">1.21.3.2.</span> <span class="toc-text">代码能力</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/21/hexo-config/" title="hexo &amp; git"><img src="/img/top-img/baofu.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo &amp; git"/></a><div class="content"><a class="title" href="/2025/05/21/hexo-config/" title="hexo &amp; git">hexo &amp; git</a><time datetime="2025-05-21T08:19:57.000Z" title="发表于 2025-05-21 16:19:57">2025-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/21/ccs-bug/" title="【ccs debug】error"><img src="/img/top-img/stm32.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【ccs debug】error"/></a><div class="content"><a class="title" href="/2025/05/21/ccs-bug/" title="【ccs debug】error">【ccs debug】error</a><time datetime="2025-05-21T07:40:50.000Z" title="发表于 2025-05-21 15:40:50">2025-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/stm32_debug/" title="【stm32 bug那些事儿】"><img src="/img/top-img/stm32.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【stm32 bug那些事儿】"/></a><div class="content"><a class="title" href="/2025/03/17/stm32_debug/" title="【stm32 bug那些事儿】">【stm32 bug那些事儿】</a><time datetime="2025-03-17T12:02:16.000Z" title="发表于 2025-03-17 20:02:16">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/16/STM32-SPI%E9%80%9A%E4%BF%A1/" title="【STM32学习】SPI通信"><img src="/img/top-img/stm32.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【STM32学习】SPI通信"/></a><div class="content"><a class="title" href="/2025/03/16/STM32-SPI%E9%80%9A%E4%BF%A1/" title="【STM32学习】SPI通信">【STM32学习】SPI通信</a><time datetime="2025-03-16T11:41:00.000Z" title="发表于 2025-03-16 19:41:00">2025-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/debug/" title="关于OB-GINS在VScode调试配置设置"><img src="/img/top-img/C++.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于OB-GINS在VScode调试配置设置"/></a><div class="content"><a class="title" href="/2024/10/22/debug/" title="关于OB-GINS在VScode调试配置设置">关于OB-GINS在VScode调试配置设置</a><time datetime="2024-10-22T03:12:29.000Z" title="发表于 2024-10-22 11:12:29">2024-10-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 汐汐</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi，welocme to my blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23lilBvAg6ryz910Bq',
      clientSecret: '35f8ef4fa5095c847021e15ea2be9f3c413e55b8',
      repo: 'xi-song.github.io',
      owner: 'xi-song',
      admin: ['xi-song'],
      id: '9277fe65923d311903db3d74a76158f3',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/styles/fish.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>